好的，这是为您生成的纲领性文件的Markdown格式版本。

AI驱动的软件开发工作流 (AI-Driven Development Workflow - ADW)

版本: 1.0
作者: [你的名字/团队名]
核心理念: 本工作流旨在重塑软件开发范式，将人类开发者的角色从“代码工匠”转变为“领航员”，将AI定位为不知疲倦、极致精确的“执行引擎”。开发者负责设定愿景、做出关键决策和质量把控；AI负责具体的编码、埋点、调试等繁重工作。此流程的目标是赋能开发者，尤其是初级开发者，使其能够在结构化指导下，高效地产出高质量、可维护、可观测的软件产品。

第一章：核心原则

迭代是核心 (Iteration is Key): 每个步骤都不是一次性的，而是一个“指令-生成-审查-修正”的快速迭代循环。允许犯错，快速修正。

流程即导师 (Process as Mentor): 严格遵循本流程，本身就是在应用行业最佳实践。流程将引导你关注架构、测试、可观测性等关键领域。

文档驱动 (Documentation-Driven): 关键步骤之间通过结构化的文档（如产品规格、测试用例、技术规格）进行解耦和通信，确保人与AI的理解一致。

可观测性是基石 (Observability is Bedrock): 系统从设计之初就内置了为AI调试而生的日志系统。没有可观测性，就没有AI自主调试。

自动化测试是最终裁判 (Tests as the Ultimate Judge): 系统的“正确性”由一套完备的自动化测试用例来定义和验证。AI的修复工作以“通过所有测试”为最终目标。

第二章：工作流五大阶段
阶段一：构思与规格化 (Conception & Specification)

目标: 将一个模糊的想法（Idea）转化为AI可以理解和执行的、清晰的、结构化的规格文档。

步骤 1.1: 需求对话与产品文档生成

领航员: 与AI进行多轮对话，描述产品愿景和核心功能。

AI引擎: 生成初始的产品文档。

迭代循环: 领航员通过追问、补充边缘场景、要求澄清等方式，与AI共同打磨产品文档，直至其清晰、完备。

步骤 1.2: 自动化测试用例生成

领航员: 指示AI：“根据最终版的产品文档，为每个功能点生成详细的测试用例（单元测试和集成测试），覆盖成功、失败和边界场景。”

AI引擎: 生成测试用例描述或代码骨架。

迭代循环: 领航员审查测试用例的覆盖度，确保它们能作为产品“正确性”的最终裁判。

阶段二：架构设计与编码 (Architecture & Coding)

目标: 在一个稳固的架构之上，高效地生成代码。

步骤 2.1: 架构设计与评审

领航员: 指示AI：“基于产品文档，为这个项目设计一个软件架构，包括目录结构、核心模块划分和关键数据结构。”

AI引擎: 提出1-2个架构方案。

迭代循环: 此步骤需要领航员进行关键决策。选择或修正架构方案，直到它符合项目的规模和复杂度预期。

步骤 2.2: 代码生成

领航员: 指示AI：“根据已确认的架构和产品文档，生成完整的代码。” （也可采用先生成脚手架，再填充逻辑的方式，以增强可控性）

AI引擎: 生成源代码。

迭代循环: 领航员进行代码抽查，确保代码风格和结构基本符合预期。可进行多次微调。

阶段三：可观测性注入 (Observability Injection)

目标: 为生成的代码自动植入一套服务于AI自主调试的、标准化的日志系统。

步骤 3.1: 业务流程分析

领航员: 发起自动化任务。

AI引擎:

读取项目源代码。

使用 prompt/业务函数流程提示词.toml 作为指导，生成一份详细的技术规格与流程分析文档 docs/implementation_spec.md。

迭代循环: 领航员快速审查 docs/implementation_spec.md，重点检查“业务流程类型”（高频/低频）的划分是否准确。如有偏差，直接在文档中修正或向AI提出修正指令。

步骤 3.2: 自动化日志埋点

领航员: 发起自动化任务。

AI引擎:

读取 docs/implementation_spec.md 和源代码。

使用 prompt/日志埋点提示词2.toml 作为核心规则。

生成带有完整、标准化日志埋点的代码。建议运行两次，一次输出完整代码，一次输出局部diff，综合采纳。

迭代循环: 此步骤自动化程度很高，通常只需在AI执行出错时进行干预。

阶段四：编译与调试循环 (Compile & Debug Loop)

目标: 打造一个快速的反馈闭环，系统性地消除编译错误和运行时问题。

步骤 4.1: 编译-静态分析循环

领航员: 运行 cargo build && cargo clippy。

AI引擎: 如果出现编译或静态分析错误，将错误信息作为输入，AI会自动进行代码修复。

迭代循环: 重复此过程，直到代码能够成功编译。

步骤 4.2: 运行与日志生成

领航员: 运行程序，并执行在阶段一中定义的自动化测试集。

系统产出: 生成三种日志文件：

logs/low_freq.log: 记录程序生命周期中的关键检查点。

logs/problem_summary.log: 问题索引，记录所有WARN/ERROR事件。

logs/ai_detailed.log: 包含所有细节的追踪日志。

步骤 4.3: AI自主调试

触发条件: 自动化测试失败，或 logs/problem_summary.log 中出现新的条目。

领航员: 将触发信号（测试失败报告或日志条目）交给AI。

AI引擎:

严格遵循 prompt/AI调试提示词.md 中定义的SOP（标准操作流程）。

通过分析日志、查询上下文、交叉引用源代码，定位问题根因。

提出具体的代码修复方案（如diff）。

迭代循环: 领航员审查AI的分析报告和修复方案。如果合理，则应用修改，并返回步骤4.1，开始新一轮的“编译-测试-调试”大循环。

阶段五：交付 (Delivery)

目标: 得到一个经过充分验证的、可用的软件Demo。

步骤 5.1: 退出循环

循环终止条件:

所有自动化测试用例均已通过。

在完整的测试运行期间，logs/problem_summary.log 保持为空。

步骤 5.2: 交付产物

一个功能正确、代码健壮、并且内置了先进可观测性系统的软件Demo。

附录：工具与Prompt清单

核心Prompt:

prompt/业务函数流程提示词.toml: 定义了如何从代码中逆向工程出业务流程。

prompt/日志埋点提示词2.toml: 定义了如何为代码植入标准化的日志。

prompt/AI调试提示词.md: 定义了AI进行自主调试的专家级SOP。

关键产出:

docs/implementation_spec.md: 连接代码与日志埋点的桥梁。

logs/*.log: AI自主调试的信息来源。