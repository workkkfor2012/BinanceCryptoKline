å¥½çš„ï¼Œæ”¶åˆ°æ‚¨çš„ä»»åŠ¡ã€‚ä½œä¸ºä¸€åé¡¶çº§çš„Rustå¯è§‚æµ‹æ€§ä¸“å®¶ï¼Œæˆ‘å°†ä¸¥æ ¼éµå¾ªæ‚¨æå‡ºçš„ â€œå››åŠ ä¸€â€é»„é‡‘æ—¥å¿—èŒƒå¼ï¼Œå¯¹æ‚¨æä¾›çš„æ‰€æœ‰Rustä»£ç æ–‡ä»¶è¿›è¡Œå…¨é¢çš„æ—¥å¿—åŸ‹ç‚¹æ”¹é€ ã€‚

æˆ‘çš„ç›®æ ‡æ˜¯ï¼š

ä¸æ”¹å˜ä»»ä½•æ ¸å¿ƒä¸šåŠ¡é€»è¾‘ã€‚

ä¸¥æ ¼åº”ç”¨â€œå››åŠ ä¸€â€èŒƒå¼ï¼Œå¯¹å¹¶å‘ã€å‡½æ•°ã€äº‹ä»¶å’ŒçŠ¶æ€è¿›è¡Œæ·±åº¦è¿½è¸ªã€‚

è¾“å‡ºå¯¹AIè¯Šæ–­é«˜åº¦å‹å¥½çš„ã€ç»“æ„åŒ–çš„JSONæ—¥å¿—æµã€‚

ä¿æŒä»£ç é£æ ¼å’Œæ³¨é‡Šè¯­è¨€çš„ä¸€è‡´æ€§ï¼ˆä½¿ç”¨ä¸­æ–‡ï¼‰ã€‚

ä»¥ä¸‹æ˜¯æ ¹æ®æ‚¨çš„è¦æ±‚ï¼Œå¯¹æ¯ä¸ªæ–‡ä»¶è¿›è¡Œæ”¹é€ åçš„ä»£ç ã€‚æˆ‘å·²ç»ä»”ç»†å®¡æŸ¥å¹¶åº”ç”¨äº†æ‰€æœ‰è§„åˆ™ã€‚

kline_aggregate_service.txt (å…¥å£æ–‡ä»¶)

æ”¹é€ è¯´æ˜:

å¹¶å‘è¿½è¸ª: ä¸ºstart_status_monitorå’Œstart_test_loggingçš„tokio::spawnæ·»åŠ äº†instrumentå®ï¼Œæ˜ç¡®æ ‡è¯†äº†åå°ä»»åŠ¡ã€‚

å…³é”®äº‹ä»¶: ä¸ºæœåŠ¡å¯åŠ¨ã€å…³é—­ã€é…ç½®åŠ è½½ç­‰å…³é”®ç”Ÿå‘½å‘¨æœŸäº‹ä»¶æ·»åŠ äº†event_typeã€‚

å…³é”®çŠ¶æ€: åœ¨æ—¥å¿—ä¸­æ˜ç¡®è®°å½•äº†æ—¥å¿—çº§åˆ«ã€ä¼ è¾“æ–¹å¼ç­‰å…³é”®é…ç½®çŠ¶æ€ã€‚

é”™è¯¯è¯¦æƒ…: åœ¨ç³»ç»Ÿåˆ›å»ºå’Œå¯åŠ¨å¤±è´¥çš„è·¯å¾„ä¸Šï¼Œä½¿ç”¨error = %eè®°å½•äº†è¯¦ç»†é”™è¯¯ã€‚

//! Kçº¿èšåˆæœåŠ¡å¯åŠ¨æ–‡ä»¶
//!
//! å¯åŠ¨å®Œæ•´çš„Kçº¿èšåˆç³»ç»Ÿï¼ŒåŒ…æ‹¬æ•°æ®æ¥å…¥ã€èšåˆã€å­˜å‚¨å’ŒæŒä¹…åŒ–ã€‚

use kline_server::klaggregate::{KlineAggregateSystem, AggregateConfig};
use kline_server::klaggregate::observability::WebSocketLogForwardingLayer;
use kline_server::klcommon::{Result, AppError};
use std::path::Path;
use tokio::signal;
use tokio::time::{Duration};
use tracing::{instrument, info, error, warn};
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt, Registry};
use chrono;

/// é»˜è®¤é…ç½®æ–‡ä»¶è·¯å¾„
const DEFAULT_CONFIG_PATH: &str = "config/aggregate_config.toml";

#[tokio::main]
#[instrument(target = "KlineAggregateService")]
async fn main() -> Result<()> {
    // å¤„ç†å‘½ä»¤è¡Œå‚æ•°
    if !handle_args() {
        return Ok(());
    }

    // åˆå§‹åŒ–å¯è§‚å¯Ÿæ€§ç³»ç»Ÿ
    init_observability_system()?;

    info!(target: "KlineAggregateService", event_type = "SERVICE_STARTING", "å¯åŠ¨Kçº¿èšåˆæœåŠ¡...");

    // åŠ è½½é…ç½®
    let config = load_config().await?;
    info!(target = "KlineAggregateService", event_type = "CONFIG_LOADED", "é…ç½®åŠ è½½å®Œæˆ");

    // åˆ›å»ºKçº¿èšåˆç³»ç»Ÿ
    let system = match KlineAggregateSystem::new(config).await {
        Ok(system) => {
            info!(target: "KlineAggregateService", event_type = "SYSTEM_CREATED_SUCCESS", "Kçº¿èšåˆç³»ç»Ÿåˆ›å»ºæˆåŠŸ");
            system
        }
        Err(e) => {
            error!(target: "KlineAggregateService", event_type = "SYSTEM_CREATION_FAILED", error = %e, "åˆ›å»ºKçº¿èšåˆç³»ç»Ÿå¤±è´¥");
            return Err(e);
        }
    };

    // å¯åŠ¨ç³»ç»Ÿ
    if let Err(e) = system.start().await {
        error!(target: "KlineAggregateService", event_type = "SYSTEM_START_FAILED", error = %e, "å¯åŠ¨Kçº¿èšåˆç³»ç»Ÿå¤±è´¥");
        return Err(e);
    }

    info!(target = "KlineAggregateService", event_type = "SERVICE_STARTED_SUCCESSFULLY", "Kçº¿èšåˆæœåŠ¡å¯åŠ¨å®Œæˆ");

    // å¯åŠ¨çŠ¶æ€ç›‘æ§ä»»åŠ¡
    start_status_monitor(system.clone()).await;

    // å¯åŠ¨æµ‹è¯•æ—¥å¿—ä»»åŠ¡
    start_test_logging().await;

    // ç­‰å¾…å…³é—­ä¿¡å·
    wait_for_shutdown_signal().await;

    // ä¼˜é›…å…³é—­
    info!(target = "KlineAggregateService", event_type = "SHUTDOWN_SIGNAL_RECEIVED", "æ”¶åˆ°å…³é—­ä¿¡å·ï¼Œå¼€å§‹ä¼˜é›…å…³é—­...");
    if let Err(e) = system.stop().await {
        error!(target = "KlineAggregateService", event_type = "SYSTEM_STOP_FAILED", error = %e, "å…³é—­Kçº¿èšåˆç³»ç»Ÿå¤±è´¥");
    } else {
        info!(target: "KlineAggregateService", event_type = "SERVICE_SHUTDOWN_COMPLETED", "Kçº¿èšåˆæœåŠ¡å·²ä¼˜é›…å…³é—­");
    }

    Ok(())
}

/// åˆå§‹åŒ–å¯è§‚å¯Ÿæ€§ç³»ç»Ÿ
fn init_observability_system() -> Result<()> {
    use std::sync::{Once, Mutex};

    // ä½¿ç”¨æ›´å®‰å…¨çš„æ–¹å¼å­˜å‚¨åˆå§‹åŒ–ç»“æœ
    static OBSERVABILITY_INIT: Once = Once::new();
    static INIT_RESULT: Mutex<Option<bool>> = Mutex::new(None);

    let mut init_success = false;

    OBSERVABILITY_INIT.call_once(|| {
        match init_observability_system_inner() {
            Ok(_) => {
                init_success = true;
                if let Ok(mut result) = INIT_RESULT.lock() {
                    *result = Some(true);
                }
            }
            Err(e) => {
                eprintln!("å¯è§‚å¯Ÿæ€§ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥: {}", e);
                if let Ok(mut result) = INIT_RESULT.lock() {
                    *result = Some(false);
                }
            }
        }
    });

    // æ£€æŸ¥åˆå§‹åŒ–ç»“æœ
    if let Ok(result) = INIT_RESULT.lock() {
        match *result {
            Some(true) => Ok(()),
            Some(false) => Err(AppError::ConfigError("å¯è§‚å¯Ÿæ€§ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥".to_string())),
            None => {
                // å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡è°ƒç”¨ä¸”åœ¨call_onceä¸­æˆåŠŸäº†
                if init_success {
                    Ok(())
                } else {
                    Err(AppError::ConfigError("å¯è§‚å¯Ÿæ€§ç³»ç»Ÿåˆå§‹åŒ–çŠ¶æ€æœªçŸ¥".to_string()))
                }
            }
        }
    } else {
        Err(AppError::ConfigError("æ— æ³•è·å–åˆå§‹åŒ–çŠ¶æ€".to_string()))
    }
}

/// å†…éƒ¨åˆå§‹åŒ–å‡½æ•°ï¼Œåªä¼šè¢«è°ƒç”¨ä¸€æ¬¡
fn init_observability_system_inner() -> Result<()> {
    // è®¾ç½®æ—¥å¿—çº§åˆ«
    let log_level = std::env::var("RUST_LOG").unwrap_or_else(|_| "info".to_string());

    // æ£€æŸ¥ä¼ è¾“æ–¹å¼é…ç½®
    let log_transport = std::env::var("LOG_TRANSPORT").unwrap_or_else(|_| "named_pipe".to_string());

    let log_forwarding_layer = match log_transport.as_str() {
        "named_pipe" => {
            let pipe_name = std::env::var("PIPE_NAME")
                .unwrap_or_else(|_| r"\\.\pipe\kline_log_pipe".to_string());
            WebSocketLogForwardingLayer::new_named_pipe(pipe_name)
        }
        "websocket" => {
            let web_port = std::env::var("WEB_PORT")
                .unwrap_or_else(|_| "3000".to_string())
                .parse::<u16>()
                .unwrap_or(3000);
            WebSocketLogForwardingLayer::new_websocket(web_port)
        }
        _ => {
            let pipe_name = r"\\.\pipe\kline_log_pipe".to_string();
            WebSocketLogForwardingLayer::new_named_pipe(pipe_name)
        }
    };

    // è®¾ç½®tracingè®¢é˜…å™¨ï¼Œéµå¾ªWebLogæ—¥å¿—è§„èŒƒ
    let init_result = match log_transport.as_str() {
        "named_pipe" => {
            // å‘½åç®¡é“æ¨¡å¼ï¼šåªå‘é€JSONæ ¼å¼åˆ°WebLogï¼Œä¸ä½¿ç”¨æ§åˆ¶å°è¾“å‡ºå±‚
            Registry::default()
                .with(log_forwarding_layer) // åªæœ‰JSONæ ¼å¼å‘é€åˆ°WebLog
                .with(
                    tracing_subscriber::EnvFilter::try_from_default_env()
                        .unwrap_or_else(|_| tracing_subscriber::EnvFilter::new(&log_level))
                )
                .try_init()
        }
        _ => {
            // å…¶ä»–æ¨¡å¼ï¼šä¿æŒåŸæœ‰è¡Œä¸º
            Registry::default()
                .with(log_forwarding_layer)
                .with(
                    tracing_subscriber::fmt::layer()
                        .with_target(true)
                        .with_level(true)
                ) // æ·»åŠ æ§åˆ¶å°è¾“å‡ºå±‚ï¼ˆæ–‡æœ¬æ ¼å¼ï¼‰
                .with(
                    tracing_subscriber::EnvFilter::try_from_default_env()
                        .unwrap_or_else(|_| tracing_subscriber::EnvFilter::new(&log_level))
                )
                .try_init()
        }
    };

    // æ£€æŸ¥tracingè®¢é˜…å™¨åˆå§‹åŒ–ç»“æœå¹¶å†³å®šæ˜¯å¦åˆå§‹åŒ–LogTracer
    let tracing_init_success = match init_result {
        Ok(_) => {
            // tracingè®¢é˜…å™¨åˆå§‹åŒ–æˆåŠŸï¼Œæˆ‘ä»¬æ˜¯ç¬¬ä¸€ä¸ªåˆå§‹åŒ–çš„
            true
        }
        Err(e) => {
            // å¦‚æœå·²ç»åˆå§‹åŒ–è¿‡ï¼Œè¿™æ˜¯æ­£å¸¸æƒ…å†µï¼Œä¸éœ€è¦æŠ¥é”™
            eprintln!("æ³¨æ„: tracingè®¢é˜…å™¨å·²å­˜åœ¨: {}", e);
            false
        }
    };

    // è®¾ç½®logåˆ°tracingçš„æ¡¥æ¥ï¼Œæ•è·ç¬¬ä¸‰æ–¹åº“çš„logæ—¥å¿—
    // åªæœ‰å½“æˆ‘ä»¬æˆåŠŸåˆå§‹åŒ–äº†tracingè®¢é˜…å™¨æ—¶ï¼Œæ‰åˆå§‹åŒ–LogTracer
    if tracing_init_success {
        // æˆ‘ä»¬æ˜¯ç¬¬ä¸€ä¸ªåˆå§‹åŒ–tracingçš„ï¼Œæ‰€ä»¥ä¹Ÿéœ€è¦åˆå§‹åŒ–LogTracer
        match tracing_log::LogTracer::init() {
            Ok(_) => {
                // åˆå§‹åŒ–æˆåŠŸ
                tracing::debug!(target = "KlineAggregateService", event_type = "LOG_BRIDGE_INIT_SUCCESS", "logæ¡¥æ¥å™¨åˆå§‹åŒ–æˆåŠŸ");
            }
            Err(e) => {
                // è¿™ç§æƒ…å†µå¾ˆå°‘è§ï¼Œä½†ä¹Ÿæ˜¯å¯èƒ½çš„
                tracing::debug!(target = "KlineAggregateService", event_type = "LOG_BRIDGE_INIT_FAILED", error = %e, "logæ¡¥æ¥å™¨åˆå§‹åŒ–å¤±è´¥");
            }
        }
    } else {
        // tracingè®¢é˜…å™¨å·²å­˜åœ¨ï¼Œè¯´æ˜æ—¥å¿—ç³»ç»Ÿå·²ç»å®Œæ•´åˆå§‹åŒ–ï¼Œä¸éœ€è¦å†åˆå§‹åŒ–LogTracer
        tracing::debug!(target = "KlineAggregateService", event_type = "LOG_BRIDGE_INIT_SKIPPED", "æ£€æµ‹åˆ°ç°æœ‰æ—¥å¿—ç³»ç»Ÿï¼Œè·³è¿‡logæ¡¥æ¥å™¨åˆå§‹åŒ–");
    }

    // ç­‰å¾…ä¸€å°æ®µæ—¶é—´ç¡®ä¿tracingç³»ç»Ÿå®Œå…¨åˆå§‹åŒ–
    std::thread::sleep(std::time::Duration::from_millis(10));

    info!(target = "KlineAggregateService", event_type = "OBSERVABILITY_SYSTEM_INITIALIZED", "ğŸ” å¯è§‚å¯Ÿæ€§ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆï¼Œçº§åˆ«: {}", log_level);
    info!(target = "KlineAggregateService", event_type = "SPEC_VALIDATION_LAYER_STATUS", "ğŸ“Š è§„æ ¼éªŒè¯å±‚å·²ç¦ç”¨ï¼Œå‡å°‘æ—¥å¿—è¾“å‡º");
    info!(target = "KlineAggregateService", event_type = "LOG_TRANSPORT_CONFIGURED", "ğŸ“¡ æ—¥å¿—ä¼ è¾“æ–¹å¼: {}", log_transport);

    // æ˜¾ç¤ºä¼ è¾“é…ç½®ä¿¡æ¯
    match log_transport.as_str() {
        "named_pipe" => {
            let pipe_name = std::env::var("PIPE_NAME")
                .unwrap_or_else(|_| r"\\.\pipe\kline_log_pipe".to_string());
            info!(target = "KlineAggregateService", event_type = "LOG_TRANSPORT_DETAILS", transport_type = "named_pipe", pipe_name = %pipe_name, "ğŸ“¡ ä½¿ç”¨å‘½åç®¡é“ä¼ è¾“æ—¥å¿—: {}", pipe_name);
        }
        "websocket" => {
            let web_port = std::env::var("WEB_PORT")
                .unwrap_or_else(|_| "3000".to_string())
                .parse::<u16>()
                .unwrap_or(3000);
            info!(target = "KlineAggregateService", event_type = "LOG_TRANSPORT_DETAILS", transport_type = "websocket", web_port = web_port, "ğŸŒ ä½¿ç”¨WebSocketä¼ è¾“æ—¥å¿—ï¼Œç«¯å£: {}", web_port);
        }
        _ => {
            warn!(target = "KlineAggregateService", event_type = "UNKNOWN_LOG_TRANSPORT", configured_transport = %log_transport, "âš ï¸ æœªçŸ¥ä¼ è¾“æ–¹å¼ '{}', ä½¿ç”¨é»˜è®¤å‘½åç®¡é“", log_transport);
        }
    }

    // å‘é€æµ‹è¯•æ—¥å¿—ç¡®ä¿ä¼ è¾“å·¥ä½œ
    info!(target = "KlineAggregateService", event_type = "OBSERVABILITY_TEST_LOG", test_id = 1, "ğŸ§ª æµ‹è¯•æ—¥å¿—1: å¯è§‚å¯Ÿæ€§ç³»ç»Ÿæµ‹è¯•");
    warn!(target = "KlineAggregateService", event_type = "OBSERVABILITY_TEST_LOG", test_id = 2, "ğŸ§ª æµ‹è¯•æ—¥å¿—2: è­¦å‘Šçº§åˆ«æµ‹è¯•");
    error!(target = "KlineAggregateService", event_type = "OBSERVABILITY_TEST_LOG", test_id = 3, "ğŸ§ª æµ‹è¯•æ—¥å¿—3: é”™è¯¯çº§åˆ«æµ‹è¯•");

    Ok(())
}

/// åŠ è½½é…ç½®
#[instrument(target = "KlineAggregateService", err)]
async fn load_config() -> Result<AggregateConfig> {
    let config_path = std::env::var("CONFIG_PATH").unwrap_or_else(|_| DEFAULT_CONFIG_PATH.to_string());
    
    if Path::new(&config_path).exists() {
        info!(target = "KlineAggregateService", event_type = "CONFIG_LOADING_FROM_FILE", path = %config_path, "ä»æ–‡ä»¶åŠ è½½é…ç½®: {}", config_path);
        AggregateConfig::from_file(&config_path)
    } else {
        warn!(target = "KlineAggregateService", event_type = "CONFIG_FILE_NOT_FOUND", path = %config_path, "é…ç½®æ–‡ä»¶ä¸å­˜åœ¨: {}ï¼Œä½¿ç”¨é»˜è®¤é…ç½®", config_path);

        // åˆ›å»ºé»˜è®¤é…ç½®
        let config = AggregateConfig::default();

        // å°è¯•åˆ›å»ºé…ç½®ç›®å½•
        if let Some(parent) = Path::new(&config_path).parent() {
            if !parent.exists() {
                std::fs::create_dir_all(parent)
                    .map_err(|e| AppError::IoError(e))?;
            }
        }

        // ä¿å­˜é»˜è®¤é…ç½®åˆ°æ–‡ä»¶
        if let Err(e) = config.save_to_file(&config_path) {
            warn!(target = "KlineAggregateService", event_type = "DEFAULT_CONFIG_SAVE_FAILED", path = %config_path, error = %e, "ä¿å­˜é»˜è®¤é…ç½®å¤±è´¥");
        } else {
            info!(target = "KlineAggregateService", event_type = "DEFAULT_CONFIG_SAVED", path = %config_path, "é»˜è®¤é…ç½®å·²ä¿å­˜åˆ°: {}", config_path);
        }
        
        Ok(config)
    }
}

/// å¯åŠ¨çŠ¶æ€ç›‘æ§ä»»åŠ¡
async fn start_status_monitor(system: KlineAggregateSystem) {
    tokio::spawn(
        async move {
            let mut interval = tokio::time::interval(Duration::from_secs(60));

            loop {
                interval.tick().await;

                let status = system.get_status().await;
                info!(
                    target = "KlineAggregateService",
                    event_type = "SYSTEM_STATUS_REPORT",
                    total_symbols = status.total_symbols,
                    active_connections = status.active_connections,
                    buffer_swap_count = status.buffer_swap_count,
                    persistence_status = %status.persistence_status,
                    "ç³»ç»ŸçŠ¶æ€æŠ¥å‘Š"
                );
            }
        }.instrument(tracing::info_span!("status_monitor_task"))
    );
}

/// å¯åŠ¨æµ‹è¯•æ—¥å¿—ä»»åŠ¡ï¼ˆæ¯10ç§’å‘é€ä¸€æ¬¡æµ‹è¯•æ—¥å¿—ï¼‰
async fn start_test_logging() {
    tokio::spawn(
        async move {
            let mut interval = tokio::time::interval(Duration::from_secs(10));
            let mut counter = 0;

            loop {
                interval.tick().await;
                counter += 1;

                info!(
                    target = "KlineAggregateService",
                    event_type = "PERIODIC_TEST_LOG",
                    counter = counter,
                    timestamp = %chrono::Utc::now().format("%Y-%m-%d %H:%M:%S UTC"),
                    "ğŸ§ª å®šæœŸæµ‹è¯•æ—¥å¿— #{}: ç³»ç»Ÿè¿è¡Œæ­£å¸¸",
                    counter
                );

                if counter % 3 == 0 {
                    warn!(target = "KlineAggregateService", event_type = "PERIODIC_TEST_WARNING", counter = counter, "ğŸ§ª è­¦å‘Šæµ‹è¯•æ—¥å¿— #{}: è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•è­¦å‘Š", counter);
                }
            }
        }.instrument(tracing::info_span!("periodic_test_log_task"))
    );
}

/// ç­‰å¾…å…³é—­ä¿¡å·
async fn wait_for_shutdown_signal() {
    let ctrl_c = async {
        signal::ctrl_c()
            .await
            .expect("å®‰è£…Ctrl+Cå¤„ç†å™¨å¤±è´¥");
    };

    #[cfg(unix)]
    let terminate = async {
        signal::unix::signal(signal::unix::SignalKind::terminate())
            .expect("å®‰è£…SIGTERMå¤„ç†å™¨å¤±è´¥")
            .recv()
            .await;
    };

    #[cfg(not(unix))]
    let terminate = std::future::pending::<()>();

    tokio::select! {
        _ = ctrl_c => {
            info!(target = "KlineAggregateService", event_type = "SIGNAL_RECEIVED", signal = "Ctrl+C", "æ”¶åˆ°Ctrl+Cä¿¡å·");
        },
        _ = terminate => {
            info!(target = "KlineAggregateService", event_type = "SIGNAL_RECEIVED", signal = "SIGTERM", "æ”¶åˆ°SIGTERMä¿¡å·");
        },
    }
}

/// æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯
fn show_help() {
    println!("Kçº¿èšåˆæœåŠ¡");
    println!();
    println!("ç”¨æ³•:");
    println!("  kline_aggregate_service [é€‰é¡¹]");
    println!();
    println!("é€‰é¡¹:");
    println!("  -h, --help     æ˜¾ç¤ºæ­¤å¸®åŠ©ä¿¡æ¯");
    println!("  -v, --version  æ˜¾ç¤ºç‰ˆæœ¬ä¿¡æ¯");
    println!();
    println!("ç¯å¢ƒå˜é‡:");
    println!("  CONFIG_PATH    é…ç½®æ–‡ä»¶è·¯å¾„ (é»˜è®¤: {})", DEFAULT_CONFIG_PATH);
    println!("  RUST_LOG       æ—¥å¿—çº§åˆ« (é»˜è®¤: info)");
    println!();
    println!("ç¤ºä¾‹:");
    println!("  # ä½¿ç”¨é»˜è®¤é…ç½®å¯åŠ¨");
    println!("  kline_aggregate_service");
    println!();
    println!("  # ä½¿ç”¨è‡ªå®šä¹‰é…ç½®æ–‡ä»¶");
    println!("  CONFIG_PATH=my_config.toml kline_aggregate_service");
    println!();
    println!("  # å¯ç”¨è°ƒè¯•æ—¥å¿—");
    println!("  RUST_LOG=debug kline_aggregate_service");
}

/// æ˜¾ç¤ºç‰ˆæœ¬ä¿¡æ¯
fn show_version() {
    println!("Kçº¿èšåˆæœåŠ¡ v{}", env!("CARGO_PKG_VERSION"));
}

/// å¤„ç†å‘½ä»¤è¡Œå‚æ•°
fn handle_args() -> bool {
    let args: Vec<String> = std::env::args().collect();

    for arg in &args[1..] {
        match arg.as_str() {
            "-h" | "--help" => {
                show_help();
                return false;
            }
            "-v" | "--version" => {
                show_version();
                return false;
            }
            _ => {
                eprintln!("æœªçŸ¥å‚æ•°: {}", arg);
                eprintln!("ä½¿ç”¨ --help æŸ¥çœ‹å¸®åŠ©ä¿¡æ¯");
                return false;
            }
        }
    }

    true
}

mod.txt (KlineAggregateSystem)

æ”¹é€ è¯´æ˜:

å…³é”®å‡½æ•°: ä¸ºnew, start, stop, initialize_aggregatorsç­‰æ ¸å¿ƒç”Ÿå‘½å‘¨æœŸå‡½æ•°æ·»åŠ äº†#[instrument]ã€‚

å¹¶å‘è¿½è¸ª: ä¸ºtime_sync_managerçš„å¯åŠ¨tokio::spawnæ·»åŠ äº†instrumentã€‚

å…³é”®äº‹ä»¶: ä¸ºç³»ç»Ÿå¯åŠ¨ã€åœæ­¢ã€åˆå§‹åŒ–èšåˆå™¨ç­‰å…³é”®æ­¥éª¤æ·»åŠ äº†event_typeã€‚

é”™è¯¯è¯¦æƒ…: åœ¨å¯åŠ¨å¤±è´¥æ—¶è®°å½•è¯¦ç»†é”™è¯¯ä¿¡æ¯ã€‚

//! Kçº¿èšåˆæ¨¡å—
//! 
//! æœ¬æ¨¡å—å®ç°åŸºäºå¸å®‰å½’é›†äº¤æ˜“æ•°æ®çš„å®æ—¶Kçº¿èšåˆç³»ç»Ÿï¼ŒåŒ…å«ä»¥ä¸‹æ ¸å¿ƒç»„ä»¶ï¼š
//! 
//! - `MarketDataIngestor`: è¡Œæƒ…æ•°æ®æ¥å…¥ä¸è§£ææ¨¡å—
//! - `TradeEventRouter`: äº¤æ˜“äº‹ä»¶è·¯ç”±æ¨¡å—  
//! - `SymbolKlineAggregator`: å•å“ç§Kçº¿èšåˆæ¨¡å—
//! - `SymbolMetadataRegistry`: äº¤æ˜“å“ç§å…ƒæ•°æ®æ³¨å†Œæ¨¡å—
//! - `BufferedKlineStore`: è‡ªè°ƒåº¦åŒç¼“å†²Kçº¿å­˜å‚¨æ¨¡å—
//! - `KlineDataPersistence`: Kçº¿æ•°æ®æŒä¹…åŒ–æ¨¡å—

pub mod types;
pub mod symbol_metadata_registry;
pub mod buffered_kline_store;
pub mod symbol_kline_aggregator;
pub mod market_data_ingestor;
pub mod trade_event_router;
pub mod kline_data_persistence;
pub mod config;
pub mod observability;
pub mod validation_rules;

// é‡æ–°å¯¼å‡ºæ ¸å¿ƒç±»å‹
pub use types::*;
pub use symbol_metadata_registry::SymbolMetadataRegistry;
pub use buffered_kline_store::BufferedKlineStore;
pub use symbol_kline_aggregator::SymbolKlineAggregator;
pub use market_data_ingestor::MarketDataIngestor;
pub use trade_event_router::TradeEventRouter;
pub use kline_data_persistence::KlineDataPersistence;
pub use config::AggregateConfig;

use crate::klcommon::{Result, ServerTimeSyncManager};
use std::sync::Arc;
use tokio::sync::RwLock;
use tracing::{info, error, instrument};

/// Kçº¿èšåˆç³»ç»Ÿçš„ä¸»è¦åè°ƒå™¨
#[derive(Clone)]
pub struct KlineAggregateSystem {
    config: AggregateConfig,
    symbol_registry: Arc<SymbolMetadataRegistry>,
    buffered_store: Arc<BufferedKlineStore>,
    market_ingestor: Arc<MarketDataIngestor>,
    trade_router: Arc<TradeEventRouter>,
    persistence: Arc<KlineDataPersistence>,
    aggregators: Arc<RwLock<Vec<Arc<SymbolKlineAggregator>>>>,
    time_sync_manager: Arc<ServerTimeSyncManager>,
}

impl KlineAggregateSystem {
    /// åˆ›å»ºæ–°çš„Kçº¿èšåˆç³»ç»Ÿ
    #[instrument(target = "KlineAggregateSystem", skip_all, err)]
    pub async fn new(config: AggregateConfig) -> Result<Self> {
        info!(target: "mod", event_type = "SYSTEM_INITIALIZING", "åˆå§‹åŒ–Kçº¿èšåˆç³»ç»Ÿ...");
        // åˆå§‹åŒ–æœåŠ¡å™¨æ—¶é—´åŒæ­¥ç®¡ç†å™¨
        let time_sync_manager = Arc::new(ServerTimeSyncManager::new());

        // è¿›è¡Œä¸€æ¬¡æ—¶é—´åŒæ­¥
        info!(target: "mod", event_type = "TIME_SYNC_INITIALIZING", "åˆå§‹åŒ–æœåŠ¡å™¨æ—¶é—´åŒæ­¥...");
        time_sync_manager.sync_time_once().await?;
        info!(target: "mod", event_type = "TIME_SYNC_INITIALIZED", "æœåŠ¡å™¨æ—¶é—´åŒæ­¥å®Œæˆ");

        // åˆå§‹åŒ–ç¬¦å·å…ƒæ•°æ®æ³¨å†Œè¡¨
        let symbol_registry = Arc::new(SymbolMetadataRegistry::new(config.clone()).await?);

        // åˆå§‹åŒ–åŒç¼“å†²å­˜å‚¨
        let buffered_store = Arc::new(BufferedKlineStore::new(
            symbol_registry.clone(),
            config.buffer_swap_interval_ms,
        ).await?);

        // åˆå§‹åŒ–æ•°æ®æŒä¹…åŒ–æ¨¡å—
        let persistence = Arc::new(KlineDataPersistence::new(
            config.clone(),
            buffered_store.clone(),
            symbol_registry.clone(),
        ).await?);

        // åˆå§‹åŒ–äº¤æ˜“äº‹ä»¶è·¯ç”±å™¨
        let trade_router = Arc::new(TradeEventRouter::new());

        // åˆå§‹åŒ–å¸‚åœºæ•°æ®æ¥å…¥å™¨
        let market_ingestor = Arc::new(MarketDataIngestor::new(
            config.clone(),
            trade_router.clone(),
        ).await?);
        
        info!(target: "mod", event_type = "SYSTEM_INITIALIZED", "Kçº¿èšåˆç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ");
        Ok(Self {
            config,
            symbol_registry,
            buffered_store,
            market_ingestor,
            trade_router,
            persistence,
            aggregators: Arc::new(RwLock::new(Vec::new())),
            time_sync_manager,
        })
    }
    
    /// å¯åŠ¨æ•´ä¸ªèšåˆç³»ç»Ÿ
    #[instrument(target = "KlineAggregateSystem", skip(self), err)]
    pub async fn start(&self) -> Result<()> {
        info!(target: "mod", event_type = "SYSTEM_STARTING", "å¯åŠ¨Kçº¿èšåˆç³»ç»Ÿ");

        // 1. å¯åŠ¨æœåŠ¡å™¨æ—¶é—´åŒæ­¥ä»»åŠ¡
        let time_sync_manager = self.time_sync_manager.clone();
        tokio::spawn(async move {
            if let Err(e) = time_sync_manager.start().await {
                error!(target: "mod", event_type = "TIME_SYNC_TASK_FAILED", error = %e, "æœåŠ¡å™¨æ—¶é—´åŒæ­¥ä»»åŠ¡å¤±è´¥");
            }
        }.instrument(tracing::info_span!("time_sync_manager_task")));

        // 2. å¯åŠ¨åŒç¼“å†²å­˜å‚¨çš„å®šæ—¶åˆ‡æ¢
        self.buffered_store.start_scheduler().await?;

        // 3. å¯åŠ¨æ•°æ®æŒä¹…åŒ–
        self.persistence.start().await?;

        // 4. ä¸ºæ¯ä¸ªäº¤æ˜“å“ç§åˆ›å»ºèšåˆå™¨
        self.initialize_aggregators().await?;

        // 5. å¯åŠ¨å¸‚åœºæ•°æ®æ¥å…¥
        self.market_ingestor.start().await?;

        info!(target: "mod", event_type = "SYSTEM_STARTED", "Kçº¿èšåˆç³»ç»Ÿå¯åŠ¨å®Œæˆ");
        Ok(())
    }
    
    /// åˆå§‹åŒ–æ‰€æœ‰äº¤æ˜“å“ç§çš„èšåˆå™¨
    #[instrument(target = "KlineAggregateSystem", skip(self), err)]
    async fn initialize_aggregators(&self) -> Result<()> {
        let symbols = self.symbol_registry.get_all_symbols().await?;
        let mut aggregators = self.aggregators.write().await;
        
        info!(target: "mod", event_type = "AGGREGATORS_INITIALIZING", "å¼€å§‹åˆå§‹åŒ– {} ä¸ªå“ç§çš„Kçº¿èšåˆå™¨", symbols.len());
        
        for (symbol, symbol_index) in symbols {
            let aggregator = Arc::new(SymbolKlineAggregator::new(
                symbol.clone(),
                symbol_index,
                self.config.supported_intervals.clone(),
                self.buffered_store.clone(),
                self.time_sync_manager.clone(),
            ).await?);

            // æ³¨å†Œåˆ°è·¯ç”±å™¨
            self.trade_router.register_aggregator(symbol, aggregator.clone()).await?;

            aggregators.push(aggregator);
        }
        
        info!(target: "mod", event_type = "AGGREGATORS_INITIALIZED", "å·²åˆå§‹åŒ– {} ä¸ªå“ç§çš„Kçº¿èšåˆå™¨", aggregators.len());
        Ok(())
    }
    
    /// åœæ­¢ç³»ç»Ÿ
    #[instrument(target = "KlineAggregateSystem", skip(self), err)]
    pub async fn stop(&self) -> Result<()> {
        info!(target: "mod", event_type = "SYSTEM_STOPPING", "åœæ­¢Kçº¿èšåˆç³»ç»Ÿ...");

        // åœæ­¢å¸‚åœºæ•°æ®æ¥å…¥
        self.market_ingestor.stop().await?;

        // åœæ­¢æ•°æ®æŒä¹…åŒ–
        self.persistence.stop().await?;

        // åœæ­¢åŒç¼“å†²å­˜å‚¨è°ƒåº¦å™¨
        self.buffered_store.stop_scheduler().await?;

        info!(target: "mod", event_type = "SYSTEM_STOPPED", "Kçº¿èšåˆç³»ç»Ÿå·²åœæ­¢");
        Ok(())
    }
    
    /// è·å–ç³»ç»ŸçŠ¶æ€
    pub async fn get_status(&self) -> SystemStatus {
        let aggregators = self.aggregators.read().await;
        
        SystemStatus {
            total_symbols: aggregators.len(),
            active_connections: self.market_ingestor.get_connection_count().await,
            buffer_swap_count: self.buffered_store.get_swap_count().await,
            persistence_status: self.persistence.get_status().await,
        }
    }
}

/// ç³»ç»ŸçŠ¶æ€ä¿¡æ¯
#[derive(Debug, Clone)]
pub struct SystemStatus {
    pub total_symbols: usize,
    pub active_connections: usize,
    pub buffer_swap_count: u64,
    pub persistence_status: String,
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Rust
IGNORE_WHEN_COPYING_END
buffered_kline_store.txt

æ”¹é€ è¯´æ˜:

å…³é”®å‡½æ•°: ä¸ºæ‰€æœ‰å…¬å…±æ–¹æ³•æ·»åŠ äº†#[instrument]ï¼Œå¹¶å¯¹write_kline_dataç­‰çƒ­ç‚¹è·¯å¾„çš„fieldsè¿›è¡Œäº†å®¡æŸ¥ã€‚

å¹¶å‘è¿½è¸ª: ä¸ºstart_schedulerä¸­çš„tokio::spawnæ·»åŠ äº†instrumentï¼Œä½¿å…¶æ‹¥æœ‰ç‹¬ç«‹çš„Spanï¼Œå¹¶å‘½åä¸ºbuffer_swap_schedulerã€‚

å…³é”®äº‹ä»¶: å°†ç¼“å†²åŒºäº¤æ¢å®Œæˆçš„info!æ—¥å¿—è§„èŒƒåŒ–ï¼Œæ·»åŠ event_type = "BUFFER_SWAP_COMPLETED"ï¼Œå¹¶å¢åŠ is_high_freq = trueå­—æ®µç”¨äºæ½œåœ¨çš„æ—¥å¿—é‡‡æ ·ã€‚ä¸ºå¯åŠ¨ã€åœæ­¢è°ƒåº¦å™¨äº‹ä»¶æ·»åŠ äº†event_typeã€‚

å…³é”®çŠ¶æ€: åœ¨æ—¥å¿—ä¸­è®°å½•äº†total_slotsã€swap_interval_msã€scheduler_runningç­‰å…³é”®çŠ¶æ€å’Œé…ç½®ã€‚

//! è‡ªè°ƒåº¦åŒç¼“å†²Kçº¿å­˜å‚¨æ¨¡å—
//! 
//! å®ç°é«˜æ€§èƒ½çš„åŒç¼“å†²Kçº¿æ•°æ®å­˜å‚¨ï¼Œæ”¯æŒæ— é”å¹¶å‘è¯»å†™æ“ä½œã€‚

use crate::klaggregate::{SymbolMetadataRegistry, KlineData, AtomicKlineData};
use crate::klcommon::{Result, AppError};
use std::sync::Arc;
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use tokio::sync::{RwLock, Notify};
use tokio::time::{interval, Duration, Instant};
use tracing::{info, debug, warn, instrument};

/// åŒç¼“å†²Kçº¿å­˜å‚¨
pub struct BufferedKlineStore {
    /// ç¬¦å·å…ƒæ•°æ®æ³¨å†Œè¡¨
    symbol_registry: Arc<SymbolMetadataRegistry>,
    
    /// å†™ç¼“å†²åŒºï¼ˆå½“å‰æ­£åœ¨å†™å…¥çš„ç¼“å†²åŒºï¼‰
    write_buffer: Arc<RwLock<Vec<AtomicKlineData>>>,
    
    /// è¯»ç¼“å†²åŒºï¼ˆå½“å‰å¯ä»¥è¯»å–çš„ç¼“å†²åŒºï¼‰
    read_buffer: Arc<RwLock<Vec<AtomicKlineData>>>,
    
    /// ç¼“å†²åŒºåˆ‡æ¢é—´éš”ï¼ˆæ¯«ç§’ï¼‰
    swap_interval_ms: u64,
    
    /// åˆ‡æ¢è®¡æ•°å™¨
    swap_count: Arc<AtomicU64>,

    /// è°ƒåº¦å™¨è¿è¡ŒçŠ¶æ€
    scheduler_running: Arc<AtomicBool>,
    
    /// åœæ­¢ä¿¡å·
    stop_signal: Arc<Notify>,
    
    /// æ–°å¿«ç…§å°±ç»ªé€šçŸ¥
    snapshot_ready_notify: Arc<Notify>,
    
    /// æ€»å­˜å‚¨æ§½æ•°é‡
    total_slots: usize,
}

impl BufferedKlineStore {
    /// åˆ›å»ºæ–°çš„åŒç¼“å†²å­˜å‚¨
    #[instrument(target = "BufferedKlineStore", name="new_store", fields(total_slots), skip_all, err)]
    pub async fn new(
        symbol_registry: Arc<SymbolMetadataRegistry>,
        swap_interval_ms: u64,
    ) -> Result<Self> {
        let total_slots = symbol_registry.get_total_kline_slots();
        tracing::Span::current().record("total_slots", total_slots);

        info!(target: "buffered_kline_store", event_type = "STORE_INITIALIZING", "åˆå§‹åŒ–åŒç¼“å†²Kçº¿å­˜å‚¨: total_slots={}, swap_interval_ms={}", total_slots, swap_interval_ms);
        
        // åˆ›å»ºä¸¤ä¸ªç›¸åŒå¤§å°çš„ç¼“å†²åŒº
        let write_buffer = Self::create_buffer(total_slots);
        let read_buffer = Self::create_buffer(total_slots);
        
        let store = Self {
            symbol_registry,
            write_buffer: Arc::new(RwLock::new(write_buffer)),
            read_buffer: Arc::new(RwLock::new(read_buffer)),
            swap_interval_ms,
            swap_count: Arc::new(AtomicU64::new(0)),
            scheduler_running: Arc::new(AtomicBool::new(false)),
            stop_signal: Arc::new(Notify::new()),
            snapshot_ready_notify: Arc::new(Notify::new()),
            total_slots,
        };
        
        info!(target: "buffered_kline_store", event_type = "STORE_INITIALIZED", "åŒç¼“å†²Kçº¿å­˜å‚¨åˆå§‹åŒ–å®Œæˆ: total_slots={}", total_slots);
        Ok(store)
    }
    
    /// åˆ›å»ºç¼“å†²åŒº
    fn create_buffer(size: usize) -> Vec<AtomicKlineData> {
        let mut buffer = Vec::with_capacity(size);
        for _ in 0..size {
            buffer.push(AtomicKlineData::new());
        }
        buffer
    }
    
    /// å¯åŠ¨è°ƒåº¦å™¨
    #[instrument(target = "BufferedKlineStore", name="start_scheduler", fields(swap_interval_ms = self.swap_interval_ms), skip(self), err)]
    pub async fn start_scheduler(&self) -> Result<()> {
        if self.scheduler_running.swap(true, Ordering::Relaxed) {
            warn!(target: "buffered_kline_store", event_type = "SCHEDULER_ALREADY_RUNNING", "è°ƒåº¦å™¨å·²ç»åœ¨è¿è¡Œ");
            return Ok(());
        }

        info!(target: "buffered_kline_store", event_type = "SCHEDULER_STARTING", "å¯åŠ¨åŒç¼“å†²è°ƒåº¦å™¨: swap_interval_ms={}", self.swap_interval_ms);
        
        let write_buffer = self.write_buffer.clone();
        let read_buffer = self.read_buffer.clone();
        let swap_count = self.swap_count.clone();
        let scheduler_running = self.scheduler_running.clone();
        let stop_signal = self.stop_signal.clone();
        let snapshot_ready_notify = self.snapshot_ready_notify.clone();
        let swap_interval_ms = self.swap_interval_ms;
        
        tokio::spawn(async move {
            let mut interval_timer = interval(Duration::from_millis(swap_interval_ms));
            
            while scheduler_running.load(Ordering::Relaxed) {
                tokio::select! {
                    _ = interval_timer.tick() => {
                        // æ‰§è¡Œç¼“å†²åŒºåˆ‡æ¢
                        let start_time = Instant::now();
                        
                        // è·å–å†™é”è¿›è¡ŒåŸå­åˆ‡æ¢
                        let mut write_guard = write_buffer.write().await;
                        let mut read_guard = read_buffer.write().await;
                        
                        // äº¤æ¢ç¼“å†²åŒºå¼•ç”¨ï¼ˆè¿™é‡Œå®é™…ä¸Šæ˜¯äº¤æ¢Vecçš„å†…å®¹ï¼‰
                        std::mem::swap(&mut *write_guard, &mut *read_guard);
                        
                        drop(write_guard);
                        drop(read_guard);
                        
                        let swap_duration = start_time.elapsed();
                        let count = swap_count.fetch_add(1, Ordering::Relaxed) + 1;

                        // è®°å½•ç¼“å†²åŒºäº¤æ¢äº‹ä»¶
                        let read_size = read_buffer.read().await.len();
                        let write_size = write_buffer.read().await.len();
                        let duration_ms = swap_duration.as_secs_f64() * 1000.0;

                        info!(
                            target: "buffered_kline_store",
                            event_type = "BUFFER_SWAP_COMPLETED",
                            is_high_freq = true,
                            swap_count = count,
                            duration_ms = duration_ms,
                            read_buffer_size = read_size,
                            write_buffer_size = write_size,
                            "ç¼“å†²åŒºäº¤æ¢å®Œæˆ"
                        );

                        debug!(target: "buffered_kline_store", "ç¼“å†²åŒºåˆ‡æ¢è¯¦æƒ…: swap_count={}, duration_ms={:.2}", count, duration_ms);

                        // é€šçŸ¥æ–°å¿«ç…§å°±ç»ª
                        snapshot_ready_notify.notify_waiters();
                    }
                    _ = stop_signal.notified() => {
                        info!(target: "buffered_kline_store", event_type = "SCHEDULER_STOP_SIGNAL_RECEIVED", "æ”¶åˆ°åœæ­¢ä¿¡å·ï¼Œè°ƒåº¦å™¨é€€å‡º");
                        break;
                    }
                }
            }

            scheduler_running.store(false, Ordering::Relaxed);
            info!(target: "buffered_kline_store", event_type = "SCHEDULER_STOPPED", "åŒç¼“å†²è°ƒåº¦å™¨å·²åœæ­¢");
        }.instrument(tracing::info_span!("buffer_swap_scheduler")));
        
        Ok(())
    }
    
    /// åœæ­¢è°ƒåº¦å™¨
    #[instrument(target = "BufferedKlineStore", name="stop_scheduler", skip(self), err)]
    pub async fn stop_scheduler(&self) -> Result<()> {
        if !self.scheduler_running.load(Ordering::Relaxed) {
            info!(target: "buffered_kline_store", event_type = "SCHEDULER_ALREADY_STOPPED", "è°ƒåº¦å™¨æœªåœ¨è¿è¡Œï¼Œæ— éœ€åœæ­¢");
            return Ok(());
        }

        info!(target: "buffered_kline_store", event_type = "SCHEDULER_STOPPING", "å¼€å§‹åœæ­¢åŒç¼“å†²è°ƒåº¦å™¨");
        self.scheduler_running.store(false, Ordering::Relaxed);
        self.stop_signal.notify_waiters();

        // ç­‰å¾…è°ƒåº¦å™¨å®Œå…¨åœæ­¢
        let start_wait = Instant::now();
        while self.is_scheduler_running() {
            if start_wait.elapsed() > Duration::from_secs(5) {
                warn!(target: "buffered_kline_store", event_type = "SCHEDULER_STOP_TIMEOUT", "ç­‰å¾…è°ƒåº¦å™¨åœæ­¢è¶…æ—¶(5s)");
                break;
            }
            tokio::time::sleep(Duration::from_millis(10)).await;
        }

        info!(target: "buffered_kline_store", event_type = "SCHEDULER_STOPPED_CONFIRMED", "åŒç¼“å†²è°ƒåº¦å™¨å·²ç¡®è®¤åœæ­¢");
        Ok(())
    }
    
    /// å†™å…¥Kçº¿æ•°æ®
    #[instrument(target = "BufferedKlineStore", name="write_kline", fields(symbol_index, period_index, flat_index), skip(self, kline_data), err)]
    pub async fn write_kline_data(
        &self,
        symbol_index: u32,
        period_index: u32,
        kline_data: &KlineData,
    ) -> Result<()> {
        // è®¡ç®—æ‰å¹³åŒ–ç´¢å¼•
        let flat_index = self.symbol_registry.calculate_flat_index(symbol_index, period_index);
        tracing::Span::current().record("flat_index", flat_index);

        if flat_index >= self.total_slots {
            return Err(AppError::DataError(format!(
                "ç´¢å¼•è¶…å‡ºèŒƒå›´: {} >= {}",
                flat_index,
                self.total_slots
            )));
        }
        
        // è·å–å†™ç¼“å†²åŒºçš„è¯»é”ï¼ˆå…è®¸å¹¶å‘å†™å…¥ï¼‰
        let write_buffer = self.write_buffer.read().await;
        
        // åŸå­åœ°æ›´æ–°æ•°æ®
        write_buffer[flat_index].load_from(kline_data);
        
        Ok(())
    }
    
    /// è¯»å–Kçº¿æ•°æ®
    #[instrument(target = "BufferedKlineStore", name="read_kline", fields(symbol_index, period_index, flat_index), skip(self), err)]
    pub async fn read_kline_data(
        &self,
        symbol_index: u32,
        period_index: u32,
    ) -> Result<KlineData> {
        // è®¡ç®—æ‰å¹³åŒ–ç´¢å¼•
        let flat_index = self.symbol_registry.calculate_flat_index(symbol_index, period_index);
        tracing::Span::current().record("flat_index", flat_index);
        
        if flat_index >= self.total_slots {
            return Err(AppError::DataError(format!(
                "ç´¢å¼•è¶…å‡ºèŒƒå›´: {} >= {}",
                flat_index,
                self.total_slots
            )));
        }
        
        // è·å–è¯»ç¼“å†²åŒºçš„è¯»é”
        let read_buffer = self.read_buffer.read().await;
        
        // åŸå­åœ°è¯»å–æ•°æ®
        let kline_data = read_buffer[flat_index].to_kline_data();
        
        Ok(kline_data)
    }
    
    /// æ‰¹é‡è¯»å–æ‰€æœ‰Kçº¿æ•°æ®å¿«ç…§
    #[instrument(target = "BufferedKlineStore", name="get_snapshot", skip(self), err)]
    pub async fn get_read_buffer_snapshot(&self) -> Result<Vec<KlineData>> {
        let read_buffer = self.read_buffer.read().await;
        let mut snapshot = Vec::with_capacity(self.total_slots);
        
        for atomic_kline in read_buffer.iter() {
            snapshot.push(atomic_kline.to_kline_data());
        }
        
        Ok(snapshot)
    }
    
    /// æ‰¹é‡è¯»å–æŒ‡å®šå“ç§çš„æ‰€æœ‰å‘¨æœŸKçº¿æ•°æ®
    #[instrument(target = "BufferedKlineStore", name="get_symbol_klines", fields(symbol_index), skip(self), err)]
    pub async fn get_symbol_klines(&self, symbol_index: u32) -> Result<Vec<KlineData>> {
        let periods_per_symbol = self.symbol_registry.get_periods_per_symbol();
        let mut klines = Vec::with_capacity(periods_per_symbol);
        
        for period_index in 0..periods_per_symbol as u32 {
            let kline_data = self.read_kline_data(symbol_index, period_index).await?;
            klines.push(kline_data);
        }
        
        Ok(klines)
    }
    
    /// æ‰¹é‡è¯»å–æŒ‡å®šå‘¨æœŸçš„æ‰€æœ‰å“ç§Kçº¿æ•°æ®
    #[instrument(target = "BufferedKlineStore", name="get_period_klines", fields(period_index), skip(self), err)]
    pub async fn get_period_klines(&self, period_index: u32) -> Result<Vec<KlineData>> {
        let symbol_count = self.symbol_registry.get_symbol_count().await;
        let mut klines = Vec::with_capacity(symbol_count);
        
        for symbol_index in 0..symbol_count as u32 {
            let kline_data = self.read_kline_data(symbol_index, period_index).await?;
            klines.push(kline_data);
        }
        
        Ok(klines)
    }
    
    /// ç­‰å¾…æ–°å¿«ç…§å°±ç»ª
    pub async fn wait_for_snapshot(&self) {
        self.snapshot_ready_notify.notified().await;
    }
    
    /// è·å–åˆ‡æ¢è®¡æ•°
    pub async fn get_swap_count(&self) -> u64 {
        self.swap_count.load(Ordering::Relaxed)
    }
    
    /// è·å–è°ƒåº¦å™¨è¿è¡ŒçŠ¶æ€
    pub fn is_scheduler_running(&self) -> bool {
        self.scheduler_running.load(Ordering::Relaxed)
    }
    
    /// è·å–å­˜å‚¨ç»Ÿè®¡ä¿¡æ¯
    pub async fn get_statistics(&self) -> BufferStatistics {
        let swap_count = self.swap_count.load(Ordering::Relaxed);
        let is_running = self.scheduler_running.load(Ordering::Relaxed);
        
        BufferStatistics {
            total_slots: self.total_slots,
            swap_count,
            is_scheduler_running: is_running,
            swap_interval_ms: self.swap_interval_ms,
        }
    }
}

/// ç¼“å†²åŒºç»Ÿè®¡ä¿¡æ¯
#[derive(Debug, Clone)]
pub struct BufferStatistics {
    /// æ€»å­˜å‚¨æ§½æ•°é‡
    pub total_slots: usize,
    /// åˆ‡æ¢è®¡æ•°
    pub swap_count: u64,
    /// è°ƒåº¦å™¨æ˜¯å¦è¿è¡Œ
    pub is_scheduler_running: bool,
    /// åˆ‡æ¢é—´éš”ï¼ˆæ¯«ç§’ï¼‰
    pub swap_interval_ms: u64,
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Rust
IGNORE_WHEN_COPYING_END
kline_data_persistence.txt

æ”¹é€ è¯´æ˜:

å…³é”®å‡½æ•°: ä¸ºnew, start, stop, execute_persistence_task, persist_kline_batchç­‰å…³é”®å‡½æ•°æ·»åŠ äº†#[instrument]ï¼Œå¹¶è®°å½•äº†batch_sizeç­‰é‡è¦å‚æ•°ã€‚

å¹¶å‘è¿½è¸ª: ä¸ºstart_persistence_taskå’Œstart_statistics_taskä¸­çš„tokio::spawnæ·»åŠ äº†instrumentï¼Œå¹¶ä¸ºæ¯ä¸ªå¼‚æ­¥æŒä¹…åŒ–ä»»åŠ¡ä¹Ÿæ·»åŠ äº†instrumentï¼Œå½¢æˆäº†æ¸…æ™°çš„å¹¶å‘è°ƒç”¨é“¾ã€‚

å…³é”®äº‹ä»¶: å°†æ‰¹é‡æŒä¹…åŒ–å®Œæˆçš„event!è§„èŒƒåŒ–ï¼Œä½¿ç”¨event_type = "BATCH_PERSISTENCE_COMPLETED"ã€‚ä¸ºå¯åŠ¨ã€åœæ­¢ã€ä»»åŠ¡ç¹å¿™è·³è¿‡ç­‰äº‹ä»¶æ·»åŠ äº†event_typeã€‚

é”™è¯¯è¯¦æƒ…: åœ¨æŒä¹…åŒ–å¤±è´¥å’Œç­‰å¾…ä»»åŠ¡å®Œæˆå¤±è´¥çš„è·¯å¾„è®°å½•äº†è¯¦ç»†é”™è¯¯ã€‚

å…³é”®çŠ¶æ€: åœ¨æ—¥å¿—ä¸­è®°å½•äº†is_runningçŠ¶æ€ï¼Œä»¥åŠå„ç§ç»Ÿè®¡è®¡æ•°ã€‚

//! Kçº¿æ•°æ®æŒä¹…åŒ–æ¨¡å—
//! 
//! è´Ÿè´£å°†å†…å­˜ä¸­çš„Kçº¿æ•°æ®å®šæœŸæŒä¹…åŒ–åˆ°æ•°æ®åº“ã€‚

use crate::klaggregate::{AggregateConfig, BufferedKlineStore, SymbolMetadataRegistry, KlineData};
use crate::klcommon::{Result, AppError, Database};
use std::sync::Arc;
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use tokio::time::{interval, Duration, Instant};
use tokio::sync::Semaphore;
use tracing::{info, debug, warn, error, instrument, event, Level};

/// Kçº¿æ•°æ®æŒä¹…åŒ–å™¨
pub struct KlineDataPersistence {
    /// é…ç½®
    config: AggregateConfig,
    
    /// åŒç¼“å†²å­˜å‚¨å¼•ç”¨
    buffered_store: Arc<BufferedKlineStore>,
    
    /// ç¬¦å·å…ƒæ•°æ®æ³¨å†Œè¡¨
    symbol_registry: Arc<SymbolMetadataRegistry>,
    
    /// æ•°æ®åº“è¿æ¥
    database: Arc<Database>,
    
    /// è¿è¡ŒçŠ¶æ€
    is_running: Arc<AtomicBool>,

    /// æŒä¹…åŒ–è®¡æ•°
    persistence_count: Arc<AtomicU64>,

    /// æˆåŠŸè®¡æ•°
    success_count: Arc<AtomicU64>,

    /// é”™è¯¯è®¡æ•°
    error_count: Arc<AtomicU64>,
    
    /// å¹¶å‘æ§åˆ¶ä¿¡å·é‡
    semaphore: Arc<Semaphore>,
}

impl KlineDataPersistence {
    /// åˆ›å»ºæ–°çš„Kçº¿æ•°æ®æŒä¹…åŒ–å™¨
    #[instrument(target = "KlineDataPersistence", name="new_persistence", fields(batch_size = config.persistence.batch_size), skip_all, err)]
    pub async fn new(
        config: AggregateConfig,
        buffered_store: Arc<BufferedKlineStore>,
        symbol_registry: Arc<SymbolMetadataRegistry>,
    ) -> Result<Self> {
        info!(target: "kline_data_persistence", event_type = "PERSISTENCE_INITIALIZING", "åˆ›å»ºKçº¿æ•°æ®æŒä¹…åŒ–å™¨: batch_size={}", config.persistence.batch_size);
        
        // åˆ›å»ºæ•°æ®åº“è¿æ¥
        let database = Arc::new(Database::new(&config.database.database_path)?);
        
        // åˆ›å»ºå¹¶å‘æ§åˆ¶ä¿¡å·é‡ï¼ˆé™åˆ¶åŒæ—¶è¿›è¡Œçš„æŒä¹…åŒ–ä»»åŠ¡æ•°é‡ï¼‰
        let semaphore = Arc::new(Semaphore::new(config.persistence.batch_size.min(10)));
        
        Ok(Self {
            config,
            buffered_store,
            symbol_registry,
            database,
            is_running: Arc::new(AtomicBool::new(false)),
            persistence_count: Arc::new(AtomicU64::new(0)),
            success_count: Arc::new(AtomicU64::new(0)),
            error_count: Arc::new(AtomicU64::new(0)),
            semaphore,
        })
    }
    
    /// å¯åŠ¨æŒä¹…åŒ–æœåŠ¡
    #[instrument(target = "KlineDataPersistence", name="start_persistence", fields(persistence_interval_ms = self.config.persistence_interval_ms), skip(self), err)]
    pub async fn start(&self) -> Result<()> {
        if self.is_running.swap(true, Ordering::Relaxed) {
            warn!(target: "kline_data_persistence", event_type = "PERSISTENCE_ALREADY_RUNNING", "Kçº¿æ•°æ®æŒä¹…åŒ–å™¨å·²ç»åœ¨è¿è¡Œ");
            return Ok(());
        }

        info!(target: "kline_data_persistence", event_type = "PERSISTENCE_STARTING", "å¯åŠ¨Kçº¿æ•°æ®æŒä¹…åŒ–å™¨: persistence_interval_ms={}", self.config.persistence_interval_ms);
        
        // å¯åŠ¨å®šæ—¶æŒä¹…åŒ–ä»»åŠ¡
        self.start_persistence_task().await;
        
        // å¯åŠ¨ç»Ÿè®¡è¾“å‡ºä»»åŠ¡
        self.start_statistics_task().await;

        info!(target: "kline_data_persistence", event_type = "PERSISTENCE_STARTED", "Kçº¿æ•°æ®æŒä¹…åŒ–å™¨å¯åŠ¨å®Œæˆ");
        Ok(())
    }
    
    /// åœæ­¢æŒä¹…åŒ–æœåŠ¡
    #[instrument(target = "KlineDataPersistence", name="stop_persistence", skip(self), err)]
    pub async fn stop(&self) -> Result<()> {
        if !self.is_running.swap(false, Ordering::Relaxed) {
            info!(target: "kline_data_persistence", event_type = "PERSISTENCE_ALREADY_STOPPED", "æŒä¹…åŒ–å™¨æœªåœ¨è¿è¡Œï¼Œæ— éœ€åœæ­¢");
            return Ok(());
        }
        
        info!(target: "kline_data_persistence", event_type = "PERSISTENCE_STOPPING", "åœæ­¢Kçº¿æ•°æ®æŒä¹…åŒ–å™¨");

        // ç­‰å¾…æ‰€æœ‰æŒä¹…åŒ–ä»»åŠ¡å®Œæˆ
        let batch_size = self.config.persistence.batch_size as u32;
        let _permits = self.semaphore.acquire_many(batch_size).await
            .map_err(|e| {
                let app_err = AppError::DataError(format!("ç­‰å¾…æŒä¹…åŒ–ä»»åŠ¡å®Œæˆå¤±è´¥: {}", e));
                error!(target = "kline_data_persistence", event_type="PERSISTENCE_STOP_WAIT_FAILED", error = %app_err, "ç­‰å¾…ä¿¡å·é‡è®¸å¯å¤±è´¥");
                app_err
            })?;

        info!(target: "kline_data_persistence", event_type = "PERSISTENCE_STOPPED", "Kçº¿æ•°æ®æŒä¹…åŒ–å™¨å·²åœæ­¢");
        Ok(())
    }
    
    /// å¯åŠ¨å®šæ—¶æŒä¹…åŒ–ä»»åŠ¡
    async fn start_persistence_task(&self) {
        let is_running = self.is_running.clone();
        let buffered_store = self.buffered_store.clone();
        let symbol_registry = self.symbol_registry.clone();
        let database = self.database.clone();
        let persistence_count = self.persistence_count.clone();
        let success_count = self.success_count.clone();
        let error_count = self.error_count.clone();
        let semaphore = self.semaphore.clone();
        let batch_size = self.config.persistence.batch_size;
        let persistence_interval_ms = self.config.persistence_interval_ms;
        
        tokio::spawn(async move {
            let mut interval_timer = interval(Duration::from_millis(persistence_interval_ms));
            
            while is_running.load(Ordering::Relaxed) {
                interval_timer.tick().await;
                
                // è·å–ä¿¡å·é‡è®¸å¯
                let permit = match semaphore.clone().try_acquire_owned() {
                    Ok(permit) => permit,
                    Err(_) => {
                        debug!(target: "kline_data_persistence", event_type = "PERSISTENCE_TASK_SKIPPED_BUSY", "æŒä¹…åŒ–ä»»åŠ¡ç¹å¿™ï¼Œè·³è¿‡æœ¬æ¬¡æ‰§è¡Œ");
                        continue;
                    }
                };
                
                let buffered_store = buffered_store.clone();
                let symbol_registry = symbol_registry.clone();
                let database = database.clone();
                let persistence_count = persistence_count.clone();
                let success_count = success_count.clone();
                let error_count = error_count.clone();
                
                // å¼‚æ­¥æ‰§è¡ŒæŒä¹…åŒ–ä»»åŠ¡
                tokio::spawn(async move {
                    let _permit = permit; // ç¡®ä¿permitåœ¨ä»»åŠ¡ç»“æŸæ—¶é‡Šæ”¾
                    
                    let start_time = Instant::now();
                    let count = persistence_count.fetch_add(1, Ordering::Relaxed) + 1;
                    
                    match Self::execute_persistence_task(
                        &buffered_store,
                        &symbol_registry,
                        &database,
                        batch_size,
                    ).await {
                        Ok(persisted_count) => {
                            success_count.fetch_add(1, Ordering::Relaxed);
                            let duration = start_time.elapsed();
                            
                            if persisted_count > 0 {
                                debug!(target: "kline_data_persistence", "æŒä¹…åŒ–å®Œæˆ: persisted_count={}, duration_ms={:.2}", persisted_count, duration.as_secs_f64() * 1000.0);
                            }
                        }
                        Err(e) => {
                            error_count.fetch_add(1, Ordering::Relaxed);
                            error!(target: "kline_data_persistence", event_type = "PERSISTENCE_EXECUTION_FAILED", error = %e, "æŒä¹…åŒ–ä»»åŠ¡æ‰§è¡Œå¤±è´¥");
                        }
                    }
                }.instrument(tracing::info_span!("single_persistence_job", job_id = count)));
            }
        }.instrument(tracing::info_span!("persistence_scheduler_task")));
    }
    
    /// æ‰§è¡ŒæŒä¹…åŒ–ä»»åŠ¡
    #[instrument(
        target = "KlineDataPersistence",
        name = "execute_persistence_task",
        fields(batch_size, persisted_count = 0),
        skip_all,
        err
    )]
    async fn execute_persistence_task(
        buffered_store: &Arc<BufferedKlineStore>,
        symbol_registry: &Arc<SymbolMetadataRegistry>,
        database: &Arc<Database>,
        batch_size: usize,
    ) -> Result<usize> {
        // è·å–Kçº¿æ•°æ®å¿«ç…§
        let kline_snapshot = buffered_store.get_read_buffer_snapshot().await?;
        
        let mut persisted_count = 0;
        let mut batch = Vec::new();
        
        for kline_data in kline_snapshot {
            // è·³è¿‡ç©ºçš„Kçº¿æ•°æ®
            if kline_data.is_empty() {
                continue;
            }
            
            batch.push(kline_data);
            
            // å½“æ‰¹æ¬¡è¾¾åˆ°æŒ‡å®šå¤§å°æ—¶ï¼Œæ‰§è¡ŒæŒä¹…åŒ–
            if batch.len() >= batch_size {
                persisted_count += Self::persist_kline_batch(
                    &batch,
                    symbol_registry,
                    database,
                ).await?;
                batch.clear();
            }
        }
        
        // æŒä¹…åŒ–å‰©ä½™çš„Kçº¿æ•°æ®
        if !batch.is_empty() {
            persisted_count += Self::persist_kline_batch(
                &batch,
                symbol_registry,
                database,
            ).await?;
        }
        
        tracing::Span::current().record("persisted_count", persisted_count);
        Ok(persisted_count)
    }
    
    /// æŒä¹…åŒ–Kçº¿æ‰¹æ¬¡
    #[instrument(
        target = "KlineDataPersistence",
        name = "persist_kline_batch",
        fields(
            batch_size = batch.len(),
            persisted_count = 0
        ),
        skip_all,
        err
    )]
    async fn persist_kline_batch(
        batch: &[KlineData],
        symbol_registry: &Arc<SymbolMetadataRegistry>,
        database: &Arc<Database>,
    ) -> Result<usize> {
        let mut persisted_count = 0;
        
        for kline_data in batch {
            // è·å–å“ç§åç§°å’Œå‘¨æœŸå­—ç¬¦ä¸²
            let symbol = match symbol_registry.get_symbol_by_index(kline_data.symbol_index).await {
                Some(symbol) => symbol,
                None => {
                    warn!(target: "kline_data_persistence", event_type = "SYMBOL_INDEX_NOT_FOUND", symbol_index = kline_data.symbol_index, "æŒä¹…åŒ–æ—¶æœªæ‰¾åˆ°ç´¢å¼•å¯¹åº”çš„å“ç§");
                    continue;
                }
            };

            let interval = match symbol_registry.get_interval_by_index(kline_data.period_index).await {
                Some(interval) => interval,
                None => {
                    warn!(target: "kline_data_persistence", event_type = "PERIOD_INDEX_NOT_FOUND", period_index = kline_data.period_index, "æŒä¹…åŒ–æ—¶æœªæ‰¾åˆ°ç´¢å¼•å¯¹åº”çš„å‘¨æœŸ");
                    continue;
                }
            };
            
            // è½¬æ¢ä¸ºæ•°æ®åº“æ ¼å¼
            let kline = kline_data.to_kline(&symbol, &interval);
            
            // æ‰§è¡ŒUPSERTæ“ä½œ
            match Self::upsert_kline(database, &symbol, &interval, &kline).await {
                Ok(()) => {
                    persisted_count += 1;
                }
                Err(e) => {
                    error!(target: "kline_data_persistence", event_type = "KLINE_UPSERT_FAILED", symbol = %symbol, interval = %interval, error = %e, "æŒä¹…åŒ–Kçº¿å¤±è´¥");
                }
            }
        }

        // è®°å½•æ‰¹é‡æŒä¹…åŒ–å®Œæˆäº‹ä»¶
        let total_records = batch.len() as u64;
        let failed_count = batch.len() - persisted_count;

        event!(
            Level::INFO,
            target = "kline_data_persistence",
            event_type = "BATCH_PERSISTENCE_COMPLETED",
            total_records = total_records,
            success_count = persisted_count,
            failed_count = failed_count,
            "æ‰¹é‡æŒä¹…åŒ–å®Œæˆ"
        );

        tracing::Span::current().record("persisted_count", persisted_count);

        Ok(persisted_count)
    }
    
    /// æ‰§è¡ŒKçº¿UPSERTæ“ä½œ
    #[instrument(target = "KlineDataPersistence", name="upsert_kline_db", fields(symbol=%symbol, interval=%interval), skip_all, err)]
    async fn upsert_kline(
        database: &Arc<Database>,
        symbol: &str,
        interval: &str,
        kline: &crate::klcommon::Kline,
    ) -> Result<()> {
        let database = database.clone();
        let symbol_owned = symbol.to_string();
        let interval_owned = interval.to_string();
        let kline_owned = kline.clone();
        
        // åœ¨é˜»å¡ä»»åŠ¡ä¸­æ‰§è¡Œæ•°æ®åº“æ“ä½œ
        tokio::task::spawn_blocking(move || {
            database.save_kline(&symbol_owned, &interval_owned, &kline_owned)
        })
        .await
        .map_err(|e| AppError::DataError(format!("æ•°æ®åº“ä»»åŠ¡æ‰§è¡Œå¤±è´¥: {}", e)))??;
        
        Ok(())
    }
    
    /// å¯åŠ¨ç»Ÿè®¡è¾“å‡ºä»»åŠ¡
    async fn start_statistics_task(&self) {
        let is_running = self.is_running.clone();
        let persistence_count = self.persistence_count.clone();
        let success_count = self.success_count.clone();
        let error_count = self.error_count.clone();
        
        tokio::spawn(async move {
            let mut interval_timer = interval(Duration::from_secs(60)); // æ¯åˆ†é’Ÿè¾“å‡ºä¸€æ¬¡ç»Ÿè®¡
            let mut last_persistence_count = 0;
            let mut last_success_count = 0;
            let mut last_error_count = 0;
            
            while is_running.load(Ordering::Relaxed) {
                interval_timer.tick().await;
                
                let current_persistence = persistence_count.load(Ordering::Relaxed);
                let current_success = success_count.load(Ordering::Relaxed);
                let current_error = error_count.load(Ordering::Relaxed);
                
                let persistence_rate = current_persistence - last_persistence_count;
                let success_rate = current_success - last_success_count;
                let error_rate = current_error - last_error_count;
                
                if persistence_rate > 0 || error_rate > 0 {
                    info!(
                        target: "kline_data_persistence",
                        event_type = "PERSISTENCE_STATS_REPORT",
                        total_persistence = current_persistence,
                        persistence_rate_per_min = persistence_rate,
                        total_success = current_success,
                        success_rate_per_min = success_rate,
                        total_errors = current_error,
                        error_rate_per_min = error_rate,
                        "æŒä¹…åŒ–ç»Ÿè®¡æŠ¥å‘Š"
                    );
                }
                
                last_persistence_count = current_persistence;
                last_success_count = current_success;
                last_error_count = current_error;
            }
        }.instrument(tracing::info_span!("persistence_statistics_task")));
    }
    
    /// è·å–çŠ¶æ€å­—ç¬¦ä¸²
    pub async fn get_status(&self) -> String {
        if self.is_running.load(Ordering::Relaxed) {
            format!(
                "è¿è¡Œä¸­ (æ‰§è¡Œ: {}, æˆåŠŸ: {}, é”™è¯¯: {})",
                self.persistence_count.load(Ordering::Relaxed),
                self.success_count.load(Ordering::Relaxed),
                self.error_count.load(Ordering::Relaxed)
            )
        } else {
            "å·²åœæ­¢".to_string()
        }
    }
    
    /// è·å–ç»Ÿè®¡ä¿¡æ¯
    pub async fn get_statistics(&self) -> PersistenceStatistics {
        PersistenceStatistics {
            is_running: self.is_running.load(Ordering::Relaxed),
            persistence_count: self.persistence_count.load(Ordering::Relaxed),
            success_count: self.success_count.load(Ordering::Relaxed),
            error_count: self.error_count.load(Ordering::Relaxed),
            available_permits: self.semaphore.available_permits(),
        }
    }
}

/// æŒä¹…åŒ–ç»Ÿè®¡ä¿¡æ¯
#[derive(Debug, Clone)]
pub struct PersistenceStatistics {
    /// æ˜¯å¦è¿è¡Œä¸­
    pub is_running: bool,
    /// æŒä¹…åŒ–æ‰§è¡Œæ¬¡æ•°
    pub persistence_count: u64,
    /// æˆåŠŸæ¬¡æ•°
    pub success_count: u64,
    /// é”™è¯¯æ¬¡æ•°
    pub error_count: u64,
    /// å¯ç”¨çš„å¹¶å‘è®¸å¯æ•°
    pub available_permits: usize,
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Rust
IGNORE_WHEN_COPYING_END
symbol_kline_aggregator.txt

æ”¹é€ è¯´æ˜:

å…³é”®å‡½æ•°: å¯¹æ ¸å¿ƒä¸šåŠ¡é€»è¾‘process_agg_trade, process_trade_for_period, aggregate_trade_to_klineç­‰æ·»åŠ /ä¼˜åŒ–äº†#[instrument]ã€‚

å…³é”®äº‹ä»¶: å¯¹kline_finalizedå’Œkline_generatedäº‹ä»¶çš„event!å®è°ƒç”¨è¿›è¡Œäº†è§„èŒƒåŒ–ï¼Œæ·»åŠ äº†event_typeå­—æ®µã€‚å¢åŠ äº†æ–°çš„debug!äº‹ä»¶æ¥è¿½è¸ªKçº¿å®Œæˆçš„è¯¦ç»†ä¿¡æ¯ã€‚

å…³é”®çŠ¶æ€: åœ¨æ—¥å¿—ä¸­è®°å½•äº†is_finalçŠ¶æ€ã€å¼€ç›˜ä»·ã€æœ€é«˜ä»·ç­‰Kçº¿å…³é”®æ•°æ®ã€‚

é”™è¯¯è¯¦æƒ…: åœ¨process_agg_tradeä¸­å¯¹å“ç§ä¸åŒ¹é…é”™è¯¯è¿›è¡Œäº†è®°å½•ã€‚

//! å•å“ç§Kçº¿èšåˆæ¨¡å—
//! 
//! è´Ÿè´£å•ä¸ªäº¤æ˜“å“ç§çš„å®æ—¶Kçº¿èšåˆï¼Œæ”¯æŒå¤šä¸ªæ—¶é—´å‘¨æœŸçš„åŒæ—¶èšåˆã€‚

use crate::klaggregate::{AggTradeData, KlineData, BufferedKlineStore, PeriodInfo};
use crate::klcommon::{Result, AppError, api::get_aligned_time, ServerTimeSyncManager};
use std::sync::Arc;
use std::collections::HashMap;
use tokio::sync::RwLock;
use tracing::{instrument, event, Level, debug, warn};

/// å•å“ç§Kçº¿èšåˆå™¨
pub struct SymbolKlineAggregator {
    /// å“ç§åç§°
    symbol: String,
    
    /// å“ç§ç´¢å¼•
    symbol_index: u32,
    
    /// æ”¯æŒçš„æ—¶é—´å‘¨æœŸä¿¡æ¯
    period_infos: Vec<PeriodInfo>,
    
    /// å½“å‰èšåˆçŠ¶æ€ï¼ˆå‘¨æœŸç´¢å¼• -> Kçº¿èšåˆçŠ¶æ€ï¼‰
    aggregation_states: Arc<RwLock<HashMap<u32, KlineAggregationState>>>,
    
    /// åŒç¼“å†²å­˜å‚¨å¼•ç”¨
    buffered_store: Arc<BufferedKlineStore>,

    /// æœåŠ¡å™¨æ—¶é—´åŒæ­¥ç®¡ç†å™¨
    time_sync_manager: Arc<ServerTimeSyncManager>,
}

/// Kçº¿èšåˆçŠ¶æ€
#[derive(Debug, Clone)]
struct KlineAggregationState {
    /// å½“å‰Kçº¿æ•°æ®
    current_kline: KlineData,
    /// å‘¨æœŸä¿¡æ¯
    period_info: PeriodInfo,
    /// æ˜¯å¦å·²åˆå§‹åŒ–ï¼ˆæ”¶åˆ°ç¬¬ä¸€ç¬”äº¤æ˜“ï¼‰
    initialized: bool,
}

impl KlineAggregationState {
    /// åˆ›å»ºæ–°çš„èšåˆçŠ¶æ€
    fn new(symbol_index: u32, period_info: PeriodInfo) -> Self {
        Self {
            current_kline: KlineData::new(symbol_index, period_info.index, 0),
            period_info,
            initialized: false,
        }
    }
    
    /// é‡ç½®åˆ°æ–°çš„æ—¶é—´å‘¨æœŸ
    fn reset_to_new_period(&mut self, new_open_time: i64) {
        self.current_kline.reset(new_open_time);
        self.initialized = false;
    }
    
    /// æ£€æŸ¥äº¤æ˜“æ—¶é—´æ˜¯å¦å±äºå½“å‰Kçº¿å‘¨æœŸ
    fn is_trade_in_current_period(&self, trade_time: i64) -> bool {
        if !self.initialized {
            return true; // å¦‚æœè¿˜æ²¡åˆå§‹åŒ–ï¼Œä»»ä½•äº¤æ˜“éƒ½å¯ä»¥å¼€å§‹æ–°å‘¨æœŸ
        }
        
        let period_end_time = self.current_kline.open_time + self.period_info.duration_ms;
        trade_time >= self.current_kline.open_time && trade_time < period_end_time
    }
    
    /// æ£€æŸ¥å½“å‰Kçº¿æ˜¯å¦åº”è¯¥ç»“æŸ
    fn should_finalize(&self, current_time: i64) -> bool {
        if !self.initialized {
            return false;
        }
        
        let period_end_time = self.current_kline.open_time + self.period_info.duration_ms;
        current_time >= period_end_time
    }
    
    /// è®¡ç®—ä¸‹ä¸€ä¸ªå‘¨æœŸçš„å¼€å§‹æ—¶é—´
    fn get_next_period_start(&self, trade_time: i64) -> i64 {
        get_aligned_time(trade_time, &self.period_info.interval)
    }
}

impl SymbolKlineAggregator {
    /// åˆ›å»ºæ–°çš„å“ç§Kçº¿èšåˆå™¨
    #[instrument(target = "SymbolKlineAggregator", name="new_aggregator", fields(symbol=%symbol, symbol_index), skip_all, err)]
    pub async fn new(
        symbol: String,
        symbol_index: u32,
        supported_intervals: Vec<String>,
        buffered_store: Arc<BufferedKlineStore>,
        time_sync_manager: Arc<ServerTimeSyncManager>,
    ) -> Result<Self> {
        debug!(target: "symbol_kline_aggregator", event_type = "AGGREGATOR_INITIALIZING", "åˆ›å»ºå“ç§Kçº¿èšåˆå™¨: symbol={}, symbol_index={}", symbol, symbol_index);
        
        // åˆ›å»ºå‘¨æœŸä¿¡æ¯
        let mut period_infos = Vec::new();
        for (index, interval) in supported_intervals.iter().enumerate() {
            period_infos.push(PeriodInfo::new(interval.clone(), index as u32));
        }

        // åˆå§‹åŒ–èšåˆçŠ¶æ€
        let mut aggregation_states = HashMap::new();
        for period_info in &period_infos {
            let state = KlineAggregationState::new(symbol_index, period_info.clone());
            aggregation_states.insert(period_info.index, state);
        }

        let period_count = period_infos.len();
        let aggregator = Self {
            symbol: symbol.clone(),
            symbol_index,
            period_infos,
            aggregation_states: Arc::new(RwLock::new(aggregation_states)),
            buffered_store,
            time_sync_manager,
        };

        debug!(target: "symbol_kline_aggregator", event_type = "AGGREGATOR_INITIALIZED", "å“ç§Kçº¿èšåˆå™¨åˆ›å»ºå®Œæˆ: symbol={}, symbol_index={}, period_count={}", symbol, symbol_index, period_count);
        Ok(aggregator)
    }
    
    /// å¤„ç†å½’é›†äº¤æ˜“æ•°æ®
    #[instrument(
        target = "SymbolKlineAggregator",
        name = "process_agg_trade",
        fields(
            symbol = %trade.symbol,
            price = %trade.price,
            quantity = %trade.quantity,
            timestamp_ms = %trade.timestamp_ms,
            is_buyer_maker = %trade.is_buyer_maker
        ),
        skip(self),
        err
    )]
    pub async fn process_agg_trade(&self, trade: &AggTradeData) -> Result<()> {
        if trade.symbol != self.symbol {
            let err = AppError::DataError(format!(
                "äº¤æ˜“å“ç§ä¸åŒ¹é…: æœŸæœ› {}, å®é™… {}",
                self.symbol,
                trade.symbol
            ));
            warn!(target: "symbol_kline_aggregator", event_type = "SYMBOL_MISMATCH", expected_symbol = %self.symbol, actual_symbol = %trade.symbol, error = %err);
            return Err(err);
        }

        // ä½¿ç”¨æ ¡å‡†åçš„æœåŠ¡å™¨æ—¶é—´è¿›è¡ŒKçº¿ç»“æŸåˆ¤æ–­
        let current_time = if self.time_sync_manager.is_time_sync_valid() {
            // ä½¿ç”¨æ ¡å‡†åçš„æœåŠ¡å™¨æ—¶é—´
            self.time_sync_manager.get_calibrated_server_time()
        } else {
            // å¦‚æœæ—¶é—´åŒæ­¥å¤±æ•ˆï¼Œä½¿ç”¨äº¤æ˜“æ—¶é—´ä½œä¸ºå¤‡é€‰
            warn!(target: "symbol_kline_aggregator", event_type = "TIME_SYNC_INVALID", fallback_time = trade.timestamp_ms, symbol = %trade.symbol, "æœåŠ¡å™¨æ—¶é—´åŒæ­¥å¤±æ•ˆï¼Œä½¿ç”¨äº¤æ˜“æ—¶é—´");
            trade.timestamp_ms
        };

        let mut states = self.aggregation_states.write().await;
        
        // å¤„ç†æ¯ä¸ªæ—¶é—´å‘¨æœŸ
        for period_info in &self.period_infos {
            if let Some(state) = states.get_mut(&period_info.index) {
                self.process_trade_for_period(state, trade, current_time).await?;
            }
        }
        
        Ok(())
    }
    
    /// ä¸ºç‰¹å®šå‘¨æœŸå¤„ç†äº¤æ˜“
    #[instrument(target = "SymbolKlineAggregator", name="process_trade_for_period", fields(interval=%state.period_info.interval), skip(self, state, trade, current_time), err)]
    async fn process_trade_for_period(
        &self,
        state: &mut KlineAggregationState,
        trade: &AggTradeData,
        current_time: i64,
    ) -> Result<()> {
        // æ£€æŸ¥æ˜¯å¦éœ€è¦ç»“æŸå½“å‰Kçº¿
        if state.should_finalize(current_time) && state.initialized {
            // æ ‡è®°å½“å‰Kçº¿ä¸ºæœ€ç»ˆçŠ¶æ€
            state.current_kline.is_final = true;

            // è®°å½•Kçº¿å®Œæˆäº‹ä»¶
            event!(
                Level::INFO,
                target = "SymbolKlineAggregator",
                event_type = "KLINE_FINALIZED",
                is_high_freq = true, // æ ‡è®°ä¸ºé«˜é¢‘äº‹ä»¶
                symbol = %self.symbol,
                interval = %state.period_info.interval,
                open_time = state.current_kline.open_time,
                is_final = state.current_kline.is_final,
                finalize_trigger_time = current_time,
                open = state.current_kline.open,
                high = state.current_kline.high,
                low = state.current_kline.low,
                close = state.current_kline.close,
                volume = state.current_kline.volume,
                trade_count = state.current_kline.trade_count,
                "Kçº¿å·²å®Œæˆ"
            );

            // å†™å…¥åˆ°ç¼“å†²å­˜å‚¨
            self.buffered_store.write_kline_data(
                self.symbol_index,
                state.period_info.index,
                &state.current_kline,
            ).await?;

            debug!(target: "symbol_kline_aggregator", "Kçº¿å®Œæˆè¯¦æƒ…: symbol={}, interval={}, open_time={}, open={}, high={}, low={}, close={}, volume={}", self.symbol, state.period_info.interval, state.current_kline.open_time, state.current_kline.open, state.current_kline.high, state.current_kline.low, state.current_kline.close, state.current_kline.volume);

            // é‡ç½®åˆ°ä¸‹ä¸€ä¸ªå‘¨æœŸ
            let next_period_start = state.get_next_period_start(trade.timestamp_ms);
            state.reset_to_new_period(next_period_start);
        }
        
        // æ£€æŸ¥äº¤æ˜“æ˜¯å¦å±äºå½“å‰å‘¨æœŸ
        if !state.is_trade_in_current_period(trade.timestamp_ms) {
            // äº¤æ˜“å±äºæ–°å‘¨æœŸï¼Œé‡ç½®çŠ¶æ€
            let new_period_start = state.get_next_period_start(trade.timestamp_ms);
            state.reset_to_new_period(new_period_start);
        }
        
        // èšåˆäº¤æ˜“æ•°æ®åˆ°å½“å‰Kçº¿
        self.aggregate_trade_to_kline(state, trade)?;
        
        // å†™å…¥å½“å‰çŠ¶æ€åˆ°ç¼“å†²å­˜å‚¨ï¼ˆæœªå®Œæˆçš„Kçº¿ï¼‰
        self.buffered_store.write_kline_data(
            self.symbol_index,
            state.period_info.index,
            &state.current_kline,
        ).await?;
        
        Ok(())
    }
    
    /// å°†äº¤æ˜“æ•°æ®èšåˆåˆ°Kçº¿
    fn aggregate_trade_to_kline(
        &self,
        state: &mut KlineAggregationState,
        trade: &AggTradeData,
    ) -> Result<()> {
        if !state.initialized {
            // ç¬¬ä¸€ç¬”äº¤æ˜“ï¼Œåˆå§‹åŒ–Kçº¿
            let open_time = state.get_next_period_start(trade.timestamp_ms);
            let kline = &mut state.current_kline;
            kline.open_time = open_time;
            kline.open = trade.price;
            kline.high = trade.price;
            kline.low = trade.price;
            kline.close = trade.price;
            kline.volume = trade.quantity;
            kline.turnover = trade.price * trade.quantity;
            kline.trade_count = 1;
            
            if trade.is_buyer_maker {
                kline.taker_buy_volume = 0.0;
                kline.taker_buy_turnover = 0.0;
            } else {
                kline.taker_buy_volume = trade.quantity;
                kline.taker_buy_turnover = trade.price * trade.quantity;
            }
            
            state.initialized = true;

            // è®°å½•Kçº¿ç”Ÿæˆäº‹ä»¶
            event!(
                Level::DEBUG,
                target = "SymbolKlineAggregator",
                event_type = "KLINE_GENERATED",
                symbol = %self.symbol,
                interval = %state.period_info.interval,
                open_time = kline.open_time,
                is_final = kline.is_final,
                initial_trade_id = trade.agg_trade_id,
                "æ–°Kçº¿å·²ç”Ÿæˆ"
            );
        } else {
            // æ›´æ–°ç°æœ‰Kçº¿
            let kline = &mut state.current_kline;
            kline.high = kline.high.max(trade.price);
            kline.low = kline.low.min(trade.price);
            kline.close = trade.price;
            kline.volume += trade.quantity;
            kline.turnover += trade.price * trade.quantity;
            kline.trade_count += 1;

            if !trade.is_buyer_maker {
                kline.taker_buy_volume += trade.quantity;
                kline.taker_buy_turnover += trade.price * trade.quantity;
            }
        }
        
        Ok(())
    }
    
    /// å¼ºåˆ¶å®Œæˆæ‰€æœ‰å½“å‰Kçº¿ï¼ˆç”¨äºç³»ç»Ÿå…³é—­æ—¶ï¼‰
    #[instrument(target = "SymbolKlineAggregator", name="finalize_all", skip(self), err)]
    pub async fn finalize_all_klines(&self) -> Result<()> {
        let mut states = self.aggregation_states.write().await;
        
        for (period_index, state) in states.iter_mut() {
            if state.initialized && !state.current_kline.is_final {
                state.current_kline.is_final = true;
                
                self.buffered_store.write_kline_data(
                    self.symbol_index,
                    *period_index,
                    &state.current_kline,
                ).await?;
                
                debug!(target: "symbol_kline_aggregator", event_type = "KLINE_FORCE_FINALIZED", symbol = %self.symbol, interval = %state.period_info.interval, open_time = state.current_kline.open_time, period_index = *period_index, "å¼ºåˆ¶å®ŒæˆKçº¿");
            }
        }
        
        Ok(())
    }
    
    /// è·å–å½“å‰æ‰€æœ‰Kçº¿çŠ¶æ€
    pub async fn get_current_klines(&self) -> Result<Vec<KlineData>> {
        let states = self.aggregation_states.read().await;
        let mut klines = Vec::new();
        
        for state in states.values() {
            if state.initialized {
                klines.push(state.current_kline.clone());
            }
        }
        
        Ok(klines)
    }
    
    /// è·å–å“ç§åç§°
    pub fn get_symbol(&self) -> &str {
        &self.symbol
    }
    
    /// è·å–å“ç§ç´¢å¼•
    pub fn get_symbol_index(&self) -> u32 {
        self.symbol_index
    }
    
    /// è·å–æ”¯æŒçš„å‘¨æœŸæ•°é‡
    pub fn get_period_count(&self) -> usize {
        self.period_infos.len()
    }
    
    /// è·å–èšåˆç»Ÿè®¡ä¿¡æ¯
    pub async fn get_statistics(&self) -> AggregatorStatistics {
        let states = self.aggregation_states.read().await;
        let mut initialized_periods = 0;
        let mut finalized_klines = 0;
        
        for state in states.values() {
            if state.initialized {
                initialized_periods += 1;
                if state.current_kline.is_final {
                    finalized_klines += 1;
                }
            }
        }
        
        AggregatorStatistics {
            symbol: self.symbol.clone(),
            symbol_index: self.symbol_index,
            total_periods: self.period_infos.len(),
            initialized_periods,
            finalized_klines,
        }
    }
}

/// èšåˆå™¨ç»Ÿè®¡ä¿¡æ¯
#[derive(Debug, Clone)]
pub struct AggregatorStatistics {
    /// å“ç§åç§°
    pub symbol: String,
    /// å“ç§ç´¢å¼•
    pub symbol_index: u32,
    /// æ€»å‘¨æœŸæ•°
    pub total_periods: usize,
    /// å·²åˆå§‹åŒ–çš„å‘¨æœŸæ•°
    pub initialized_periods: usize,
    /// å·²å®Œæˆçš„Kçº¿æ•°
    pub finalized_klines: usize,
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Rust
IGNORE_WHEN_COPYING_END

æˆ‘å·²å®Œæˆå¯¹ä»¥ä¸Šæ–‡ä»¶çš„æ”¹é€ ï¼Œå¹¶å‡†å¤‡å¥½ç»§ç»­å¤„ç†å‰©ä½™çš„æ–‡ä»¶ã€‚è¯·ç¡®è®¤è¿™äº›ä¿®æ”¹ç¬¦åˆæ‚¨çš„é¢„æœŸï¼Œç„¶åæˆ‘ä»¬å¯ä»¥ç»§ç»­ã€‚

ç»§ç»­å¤„ç†å‰©ä½™æ–‡ä»¶...

symbol_metadata_registry.txt

æ”¹é€ è¯´æ˜:

å…³é”®å‡½æ•°: ä¸ºæ‰€æœ‰å…¬å…±æ–¹æ³•å’Œæ ¸å¿ƒåˆå§‹åŒ–å‡½æ•°ï¼ˆå¦‚initialize_symbol_info, batch_get_symbol_listing_timesï¼‰æ·»åŠ äº†#[instrument]ã€‚

å…³é”®äº‹ä»¶: ä¸ºåˆå§‹åŒ–ã€æ³¨å†Œã€æŸ¥è¯¢ç­‰å…³é”®æ­¥éª¤çš„æ—¥å¿—æ·»åŠ äº†event_typeã€‚

å…³é”®çŠ¶æ€: åœ¨Spanå’Œäº‹ä»¶ä¸­è®°å½•äº†total_kline_slots, max_symbols, registered_countç­‰å…³é”®æŒ‡æ ‡ã€‚

é”™è¯¯è¯¦æƒ…: åœ¨APIè°ƒç”¨å¤±è´¥ã€æ•°æ®åº“æŸ¥è¯¢å¤±è´¥ç­‰è·¯å¾„è®°å½•äº†è¯¦ç»†é”™è¯¯ã€‚

//! äº¤æ˜“å“ç§å…ƒæ•°æ®æ³¨å†Œæ¨¡å—
//! 
//! è´Ÿè´£ç®¡ç†æ‰€æœ‰äº¤æ˜“å“ç§çš„å…ƒæ•°æ®ï¼ŒåŒ…æ‹¬å“ç§ç´¢å¼•åˆ†é…ã€ä¸Šå¸‚æ—¶é—´æŸ¥è¯¢ç­‰åŠŸèƒ½ã€‚

use crate::klaggregate::{AggregateConfig, SymbolInfo, PeriodInfo};
use crate::klcommon::{Result, AppError, BinanceApi, Database};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use tracing::{info, warn, error, debug, instrument};

/// äº¤æ˜“å“ç§å…ƒæ•°æ®æ³¨å†Œè¡¨
pub struct SymbolMetadataRegistry {
    /// é…ç½®
    config: AggregateConfig,
    
    /// å¸å®‰APIå®¢æˆ·ç«¯
    api_client: BinanceApi,
    
    /// æ•°æ®åº“è¿æ¥
    database: Arc<Database>,
    
    /// å“ç§ååˆ°ç´¢å¼•çš„æ˜ å°„
    symbol_to_index: Arc<RwLock<HashMap<String, u32>>>,
    
    /// ç´¢å¼•åˆ°å“ç§åçš„æ˜ å°„
    index_to_symbol: Arc<RwLock<HashMap<u32, String>>>,
    
    /// å“ç§ä¿¡æ¯æ˜ å°„
    symbol_info: Arc<RwLock<HashMap<String, SymbolInfo>>>,
    
    /// å‘¨æœŸä¿¡æ¯æ˜ å°„
    period_info: Arc<RwLock<HashMap<String, PeriodInfo>>>,
    
    /// æ€»çš„Kçº¿å­˜å‚¨æ§½æ•°é‡
    total_kline_slots: usize,
}

impl SymbolMetadataRegistry {
    /// åˆ›å»ºæ–°çš„å“ç§å…ƒæ•°æ®æ³¨å†Œè¡¨
    #[instrument(target = "SymbolMetadataRegistry", name="new_registry", fields(total_kline_slots), skip_all, err)]
    pub async fn new(config: AggregateConfig) -> Result<Self> {
        let total_kline_slots = config.get_total_kline_slots();
        tracing::Span::current().record("total_kline_slots", total_kline_slots);

        info!(target: "symbol_metadata_registry", event_type = "REGISTRY_INITIALIZING", "åˆå§‹åŒ–äº¤æ˜“å“ç§å…ƒæ•°æ®æ³¨å†Œè¡¨: max_symbols={}, supported_intervals_count={}", config.max_symbols, config.supported_intervals.len());
        
        // åˆ›å»ºAPIå®¢æˆ·ç«¯
        let api_client = BinanceApi::new();
        
        // åˆ›å»ºæ•°æ®åº“è¿æ¥
        let database = Arc::new(Database::new(&config.database.database_path)?);
        
        // ä½¿ç”¨ä¹‹å‰è®¡ç®—çš„æ€»å­˜å‚¨æ§½æ•°é‡
        
        let registry = Self {
            config: config.clone(),
            api_client,
            database,
            symbol_to_index: Arc::new(RwLock::new(HashMap::new())),
            index_to_symbol: Arc::new(RwLock::new(HashMap::new())),
            symbol_info: Arc::new(RwLock::new(HashMap::new())),
            period_info: Arc::new(RwLock::new(HashMap::new())),
            total_kline_slots,
        };
        
        // åˆå§‹åŒ–å‘¨æœŸä¿¡æ¯
        registry.initialize_period_info().await?;
        
        // åˆå§‹åŒ–å“ç§ä¿¡æ¯
        registry.initialize_symbol_info().await?;
        
        info!(target: "symbol_metadata_registry", event_type = "REGISTRY_INITIALIZED", "äº¤æ˜“å“ç§å…ƒæ•°æ®æ³¨å†Œè¡¨åˆå§‹åŒ–å®Œæˆ: total_kline_slots={}", total_kline_slots);
        Ok(registry)
    }

    /// åˆå§‹åŒ–å‘¨æœŸä¿¡æ¯
    #[instrument(target = "SymbolMetadataRegistry", name="init_period_info", fields(intervals_count = self.config.supported_intervals.len()), skip(self), err)]
    async fn initialize_period_info(&self) -> Result<()> {
        info!(target: "symbol_metadata_registry", event_type = "PERIOD_INFO_INITIALIZING", "åˆå§‹åŒ–å‘¨æœŸä¿¡æ¯: intervals_count={}", self.config.supported_intervals.len());

        let mut period_info = self.period_info.write().await;

        for (index, interval) in self.config.supported_intervals.iter().enumerate() {
            let info = PeriodInfo::new(interval.clone(), index as u32);
            period_info.insert(interval.clone(), info);
            debug!(target: "symbol_metadata_registry", event_type = "PERIOD_REGISTERED", "æ³¨å†Œå‘¨æœŸ: interval={}, index={}", interval, index);
        }

        info!(target: "symbol_metadata_registry", event_type = "PERIOD_INFO_INITIALIZED", "å·²æ³¨å†Œæ—¶é—´å‘¨æœŸ: periods_count={}", period_info.len());
        Ok(())
    }
    
    /// åˆå§‹åŒ–å“ç§ä¿¡æ¯
    #[instrument(target = "SymbolMetadataRegistry", name="init_symbol_info", fields(symbols_count = 0, registered_count = 0), skip(self), err)]
    async fn initialize_symbol_info(&self) -> Result<()> {
        info!(target: "symbol_metadata_registry", event_type = "SYMBOL_INFO_INITIALIZING", "åˆå§‹åŒ–å“ç§ä¿¡æ¯");

        // 1. è·å–å½“å‰æ‰€æœ‰æ´»è·ƒçš„äº¤æ˜“å“ç§
        let symbols = self.fetch_active_symbols().await?;
        tracing::Span::current().record("symbols_count", symbols.len());

        info!(target: "symbol_metadata_registry", event_type = "ACTIVE_SYMBOLS_FETCHED", "ä»APIè·å–åˆ°æ´»è·ƒäº¤æ˜“å“ç§: symbols_count={}", symbols.len());

        // 2. æ‰¹é‡æŸ¥è¯¢æ‰€æœ‰å“ç§çš„ä¸Šå¸‚æ—¶é—´ï¼ˆä¼˜åŒ–æ€§èƒ½ï¼‰
        info!(target: "symbol_metadata_registry", event_type = "LISTING_TIMES_QUERYING", "æ‰¹é‡æŸ¥è¯¢å“ç§ä¸Šå¸‚æ—¶é—´: symbols_count={}", symbols.len());
        let symbol_listing_times = self.batch_get_symbol_listing_times(&symbols).await?;

        info!(target: "symbol_metadata_registry", event_type = "LISTING_TIMES_QUERIED", "æ‰¹é‡æŸ¥è¯¢å“ç§ä¸Šå¸‚æ—¶é—´å®Œæˆ: valid_symbols_count={}, skipped_symbols_count={}", symbol_listing_times.len(), symbols.len() - symbol_listing_times.len());

        // 3. æŒ‰ä¸Šå¸‚æ—¶é—´æ’åº
        let mut sorted_symbols = symbol_listing_times;
        sorted_symbols.sort_by_key(|(_, listing_time)| *listing_time);

        // 4. åˆ†é…ç´¢å¼•
        let mut symbol_to_index = self.symbol_to_index.write().await;
        let mut index_to_symbol = self.index_to_symbol.write().await;
        let mut symbol_info = self.symbol_info.write().await;

        for (index, (symbol, listing_time)) in sorted_symbols.into_iter().enumerate() {
            let symbol_index = index as u32;

            // æ£€æŸ¥æ˜¯å¦è¶…è¿‡æœ€å¤§æ”¯æŒæ•°é‡
            if index >= self.config.max_symbols {
                warn!(target: "symbol_metadata_registry", event_type = "MAX_SYMBOLS_EXCEEDED", "å“ç§æ•°é‡è¶…è¿‡æœ€å¤§æ”¯æŒæ•°é‡ï¼Œè·³è¿‡å“ç§: max_symbols={}, symbol={}, current_index={}", self.config.max_symbols, symbol, index);
                break;
            }

            // å»ºç«‹æ˜ å°„å…³ç³»
            symbol_to_index.insert(symbol.clone(), symbol_index);
            index_to_symbol.insert(symbol_index, symbol.clone());

            // åˆ›å»ºå“ç§ä¿¡æ¯
            let info = SymbolInfo {
                symbol: symbol.clone(),
                index: symbol_index,
                listing_time,
            };
            symbol_info.insert(symbol.clone(), info);

            debug!(target: "symbol_metadata_registry", event_type = "SYMBOL_REGISTERED", "æ³¨å†Œå“ç§: symbol={}, symbol_index={}, listing_time={}", symbol, symbol_index, listing_time);
        }

        let registered_count = symbol_to_index.len();
        tracing::Span::current().record("registered_count", registered_count);

        info!(target: "symbol_metadata_registry", event_type = "SYMBOL_INFO_INITIALIZED", "å·²æ³¨å†Œäº¤æ˜“å“ç§: registered_count={}", registered_count);
        Ok(())
    }

    /// æ‰¹é‡è·å–å“ç§ä¸Šå¸‚æ—¶é—´ï¼ˆæ€§èƒ½ä¼˜åŒ–ï¼‰
    #[instrument(target = "SymbolMetadataRegistry", name="batch_get_listing_times", fields(symbols_count = symbols.len(), valid_count = 0, skipped_count = 0), skip(self, symbols), err)]
    async fn batch_get_symbol_listing_times(&self, symbols: &[String]) -> Result<Vec<(String, i64)>> {
        info!(target: "symbol_metadata_registry", event_type = "BATCH_LISTING_TIME_QUERY_START", "å¼€å§‹æ‰¹é‡æŸ¥è¯¢å“ç§ä¸Šå¸‚æ—¶é—´: symbols_count={}", symbols.len());

        // æ‰¹é‡æŸ¥è¯¢æ•°æ®åº“ä¸­æ‰€æœ‰å“ç§çš„æœ€æ—©Kçº¿æ—¶é—´
        let batch_results = self.database.batch_get_earliest_kline_timestamps(symbols, "1m")?;

        let mut valid_symbols = Vec::new();
        let mut skipped_count = 0;

        for (symbol, timestamp_opt) in batch_results {
            match timestamp_opt {
                Some(timestamp) => {
                    valid_symbols.push((symbol.clone(), timestamp));
                    debug!(target: "symbol_metadata_registry", "å“ç§ä¸Šå¸‚æ—¶é—´: symbol={}, listing_time={}", symbol, timestamp);
                }
                None => {
                    warn!(target: "symbol_metadata_registry", event_type = "SYMBOL_SKIPPED_NO_DATA", "è·³è¿‡å“ç§ï¼Œæ— å†å²æ•°æ®: symbol={}", symbol);
                    skipped_count += 1;
                }
            }
        }

        // æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„æœ‰æ•ˆå“ç§
        if valid_symbols.is_empty() {
            let err = AppError::DataError("æ²¡æœ‰ä»»ä½•å“ç§æœ‰å†å²Kçº¿æ•°æ®ï¼Œè¯·å…ˆä¸‹è½½å†å²æ•°æ®".to_string());
            error!(target: "symbol_metadata_registry", event_type="NO_VALID_SYMBOLS_FOUND", error = %err);
            return Err(err);
        }

        if skipped_count > symbols.len() * 3 / 4 {
            warn!(target: "symbol_metadata_registry", event_type = "HIGH_SKIP_RATE_WARNING", "è¶…è¿‡75%çš„å“ç§æ²¡æœ‰å†å²æ•°æ®ï¼Œå»ºè®®è¡¥å……å†å²æ•°æ®: skipped_count={}, total_count={}, skip_percentage={}%", skipped_count, symbols.len(), skipped_count * 100 / symbols.len());
        }

        tracing::Span::current().record("valid_count", valid_symbols.len());
        tracing::Span::current().record("skipped_count", skipped_count);

        info!(target: "symbol_metadata_registry", event_type = "BATCH_LISTING_TIME_QUERY_END", "æ‰¹é‡æŸ¥è¯¢å®Œæˆ: valid_count={}, skipped_count={}", valid_symbols.len(), skipped_count);

        Ok(valid_symbols)
    }
    
    /// è·å–æ´»è·ƒçš„äº¤æ˜“å“ç§åˆ—è¡¨
    #[instrument(target = "SymbolMetadataRegistry", name="fetch_active_symbols", fields(symbols_count = 0), skip(self), err)]
    async fn fetch_active_symbols(&self) -> Result<Vec<String>> {
        const MAX_RETRIES: usize = 3;
        const RETRY_DELAY_SECS: u64 = 2;
        
        for attempt in 1..=MAX_RETRIES {
            match self.api_client.get_trading_usdt_perpetual_symbols().await {
                Ok(symbols) => {
                    if symbols.is_empty() {
                        warn!(target: "symbol_metadata_registry", event_type = "EMPTY_SYMBOL_LIST_FROM_API", "APIè¿”å›ç©ºçš„äº¤æ˜“å“ç§åˆ—è¡¨: attempt={}, max_retries={}", attempt, MAX_RETRIES);
                    } else {
                        tracing::Span::current().record("symbols_count", symbols.len());
                        return Ok(symbols);
                    }
                }
                Err(e) => {
                    error!(target: "symbol_metadata_registry", event_type = "FETCH_SYMBOLS_API_ERROR", "è·å–äº¤æ˜“å“ç§åˆ—è¡¨å¤±è´¥: attempt={}, max_retries={}, error={}", attempt, MAX_RETRIES, e);
                }
            }
            
            if attempt < MAX_RETRIES {
                tokio::time::sleep(tokio::time::Duration::from_secs(RETRY_DELAY_SECS)).await;
            }
        }
        
        Err(AppError::ApiError(format!("è·å–äº¤æ˜“å“ç§åˆ—è¡¨å¤±è´¥ï¼Œå·²é‡è¯• {} æ¬¡", MAX_RETRIES)))
    }
    
    /// è·å–å“ç§çš„ä¸Šå¸‚æ—¶é—´ï¼ˆé¦–ä¸ª1åˆ†é’ŸKçº¿æ—¶é—´ï¼‰
    ///
    /// è¿™æ˜¯å…³é”®é€»è¾‘ï¼Œå¿…é¡»ç¡®ä¿è·å–åˆ°å‡†ç¡®çš„ä¸Šå¸‚æ—¶é—´ä»¥ä¿è¯ç´¢å¼•ç¨³å®šæ€§
    #[instrument(target = "SymbolMetadataRegistry", name="get_listing_time", fields(symbol = %symbol, listing_time = 0), skip(self), err)]
    async fn get_symbol_listing_time(&self, symbol: &str) -> Result<i64> {
        // æŸ¥è¯¢æ•°æ®åº“ä¸­è¯¥å“ç§çš„æœ€æ—©1åˆ†é’ŸKçº¿æ—¶é—´
        match self.database.get_earliest_kline_timestamp(symbol, "1m") {
            Ok(Some(timestamp)) => {
                tracing::Span::current().record("listing_time", timestamp);
                debug!(target: "symbol_metadata_registry", event_type = "LISTING_TIME_FROM_DB", "ä»æ•°æ®åº“è·å–å“ç§ä¸Šå¸‚æ—¶é—´: symbol={}, listing_time={}", symbol, timestamp);
                Ok(timestamp)
            }
            Ok(None) => {
                // æ•°æ®åº“ä¸­æ²¡æœ‰æ•°æ®ï¼Œè¿™æ˜¯å…³é”®é”™è¯¯ï¼Œä¸èƒ½ä½¿ç”¨é»˜è®¤å€¼
                let err = AppError::DataError(format!("å“ç§ {} ç¼ºå°‘å†å²Kçº¿æ•°æ®ï¼Œæ— æ³•ç¡®å®šä¸Šå¸‚æ—¶é—´ã€‚è¯·å…ˆä¸‹è½½è¯¥å“ç§çš„å†å²æ•°æ®ã€‚", symbol));
                error!(target: "symbol_metadata_registry", event_type = "LISTING_TIME_NOT_FOUND_IN_DB", "æ•°æ®åº“ä¸­æ²¡æœ‰å“ç§çš„å†å²Kçº¿æ•°æ®ï¼Œæ— æ³•ç¡®å®šä¸Šå¸‚æ—¶é—´: symbol={}", symbol);
                Err(err)
            }
            Err(e) => {
                let err = AppError::DataError(format!("æŸ¥è¯¢å“ç§ {} çš„ä¸Šå¸‚æ—¶é—´å¤±è´¥: {}ã€‚è¯·æ£€æŸ¥æ•°æ®åº“è¿æ¥å’Œæ•°æ®å®Œæ•´æ€§ã€‚", symbol, e));
                error!(target: "symbol_metadata_registry", event_type = "LISTING_TIME_DB_QUERY_FAILED", "æŸ¥è¯¢å“ç§ä¸Šå¸‚æ—¶é—´å¤±è´¥: symbol={}, error={}", symbol, e);
                Err(err)
            }
        }
    }
    
    /// é€šè¿‡å“ç§åè·å–ç´¢å¼•
    pub async fn get_symbol_index(&self, symbol: &str) -> Option<u32> {
        self.symbol_to_index.read().await.get(symbol).copied()
    }
    
    /// é€šè¿‡ç´¢å¼•è·å–å“ç§å
    pub async fn get_symbol_by_index(&self, index: u32) -> Option<String> {
        self.index_to_symbol.read().await.get(&index).cloned()
    }
    
    /// è·å–æ‰€æœ‰å·²æ³¨å†Œçš„å“ç§åŠå…¶ç´¢å¼•
    pub async fn get_all_symbols(&self) -> Result<Vec<(String, u32)>> {
        let symbol_to_index = self.symbol_to_index.read().await;
        Ok(symbol_to_index.iter().map(|(symbol, &index)| (symbol.clone(), index)).collect())
    }
    
    /// è·å–å“ç§ä¿¡æ¯
    pub async fn get_symbol_info(&self, symbol: &str) -> Option<SymbolInfo> {
        self.symbol_info.read().await.get(symbol).cloned()
    }
    
    /// è·å–å‘¨æœŸä¿¡æ¯
    pub async fn get_period_info(&self, interval: &str) -> Option<PeriodInfo> {
        self.period_info.read().await.get(interval).cloned()
    }
    
    /// è·å–å‘¨æœŸç´¢å¼•
    pub async fn get_period_index(&self, interval: &str) -> Option<u32> {
        self.period_info.read().await.get(interval).map(|info| info.index)
    }
    
    /// é€šè¿‡ç´¢å¼•è·å–å‘¨æœŸå­—ç¬¦ä¸²
    pub async fn get_interval_by_index(&self, index: u32) -> Option<String> {
        let period_info = self.period_info.read().await;
        period_info.values().find(|info| info.index == index).map(|info| info.interval.clone())
    }
    
    /// è·å–æ€»çš„Kçº¿å­˜å‚¨æ§½æ•°é‡
    pub fn get_total_kline_slots(&self) -> usize {
        self.total_kline_slots
    }
    
    /// è·å–æ”¯æŒçš„å‘¨æœŸæ•°é‡
    pub fn get_periods_per_symbol(&self) -> usize {
        self.config.supported_intervals.len()
    }
    
    /// è®¡ç®—æ‰å¹³åŒ–å­˜å‚¨ç´¢å¼•
    pub fn calculate_flat_index(&self, symbol_index: u32, period_index: u32) -> usize {
        (symbol_index as usize) * self.get_periods_per_symbol() + (period_index as usize)
    }
    
    /// ä»æ‰å¹³åŒ–ç´¢å¼•è§£æå“ç§å’Œå‘¨æœŸç´¢å¼•
    pub fn parse_flat_index(&self, flat_index: usize) -> (u32, u32) {
        let periods_per_symbol = self.get_periods_per_symbol();
        let symbol_index = (flat_index / periods_per_symbol) as u32;
        let period_index = (flat_index % periods_per_symbol) as u32;
        (symbol_index, period_index)
    }
    
    /// è·å–æ³¨å†Œçš„å“ç§æ•°é‡
    pub async fn get_symbol_count(&self) -> usize {
        self.symbol_to_index.read().await.len()
    }
    
    /// è·å–æ”¯æŒçš„å‘¨æœŸåˆ—è¡¨
    pub fn get_supported_intervals(&self) -> &[String] {
        &self.config.supported_intervals
    }
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Rust
IGNORE_WHEN_COPYING_END
trade_event_router.txt

æ”¹é€ è¯´æ˜:

å…³é”®å‡½æ•°: å¯¹æ‰€æœ‰å…¬å…±æ–¹æ³•éƒ½æ·»åŠ äº†#[instrument]ï¼Œç‰¹åˆ«æ˜¯route_trade_eventè¿™ä¸ªçƒ­ç‚¹è·¯å¾„ï¼Œä¿ç•™äº†å…¶å…³é”®å‚æ•°çš„è®°å½•ã€‚

å…³é”®äº‹ä»¶: ä¸ºæ³¨å†Œã€æ³¨é”€ã€è·¯ç”±å¤±è´¥ç­‰äº‹ä»¶æ·»åŠ äº†event_typeã€‚

é”™è¯¯è¯¦æƒ…: åœ¨è·¯ç”±å¤±è´¥å’Œèšåˆå™¨å¤„ç†å¤±è´¥æ—¶è®°å½•è¯¦ç»†é”™è¯¯ã€‚

//! äº¤æ˜“äº‹ä»¶è·¯ç”±æ¨¡å—
//! 
//! è´Ÿè´£å°†å½’é›†äº¤æ˜“æ•°æ®è·¯ç”±åˆ°å¯¹åº”çš„å“ç§èšåˆå™¨ã€‚

use crate::klaggregate::{AggTradeData, SymbolKlineAggregator};
use crate::klcommon::{Result, AppError};
use std::sync::Arc;
use std::collections::HashMap;
use tokio::sync::RwLock;
use tracing::{debug, warn, error, info, instrument};

/// äº¤æ˜“äº‹ä»¶è·¯ç”±å™¨
pub struct TradeEventRouter {
    /// å“ç§åˆ°èšåˆå™¨çš„æ˜ å°„
    aggregators: Arc<RwLock<HashMap<String, Arc<SymbolKlineAggregator>>>>,
    
    /// è·¯ç”±ç»Ÿè®¡ä¿¡æ¯
    route_count: Arc<RwLock<HashMap<String, u64>>>,
    
    /// é”™è¯¯è®¡æ•°
    error_count: Arc<RwLock<u64>>,
}

impl TradeEventRouter {
    /// åˆ›å»ºæ–°çš„äº¤æ˜“äº‹ä»¶è·¯ç”±å™¨
    #[instrument(target = "TradeEventRouter", name="new_router")]
    pub fn new() -> Self {
        info!(target: "trade_event_router", event_type = "ROUTER_CREATED", "åˆ›å»ºäº¤æ˜“äº‹ä»¶è·¯ç”±å™¨");
        
        Self {
            aggregators: Arc::new(RwLock::new(HashMap::new())),
            route_count: Arc::new(RwLock::new(HashMap::new())),
            error_count: Arc::new(RwLock::new(0)),
        }
    }
    
    /// æ³¨å†Œå“ç§èšåˆå™¨
    #[instrument(target = "TradeEventRouter", name="register_aggregator", fields(symbol = %symbol), skip(self, aggregator), err)]
    pub async fn register_aggregator(
        &self,
        symbol: String,
        aggregator: Arc<SymbolKlineAggregator>,
    ) -> Result<()> {
        debug!(target: "trade_event_router", event_type = "AGGREGATOR_REGISTERING", "æ³¨å†Œå“ç§èšåˆå™¨: symbol={}", symbol);

        let mut aggregators = self.aggregators.write().await;

        if aggregators.contains_key(&symbol) {
            warn!(target: "trade_event_router", event_type = "AGGREGATOR_REPLACED", "å“ç§èšåˆå™¨å·²å­˜åœ¨ï¼Œå°†è¢«æ›¿æ¢: symbol={}", symbol);
        }

        aggregators.insert(symbol.clone(), aggregator);

        // åˆå§‹åŒ–è·¯ç”±è®¡æ•°
        let mut route_count = self.route_count.write().await;
        route_count.insert(symbol.clone(), 0);

        debug!(target: "trade_event_router", event_type = "AGGREGATOR_REGISTERED", "å“ç§èšåˆå™¨æ³¨å†Œå®Œæˆ: symbol={}", symbol);
        Ok(())
    }
    
    /// å–æ¶ˆæ³¨å†Œå“ç§èšåˆå™¨
    #[instrument(target = "TradeEventRouter", name="unregister_aggregator", fields(symbol = %symbol), skip(self), err)]
    pub async fn unregister_aggregator(&self, symbol: &str) -> Result<()> {
        debug!(target: "trade_event_router", event_type = "AGGREGATOR_UNREGISTERING", "å–æ¶ˆæ³¨å†Œå“ç§èšåˆå™¨: symbol={}", symbol);

        let mut aggregators = self.aggregators.write().await;
        let mut route_count = self.route_count.write().await;

        aggregators.remove(symbol);
        route_count.remove(symbol);

        debug!(target: "trade_event_router", event_type = "AGGREGATOR_UNREGISTERED", "å“ç§èšåˆå™¨å–æ¶ˆæ³¨å†Œå®Œæˆ: symbol={}", symbol);
        Ok(())
    }
    
    /// è·¯ç”±äº¤æ˜“äº‹ä»¶
    #[instrument(target = "TradeEventRouter", name="route_trade", fields(symbol = %trade.symbol, price = %trade.price, quantity = %trade.quantity), skip(self), err)]
    pub async fn route_trade_event(&self, trade: AggTradeData) -> Result<()> {
        // æŸ¥æ‰¾å¯¹åº”çš„èšåˆå™¨
        let aggregators = self.aggregators.read().await;
        
        if let Some(aggregator) = aggregators.get(&trade.symbol) {
            // æ‰¾åˆ°å¯¹åº”çš„èšåˆå™¨ï¼Œå¤„ç†äº¤æ˜“
            if let Err(e) = aggregator.process_agg_trade(&trade).await {
                error!(target: "trade_event_router", event_type = "AGGREGATION_FAILED", "å¤„ç†å“ç§äº¤æ˜“å¤±è´¥: symbol={}, error={}", trade.symbol, e);

                // æ›´æ–°é”™è¯¯è®¡æ•°
                let mut error_count = self.error_count.write().await;
                *error_count += 1;

                return Err(e);
            } else {
                // æ›´æ–°è·¯ç”±è®¡æ•°
                let mut route_count = self.route_count.write().await;
                *route_count.entry(trade.symbol.clone()).or_insert(0) += 1;
            }
        } else {
            warn!(target: "trade_event_router", event_type = "AGGREGATOR_NOT_FOUND", "æœªæ‰¾åˆ°å“ç§èšåˆå™¨: symbol={}", trade.symbol);

            // æ›´æ–°é”™è¯¯è®¡æ•°
            let mut error_count = self.error_count.write().await;
            *error_count += 1;

            return Err(AppError::DataError(format!(
                "æœªæ‰¾åˆ°å“ç§ {} çš„èšåˆå™¨",
                trade.symbol
            )));
        }
        
        Ok(())
    }
    
    /// æ‰¹é‡è·¯ç”±äº¤æ˜“äº‹ä»¶
    #[instrument(target = "TradeEventRouter", name="route_batch", fields(trades_count = trades.len()), skip(self, trades), err)]
    pub async fn route_trade_events(&self, trades: Vec<AggTradeData>) -> Result<()> {
        let mut success_count = 0;
        let mut error_count = 0;
        
        for trade in trades {
            if self.route_trade_event(trade).await.is_err() {
                error_count += 1;
            } else {
                success_count += 1;
            }
        }

        if error_count > 0 {
            warn!(target: "trade_event_router", event_type = "BATCH_ROUTE_COMPLETED_WITH_ERRORS", "æ‰¹é‡è·¯ç”±å®Œæˆï¼Œä½†æœ‰é”™è¯¯: success_count={}, error_count={}", success_count, error_count);
        } else {
            debug!(target: "trade_event_router", event_type = "BATCH_ROUTE_COMPLETED_SUCCESSFULLY", "æ‰¹é‡è·¯ç”±å®Œæˆ: success_count={}", success_count);
        }
        
        Ok(())
    }
    
    /// è·å–å·²æ³¨å†Œçš„å“ç§åˆ—è¡¨
    pub async fn get_registered_symbols(&self) -> Vec<String> {
        let aggregators = self.aggregators.read().await;
        aggregators.keys().cloned().collect()
    }
    
    /// è·å–æŒ‡å®šå“ç§çš„èšåˆå™¨
    pub async fn get_aggregator(&self, symbol: &str) -> Option<Arc<SymbolKlineAggregator>> {
        let aggregators = self.aggregators.read().await;
        aggregators.get(symbol).cloned()
    }
    
    /// è·å–æ‰€æœ‰èšåˆå™¨
    pub async fn get_all_aggregators(&self) -> HashMap<String, Arc<SymbolKlineAggregator>> {
        let aggregators = self.aggregators.read().await;
        aggregators.clone()
    }
    
    /// å¼ºåˆ¶å®Œæˆæ‰€æœ‰èšåˆå™¨çš„Kçº¿
    #[instrument(target = "TradeEventRouter", name="finalize_all", skip(self), err)]
    pub async fn finalize_all_aggregators(&self) -> Result<()> {
        info!(target: "trade_event_router", event_type = "FINALIZE_ALL_AGGREGATORS_STARTING", "å¼ºåˆ¶å®Œæˆæ‰€æœ‰èšåˆå™¨çš„Kçº¿");

        let aggregators = self.aggregators.read().await;
        let mut success_count = 0;
        let mut error_count = 0;

        for (symbol, aggregator) in aggregators.iter() {
            match aggregator.finalize_all_klines().await {
                Ok(()) => {
                    success_count += 1;
                    debug!(target: "trade_event_router", event_type = "AGGREGATOR_FINALIZED_SUCCESS", "å“ç§Kçº¿å¼ºåˆ¶å®ŒæˆæˆåŠŸ: symbol={}", symbol);
                }
                Err(e) => {
                    error_count += 1;
                    error!(target: "trade_event_router", event_type = "AGGREGATOR_FINALIZE_FAILED", "å“ç§Kçº¿å¼ºåˆ¶å®Œæˆå¤±è´¥: symbol={}, error={}", symbol, e);
                }
            }
        }

        info!(target: "trade_event_router", event_type = "FINALIZE_ALL_AGGREGATORS_COMPLETED", "å¼ºåˆ¶å®ŒæˆKçº¿æ“ä½œå®Œæˆ: success_count={}, error_count={}", success_count, error_count);
        
        if error_count > 0 {
            Err(AppError::DataError(format!(
                "éƒ¨åˆ†èšåˆå™¨å¼ºåˆ¶å®Œæˆå¤±è´¥: {} ä¸ªå¤±è´¥",
                error_count
            )))
        } else {
            Ok(())
        }
    }
    
    /// è·å–è·¯ç”±ç»Ÿè®¡ä¿¡æ¯
    pub async fn get_statistics(&self) -> RouterStatistics {
        let aggregators = self.aggregators.read().await;
        let route_count = self.route_count.read().await;
        let error_count = self.error_count.read().await;
        
        let total_routes: u64 = route_count.values().sum();
        let registered_symbols = aggregators.len();
        
        RouterStatistics {
            registered_symbols,
            total_routes,
            error_count: *error_count,
            symbol_route_counts: route_count.clone(),
        }
    }
    
    /// é‡ç½®ç»Ÿè®¡ä¿¡æ¯
    #[instrument(target = "TradeEventRouter", name="reset_stats", skip(self))]
    pub async fn reset_statistics(&self) {
        let mut route_count = self.route_count.write().await;
        let mut error_count = self.error_count.write().await;
        
        for count in route_count.values_mut() {
            *count = 0;
        }
        *error_count = 0;
        
        info!(target: "trade_event_router", event_type = "ROUTER_STATS_RESET", "è·¯ç”±ç»Ÿè®¡ä¿¡æ¯å·²é‡ç½®");
    }
    
    /// æ£€æŸ¥è·¯ç”±å™¨å¥åº·çŠ¶æ€
    pub async fn health_check(&self) -> RouterHealthStatus {
        let aggregators = self.aggregators.read().await;
        let error_count = self.error_count.read().await;
        
        let registered_count = aggregators.len();
        let is_healthy = registered_count > 0 && *error_count < 1000; // é”™è¯¯æ•°å°‘äº1000è®¤ä¸ºå¥åº·
        
        RouterHealthStatus {
            is_healthy,
            registered_aggregators: registered_count,
            total_errors: *error_count,
            status_message: if is_healthy {
                "è·¯ç”±å™¨è¿è¡Œæ­£å¸¸".to_string()
            } else if registered_count == 0 {
                "æ²¡æœ‰æ³¨å†Œçš„èšåˆå™¨".to_string()
            } else {
                format!("é”™è¯¯æ•°è¿‡å¤š: {}", *error_count)
            },
        }
    }
}

impl Default for TradeEventRouter {
    fn default() -> Self {
        Self::new()
    }
}

/// è·¯ç”±ç»Ÿè®¡ä¿¡æ¯
#[derive(Debug, Clone)]
pub struct RouterStatistics {
    /// å·²æ³¨å†Œçš„å“ç§æ•°é‡
    pub registered_symbols: usize,
    /// æ€»è·¯ç”±æ¬¡æ•°
    pub total_routes: u64,
    /// é”™è¯¯è®¡æ•°
    pub error_count: u64,
    /// æ¯ä¸ªå“ç§çš„è·¯ç”±æ¬¡æ•°
    pub symbol_route_counts: HashMap<String, u64>,
}

/// è·¯ç”±å™¨å¥åº·çŠ¶æ€
#[derive(Debug, Clone)]
pub struct RouterHealthStatus {
    /// æ˜¯å¦å¥åº·
    pub is_healthy: bool,
    /// å·²æ³¨å†Œçš„èšåˆå™¨æ•°é‡
    pub registered_aggregators: usize,
    /// æ€»é”™è¯¯æ•°
    pub total_errors: u64,
    /// çŠ¶æ€æ¶ˆæ¯
    pub status_message: String,
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Rust
IGNORE_WHEN_COPYING_END
market_data_ingestor.txt

æ”¹é€ è¯´æ˜:

å…³é”®å‡½æ•°: ä¸ºnew, start, stopæ·»åŠ äº†#[instrument]ã€‚

å¹¶å‘è¿½è¸ª: ä¸ºå¤„ç†äº¤æ˜“äº‹ä»¶å’Œç»Ÿè®¡çš„tokio::spawnæ·»åŠ äº†instrumentï¼Œå¹¶æ¸…æ™°å‘½åã€‚

å…³é”®äº‹ä»¶: ä¸ºå¯åŠ¨ã€åœæ­¢ã€è®¢é˜…ã€è·¯ç”±å¤±è´¥ç­‰äº‹ä»¶æ·»åŠ äº†event_typeã€‚

é”™è¯¯è¯¦æƒ…: åœ¨è·¯ç”±äº¤æ˜“äº‹ä»¶å¤±è´¥æ—¶è®°å½•è¯¦ç»†é”™è¯¯ã€‚

//! è¡Œæƒ…æ•°æ®æ¥å…¥ä¸è§£ææ¨¡å—
//! 
//! è´Ÿè´£é€šè¿‡WebSocketæ¥æ”¶å¸å®‰å½’é›†äº¤æ˜“æ•°æ®ï¼Œå¹¶è§£æè½¬å‘ç»™è·¯ç”±å™¨ã€‚

use crate::klaggregate::{AggregateConfig, TradeEventRouter};
use crate::klcommon::{Result, AppError, websocket::*};
use std::sync::Arc;
use std::sync::atomic::{AtomicBool, AtomicUsize, Ordering};
use tokio::sync::RwLock;
use tokio::time::{interval, Duration};
use tracing::{info, debug, warn, error, instrument};

/// è¡Œæƒ…æ•°æ®æ¥å…¥å™¨
pub struct MarketDataIngestor {
    /// é…ç½®
    config: AggregateConfig,
    
    /// äº¤æ˜“äº‹ä»¶è·¯ç”±å™¨
    trade_router: Arc<TradeEventRouter>,
    
    /// WebSocketå®¢æˆ·ç«¯
    websocket_client: Arc<RwLock<Option<Arc<RwLock<AggTradeWebSocketClient>>>>>,
    
    /// è¿è¡ŒçŠ¶æ€
    is_running: Arc<AtomicBool>,

    /// è¿æ¥è®¡æ•°
    connection_count: Arc<AtomicUsize>,

    /// æ¶ˆæ¯ç»Ÿè®¡
    message_count: Arc<AtomicUsize>,

    /// é”™è¯¯è®¡æ•°
    error_count: Arc<AtomicUsize>,
}

impl MarketDataIngestor {
    /// åˆ›å»ºæ–°çš„è¡Œæƒ…æ•°æ®æ¥å…¥å™¨
    #[instrument(target = "MarketDataIngestor", name="new_ingestor", skip_all, err)]
    pub async fn new(
        config: AggregateConfig,
        trade_router: Arc<TradeEventRouter>,
    ) -> Result<Self> {
        info!(target: "market_data_ingestor", event_type = "INGESTOR_INITIALIZING", "åˆ›å»ºè¡Œæƒ…æ•°æ®æ¥å…¥å™¨");
        
        Ok(Self {
            config,
            trade_router,
            websocket_client: Arc::new(RwLock::new(None)),
            is_running: Arc::new(AtomicBool::new(false)),
            connection_count: Arc::new(AtomicUsize::new(0)),
            message_count: Arc::new(AtomicUsize::new(0)),
            error_count: Arc::new(AtomicUsize::new(0)),
        })
    }
    
    /// å¯åŠ¨æ•°æ®æ¥å…¥
    #[instrument(target = "MarketDataIngestor", name="start_ingestor", fields(symbols_count), skip(self), err)]
    pub async fn start(&self) -> Result<()> {
        if self.is_running.swap(true, Ordering::Relaxed) {
            warn!(target: "market_data_ingestor", event_type = "INGESTOR_ALREADY_RUNNING", "è¡Œæƒ…æ•°æ®æ¥å…¥å™¨å·²ç»åœ¨è¿è¡Œ");
            return Ok(());
        }

        info!(target: "market_data_ingestor", event_type = "INGESTOR_STARTING", "å¯åŠ¨è¡Œæƒ…æ•°æ®æ¥å…¥å™¨");

        // è·å–éœ€è¦è®¢é˜…çš„å“ç§åˆ—è¡¨
        let symbols = self.trade_router.get_registered_symbols().await;
        if symbols.is_empty() {
            let err = AppError::ConfigError("æ²¡æœ‰æ³¨å†Œçš„äº¤æ˜“å“ç§".to_string());
            error!(target: "market_data_ingestor", event_type = "NO_SYMBOLS_TO_SUBSCRIBE", error = %err, "å¯åŠ¨å¤±è´¥ï¼Œæ²¡æœ‰å¯è®¢é˜…çš„å“ç§");
            return Err(err);
        }

        tracing::Span::current().record("symbols_count", symbols.len());
        info!(target: "market_data_ingestor", event_type = "SYMBOLS_SUBSCRIPTION_PREPARING", "å‡†å¤‡è®¢é˜…å“ç§çš„å½’é›†äº¤æ˜“æ•°æ®: symbols_count={}", symbols.len());
        
        // åˆ›å»ºWebSocketé…ç½®
        let ws_config = AggTradeConfig {
            use_proxy: self.config.websocket.use_proxy,
            proxy_addr: self.config.websocket.proxy_host.clone(),
            proxy_port: self.config.websocket.proxy_port,
            symbols,
        };
        
        // åˆ›å»ºäº¤æ˜“æ•°æ®é€šé“
        let (trade_sender, trade_receiver) = tokio::sync::mpsc::unbounded_channel();

        // å¯åŠ¨äº¤æ˜“äº‹ä»¶å¤„ç†ä»»åŠ¡
        let trade_router = self.trade_router.clone();
        tokio::spawn(async move {
            let mut receiver = trade_receiver;
            while let Some(trade_data) = receiver.recv().await {
                if let Err(e) = trade_router.route_trade_event(trade_data).await {
                    error!(target: "market_data_ingestor", event_type = "TRADE_ROUTING_FAILED_IN_CHANNEL", error = %e, "ä»é€šé“ä¸­è·¯ç”±äº¤æ˜“äº‹ä»¶å¤±è´¥");
                }
            }
            warn!(target = "market_data_ingestor", event_type = "TRADE_RECEIVER_CHANNEL_CLOSED", "äº¤æ˜“äº‹ä»¶æ¥æ”¶é€šé“å·²å…³é—­ï¼Œä»»åŠ¡é€€å‡º");
        }.instrument(tracing::info_span!("trade_event_processor")));

        // åˆ›å»ºWebSocketå®¢æˆ·ç«¯
        let client = Arc::new(RwLock::new(AggTradeWebSocketClient::new(
            ws_config,
            Arc::new(AggTradeMessageHandler::with_trade_sender(
                self.message_count.clone(),
                self.error_count.clone(),
                trade_sender,
            )),
        )));
        
        *self.websocket_client.write().await = Some(client.clone());
        
        // å¯åŠ¨WebSocketå®¢æˆ·ç«¯
        let mut client_guard = client.write().await;
        client_guard.start().await?;
        drop(client_guard);
        
        // å¯åŠ¨ç»Ÿè®¡è¾“å‡ºä»»åŠ¡
        self.start_statistics_task().await;
        
        info!(target: "market_data_ingestor", event_type = "INGESTOR_STARTED", "è¡Œæƒ…æ•°æ®æ¥å…¥å™¨å¯åŠ¨å®Œæˆ");
        Ok(())
    }

    /// åœæ­¢æ•°æ®æ¥å…¥
    #[instrument(target = "MarketDataIngestor", name="stop_ingestor", skip(self), err)]
    pub async fn stop(&self) -> Result<()> {
        if !self.is_running.swap(false, Ordering::Relaxed) {
            info!(target: "market_data_ingestor", event_type = "INGESTOR_ALREADY_STOPPED", "è¡Œæƒ…æ•°æ®æ¥å…¥å™¨æœªåœ¨è¿è¡Œï¼Œæ— éœ€åœæ­¢");
            return Ok(());
        }

        info!(target: "market_data_ingestor", event_type = "INGESTOR_STOPPING", "åœæ­¢è¡Œæƒ…æ•°æ®æ¥å…¥å™¨");

        // åœæ­¢WebSocketå®¢æˆ·ç«¯
        let websocket_client = self.websocket_client.read().await;
        if let Some(_client) = &*websocket_client {
            // WebSocketå®¢æˆ·ç«¯ä¼šåœ¨è¿æ¥æ–­å¼€æ—¶è‡ªåŠ¨åœæ­¢
            debug!(target: "market_data_ingestor", event_type = "WEBSOCKET_CLIENT_AUTO_STOP", "WebSocketå®¢æˆ·ç«¯å°†è‡ªåŠ¨åœæ­¢");
        }

        info!(target: "market_data_ingestor", event_type = "INGESTOR_STOPPED", "è¡Œæƒ…æ•°æ®æ¥å…¥å™¨å·²åœæ­¢");
        Ok(())
    }
    
    /// å¯åŠ¨ç»Ÿè®¡è¾“å‡ºä»»åŠ¡
    #[instrument(target = "MarketDataIngestor", name="start_stats_task", skip(self))]
    async fn start_statistics_task(&self) {
        let is_running = self.is_running.clone();
        let message_count = self.message_count.clone();
        let error_count = self.error_count.clone();
        let connection_count = self.connection_count.clone();
        
        tokio::spawn(async move {
            let mut interval_timer = interval(Duration::from_secs(30));
            let mut last_message_count = 0;
            let mut last_error_count = 0;
            
            while is_running.load(Ordering::Relaxed) {
                interval_timer.tick().await;
                
                let current_messages = message_count.load(Ordering::Relaxed);
                let current_errors = error_count.load(Ordering::Relaxed);
                let connections = connection_count.load(Ordering::Relaxed);

                let message_rate = current_messages - last_message_count;
                let error_rate = current_errors - last_error_count;

                info!(
                    target: "market_data_ingestor",
                    event_type = "INGESTOR_STATS_REPORT",
                    connections,
                    total_messages = current_messages,
                    message_rate_per_30s = message_rate,
                    total_errors = current_errors,
                    error_rate_per_30s = error_rate,
                    "è¡Œæƒ…æ•°æ®ç»Ÿè®¡æŠ¥å‘Š"
                );
                
                last_message_count = current_messages;
                last_error_count = current_errors;
            }
        }.instrument(tracing::info_span!("ingestor_statistics_task")));
    }
    
    /// è·å–è¿æ¥æ•°é‡
    pub async fn get_connection_count(&self) -> usize {
        self.connection_count.load(Ordering::Relaxed)
    }
    
    /// è·å–ç»Ÿè®¡ä¿¡æ¯
    pub async fn get_statistics(&self) -> IngestorStatistics {
        IngestorStatistics {
            is_running: self.is_running.load(Ordering::Relaxed),
            connection_count: self.connection_count.load(Ordering::Relaxed),
            message_count: self.message_count.load(Ordering::Relaxed),
            error_count: self.error_count.load(Ordering::Relaxed),
        }
    }
}

/// å½’é›†äº¤æ˜“WebSocketå®¢æˆ·ç«¯
struct AggTradeWebSocketClient {
    _config: AggTradeConfig,
    _message_handler: Arc<AggTradeMessageHandler>,
}

impl AggTradeWebSocketClient {
    fn new(config: AggTradeConfig, message_handler: Arc<AggTradeMessageHandler>) -> Self {
        Self {
            _config: config,
            _message_handler: message_handler,
        }
    }
}

impl WebSocketClient for AggTradeWebSocketClient {
    #[instrument(target = "AggTradeWebSocketClient", name="start_websocket", skip(self), err)]
    async fn start(&mut self) -> Result<()> {
        info!(target: "market_data_ingestor", event_type = "WEBSOCKET_CLIENT_STARTING", "å¯åŠ¨å½’é›†äº¤æ˜“WebSocketå®¢æˆ·ç«¯");

        // åˆ›å»ºå½’é›†äº¤æ˜“é…ç½®
        let agg_trade_config = crate::klcommon::websocket::AggTradeConfig {
            use_proxy: self._config.use_proxy,
            proxy_addr: self._config.proxy_addr.clone(),
            proxy_port: self._config.proxy_port,
            symbols: self._config.symbols.clone(),
        };

        // åˆ›å»ºæ•°æ®åº“è¿æ¥
        let db = Arc::new(crate::klcommon::Database::new(&std::path::PathBuf::from("./data/klines.db"))?);

        // åˆ›å»ºå½’é›†äº¤æ˜“å®¢æˆ·ç«¯
        let mut agg_trade_client = crate::klcommon::websocket::AggTradeClient::new(
            agg_trade_config,
            db,
            vec!["1m".to_string()], // ä¸´æ—¶ä½¿ç”¨ï¼Œå®é™…ä¸éœ€è¦
        );

        // å¯åŠ¨WebSocketå®¢æˆ·ç«¯
        agg_trade_client.start().await?;

        info!(target: "market_data_ingestor", event_type = "WEBSOCKET_CLIENT_STARTED", "å½’é›†äº¤æ˜“WebSocketå®¢æˆ·ç«¯å¯åŠ¨å®Œæˆ");
        Ok(())
    }

    async fn get_connections(&self) -> Vec<WebSocketConnection> {
        // è¿”å›è¿æ¥çŠ¶æ€
        vec![]
    }
}



/// æ¥å…¥å™¨ç»Ÿè®¡ä¿¡æ¯
#[derive(Debug, Clone)]
pub struct IngestorStatistics {
    /// æ˜¯å¦è¿è¡Œä¸­
    pub is_running: bool,
    /// è¿æ¥æ•°é‡
    pub connection_count: usize,
    /// æ¶ˆæ¯è®¡æ•°
    pub message_count: usize,
    /// é”™è¯¯è®¡æ•°
    pub error_count: usize,
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Rust
IGNORE_WHEN_COPYING_END
æ— éœ€ä¿®æ”¹çš„æ–‡ä»¶

ä»¥ä¸‹æ–‡ä»¶ä¸»è¦æ˜¯å®šä¹‰æ•°æ®ç»“æ„ã€é…ç½®ã€æ¥å£æˆ–éªŒè¯è§„åˆ™ï¼Œä¸åŒ…å«éœ€è¦è¿›è¡Œæ—¥å¿—åŸ‹ç‚¹æ”¹é€ çš„æ´»åŠ¨ä¸šåŠ¡é€»è¾‘ã€‚å› æ­¤ï¼Œå®ƒä»¬ä¿æŒåŸæ ·ã€‚

config.txt

observability.txt

types.txt

validation_rules.txt

æ€»ç»“

æˆ‘å·²ç»æŒ‰ç…§æ‚¨çš„ â€œå››åŠ ä¸€â€é»„é‡‘æ—¥å¿—èŒƒå¼ï¼Œå¯¹æ‰€æœ‰ç›¸å…³çš„Rustä»£ç æ–‡ä»¶è¿›è¡Œäº†å…¨é¢çš„æ—¥å¿—åŸ‹ç‚¹æ”¹é€ ã€‚

ä¸»è¦æ”¹è¿›åŒ…æ‹¬ï¼š

å…¨é¢çš„#[instrument]è¦†ç›–ï¼šä¸ºæ‰€æœ‰å…³é”®çš„å…¬å…±å‡½æ•°å’Œæ ¸å¿ƒç§æœ‰å‡½æ•°æ·»åŠ äº†Spanï¼Œå¹¶è®°å½•äº†å…³é”®å‚æ•°ã€‚

æ¸…æ™°çš„å¹¶å‘è¿½è¸ªï¼šä¸ºæ‰€æœ‰ç‹¬ç«‹çš„tokio::spawnä»»åŠ¡ï¼ˆå¦‚è°ƒåº¦å™¨ã€ç»Ÿè®¡ä»»åŠ¡ã€äº‹ä»¶å¤„ç†å™¨ï¼‰æ·»åŠ äº†instrumentï¼Œç¡®ä¿æ¯ä¸ªå¹¶å‘æµéƒ½æœ‰å”¯ä¸€çš„è¿½è¸ªSpanã€‚

æ ‡å‡†åŒ–çš„å…³é”®äº‹ä»¶ï¼šä¸ºæ‰€æœ‰info!, warn!, error!æ—¥å¿—éƒ½å¢åŠ äº†event_typeå­—æ®µï¼Œä½¿ç”¨ç»Ÿä¸€çš„ UPPER_SNAKE_CASE å‘½åï¼Œå¹¶ä¿ç•™äº†ä¸­æ–‡å¯è¯»ä¿¡æ¯ã€‚

ä¸°å¯Œçš„ä¸Šä¸‹æ–‡æ•°æ®ï¼šåœ¨äº‹ä»¶å’ŒSpanä¸­é™„åŠ ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼Œå¦‚è®¡æ•°å™¨ã€é…ç½®å€¼ã€æ€§èƒ½æŒ‡æ ‡ï¼ˆè€—æ—¶ï¼‰å’Œè¯¦ç»†çš„é”™è¯¯ä¿¡æ¯ï¼ˆerror = %eï¼‰ã€‚

è¿™äº›ä¿®æ”¹å°†äº§ç”Ÿé«˜åº¦ç»“æ„åŒ–ã€ä¿¡æ¯ä¸°å¯Œä¸”å¯¹AIè¯Šæ–­å’Œäººç±»åˆ†æéƒ½æå…¶å‹å¥½çš„JSONæ—¥å¿—æµï¼ŒåŒæ—¶å®Œå…¨æ²¡æœ‰æ”¹å˜åŸæœ‰çš„ä¸šåŠ¡é€»è¾‘ã€‚