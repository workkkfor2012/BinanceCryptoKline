# LLM友好型功能模块定义列表 (阶段一)

本文档包含了为高性能K线数据处理系统设计的核心功能模块定义。这些定义遵循面向LLM熟悉的业务模块、高内聚低耦合、数据流驱动边界以及LLM易于后续代码生成为目标。

## 模块清单

---

### 1. `MarketDataIngestor` (行情数据接入与解析模块)

*   **a. 模块名称：** `MarketDataIngestor` (行情数据接入与解析模块)
*   **b. 核心职责：** 负责通过WebSocket实时订阅、接收、解析币安的归集交易数据(aggTrade)，并管理网络连接、代理配置及自动重连机制。
*   **c. 主要输入：**
    *   交易品种列表 (需要订阅的品种名称清单，如 `["BTCUSDT", "ETHUSDT"]`)。
    *   API配置 (包含API端点URL、可能的API Key/Secret等认证信息)。
    *   代理配置 (可选，如SOCKS5代理的地址和端口)。
*   **d. 主要输出：**
    *   结构化的 `AggTradeData` 对象流 (每个对象代表一笔归集交易，包含品种、价格、数量、时间戳等标准信息)。
*   **e. 核心处理逻辑概述：**
    1.  **初始化连接**：根据提供的API配置和（可选的）代理配置，初始化并建立到指定行情数据源（例如币安）的WebSocket连接。
    2.  **订阅品种**：连接建立成功后，依据输入的交易品种列表，向数据源发送符合其协议规范的订阅指令，以接收这些品种的实时归集交易数据 (aggTrade)。
    3.  **持续接收与解析**：异步监听WebSocket消息，持续接收从数据源推送过来的原始交易数据流（通常为JSON格式）。
    4.  **数据转换**：将接收到的每一条原始交易数据准确地解析并转换为统一的、结构化的 `AggTradeData` 对象。
    5.  **连接管理与重连**：实时监控WebSocket连接的健康状态。在发生网络断开、连接错误或认证失败等问题时，自动执行预设的重连策略（例如，带退避算法的延时重试）并重新发送订阅指令。
    6.  **输出数据流**：将成功解析并转换的 `AggTradeData` 对象作为数据流向下游模块转发。

---

### 2. `TradeEventRouter` (交易事件路由模块)

*   **a. 模块名称：** `TradeEventRouter` (交易事件路由模块)
*   **b. 核心职责：** 接收结构化的 `AggTradeData` 交易事件，并根据其包含的交易品种信息，将其精确地分发到该品种专属的下游处理逻辑单元（如对应的 `SymbolKlineAggregator` 实例）。
*   **c. 主要输入：**
    *   单个 `AggTradeData` 对象 (来自 `MarketDataIngestor` 的输出流)。
*   **d. 主要输出：**
    *   （逻辑输出）将输入的 `AggTradeData` 对象转发给特定的下游处理单元。模块本身不直接产生新的数据结构作为主要输出，其输出体现为行为的触发和数据的定向传递。
*   **e. 核心处理逻辑概述：**
    1.  **接收事件**：从上游模块（如 `MarketDataIngestor`）接收一个 `AggTradeData` 对象。
    2.  **提取品种标识**：从该 `AggTradeData` 对象中提取出明确的交易品种标识符（例如，从对象的 `symbol` 字段获取 "BTCUSDT"）。
    3.  **查找目标单元**：根据提取出的交易品种标识符，查询预先配置或动态维护的路由规则（或映射表），找到该品种对应的下游处理单元实例（例如，负责处理 "BTCUSDT" K线聚合的 `SymbolKlineAggregator` 实例）。
    4.  **转发事件**：将原始的 `AggTradeData` 对象原封不动地、直接传递或发送给在步骤3中确定的目标处理单元。

---

### 3. `SymbolKlineAggregator` (单品种K线聚合模块)

*   **a. 模块名称：** `SymbolKlineAggregator` (单品种K线聚合模块)
*   **b. 核心职责：** 针对单一交易品种，接收该品种的实时归集交易数据 (`AggTradeData`)，依据预设的固定时间窗口聚合成多个周期的K线数据，并持续地将这些K线数据的最新状态（包括其是否已在该周期内最终形成的标志）推送给双缓冲K线存储模块。
*   **c. 主要输入：**
    *   特定交易品种的 `AggTradeData` 对象流 (由 `TradeEventRouter` 路由过来)。
    *   该交易品种的内部标识符 (`symbol_index`) (在初始化时由 `SymbolMetadataRegistry` 提供并缓存)。
    *   该交易品种需要聚合的K线周期配置列表 (例如 `['1m', '5m', '1h']`, 在初始化时配置)。
*   **d. 主要输出：**
    *   一个 `KlineData` 对象列表，代表本模块负责的单一品种下所有受监控周期的最新K线状态。每个 `KlineData` 对象包含OHLCV数据、精确的周期理论开始时间 (`open_time`)、以及一个明确指示该K线在本周期内是否已最终形成的布尔标志 (`is_final`)。此列表被发送给 `BufferedKlineStore` 模块的写入接口。
*   **e. 核心处理逻辑概述：**
    1.  **初始化**：对于分配给本聚合器的单一交易品种：
        a.  根据提供的K线周期配置（如1分钟、5分钟、1小时等），为每个周期在内部创建一个对应的K线聚合状态对象。该对象用于存储当前周期K线的OHLCV等数据，并包含一个 `is_final` 标志（初始为 `false`）。
        b.  缓存由 `SymbolMetadataRegistry` 提供的本品种的 `symbol_index`。
        c.  明确每个K线周期的固定时间窗口规则（例如，1分钟K线总是从每分钟的00秒000毫秒开始，到59秒999毫秒结束）。
    2.  **接收交易数据**：异步监听并接收专门路由到本品种的 `AggTradeData` 对象。
    3.  **累积更新K线状态**：对于每一条接收到的 `AggTradeData`（包含价格、成交量、成交时间 `T_agg`）：
        a.  遍历所有已配置的K线周期。
        b.  对于每个周期，判断 `T_agg` 是否落在该周期当前正在聚合的K线的预定时间窗口内。
        c.  如果是，则将该笔交易的价格和成交量信息累积更新到对应周期的内部K线聚合状态对象中：
            i.  如果这是该周期聚合的第一笔交易，则其价格为该周期的开盘价(O)。
            ii. 更新最高价(H)和最低价(L)。
            iii. 将该笔交易的价格作为当前的临时收盘价(C)。
            iv. 累加成交量(V)。
    4.  **判断K线周期在时间上结束**：
        a.  对于每个内部K线聚合状态对象，使用一个可靠的当前时间源（例如，经过服务器时间同步校准的本地系统时钟，或最新的 `AggTradeData` 时间戳所指示的行情时间），判断其预设的K线周期结束时间点是否已经过去。
    5.  **处理时间上已结束的K线**：如果一个周期的K线在步骤4中被判断为时间上已结束（并且其内部状态对象的 `is_final` 标志尚为 `false`）：
        a.  **固化数据**：
            i.  如果该周期内有聚合到交易数据，则其OHLCV值已在步骤3中更新；其最终收盘价(C)应为该周期内聚合的最后一笔有效交易的价格。其 `open_time` 为该K线周期的理论开始时间。
            ii. 如果该周期内没有任何交易数据被聚合（空K线），则根据预设业务规则处理其OHLCV值（例如，OHLC均沿用上一个已完成K线的收盘价，V为0；或所有值设为特定空值/null）。其 `open_time` 仍为理论开始时间。
        b.  **设置完成标志**：将该K线聚合状态对象的 `is_final` 标志设置为 `true`。
        c.  **准备新周期**：立即为该K线周期重置/创建一个新的内部聚合状态对象（`is_final` 标志为 `false`，OHLCV值重置），以开始聚合下一个时间窗口的数据。新对象的 `open_time` 为下一个周期的理论开始时间。
    6.  **输出最新K线状态**：将当前内部所有周期（无论是部分形成 `is_final=false` 还是刚刚在步骤5b中标记为完成 `is_final=true`）的K线聚合状态对象，转换为 `KlineData` 对象列表（每个对象均包含 `symbol_index`、对应的 `period_index`、理论 `open_time` 和 `is_final` 标志），并将其发送给 `BufferedKlineStore` 模块的写入接口。

---

### 4. `SymbolMetadataRegistry` (交易品种元数据注册模块)

*   **a. 模块名称：** `SymbolMetadataRegistry` (交易品种元数据注册模块)
*   **b. 核心职责：** 负责在系统启动时获取所有交易品种。通过查询各品种精确、唯一且不变的“首个1分钟K线时间”（此时间等同于其上市时间），并以此为唯一排序依据，为每个品种分配一个稳定且唯一的内部数字索引 (`symbol_index`)。管理品种名与索引间的映射关系，并根据预设的最大支持品种数和周期配置计算K线数据扁平化存储所需的总容量。
*   **c. 主要输入：**
    *   （隐式）系统启动信号。
    *   （配置）获取交易品种列表的数据源配置（例如API端点或本地配置文件路径）。
    *   （配置）每个品种统一支持的K线周期定义列表（例如 `['1m', '5m', '1h', '4h', '1d', '1w', '1M']`）或其数量。
    *   （配置）最大预期支持的交易品种数量（例如10000，用于预分配存储容量）。
    *   （依赖）数据库连接（或等效的数据源），用于查询各品种的“首个1分钟K线时间”（即其上市时间）。
*   **d. 主要输出：**
    *   对内提供查询接口：通过品种名（如 "BTCUSDT"）获取其对应的 `symbol_index` (整数)。
    *   对内提供查询接口：通过 `symbol_index` 获取其对应的品种名。
    *   对内提供查询接口：获取所有已注册的交易品种及其 `symbol_index` 的完整列表（通常按 `symbol_index` 排序）。
    *   对内提供查询接口：获取预计算出的、K线数据扁平化存储所需的总条目数 (`total_kline_slots`)。
*   **e. 核心处理逻辑概述：**
    1.  **获取当前品种列表**：系统启动时，从配置的数据源（例如，调用交易所API获取所有可交易的永续合约品种列表）获取当前所有活跃的交易品种的名称列表。
    2.  **查询品种上市时间（首个1分钟K线时间）**：对于步骤1中获取的每一个交易品种名称：
        a.  连接到指定的数据库（或数据源），查询该品种历史上记录的第一条1分钟K线的精确开盘时间戳。此时间戳被视为该品种的唯一且不变的“上市时间”。
        b.  **确保获取时间**：模块必须设计有健壮的机制来确保最终能够获取到所有API返回品种的“上市时间”。如果启动时因任何原因（如新品种数据同步到数据库有短暂延迟）暂时无法查询到某个品种的此时间，系统应具备合理的处理策略（例如，带超时和重试的等待机制，或者如果无法获取则记录错误并可能将该品种暂时排除在本次处理之外，同时发出警告）。`symbol_index` 的分配依赖于此时间的获得。
    3.  **排序并分配 `symbol_index`**：
        a.  为每个成功获取到“上市时间”的品种，创建一个包含 `(品种名, 上市时间)` 的记录。
        b.  根据每个品种的“上市时间”（即首个1分钟K线时间戳），对所有这些记录进行严格的**升序排序**。由于“上市时间”被认为是每个品种绝对唯一的，因此不设置次级排序规则。
        c.  根据这个由唯一上市时间严格决定的排序结果，为每个品种从0开始依次分配一个唯一的 `symbol_index` (0, 1, 2, ...)。
    4.  **构建双向查询结构**：基于步骤3c中生成的 `(品种名 -> symbol_index)` 映射，构建高效的内部数据结构（如哈希表），以便快速进行品种名到 `symbol_index` 的查询，以及 `symbol_index` 到品种名的反向查询。
    5.  **计算存储总容量**：根据配置中预设的“最大预期支持的交易品种数量”和“每个品种支持的K线周期数量”，计算出 `BufferedKlineStore` 初始化时所需的扁平化K线数据存储的总条目数。公式为：`total_kline_slots = max_supported_symbols * num_periods_per_symbol`。
    6.  **提供查询服务接口**：使模块能够响应来自系统内其他模块的、对品种名/`symbol_index`映射关系、所有已注册品种列表、以及计算出的存储总容量的查询请求。

---

### 5. `BufferedKlineStore` (自调度双缓冲K线存储模块)

*   **a. 模块名称：** `BufferedKlineStore` (自调度双缓冲K线存储模块)
*   **b. 核心职责：** 管理两份独立的、扁平化的K线数据内存存储区。通过双缓冲机制，实现对K线数据近乎无锁的并发写入（到写缓冲区）和读取（从读缓冲区）。内置一个定时调度器，该调度器按照预设的固定时间间隔，自动触发模块内部读写缓冲区的原子切换，从而确保读取操作总能访问到一个定期更新的一致性数据快照。在每次成功的缓冲区切换后，模块会发出通知。
*   **c. 主要输入：**
    *   `symbol_index` (整数类型)：用于定位特定交易品种在扁平化存储中的区域。由调用方（如 `SymbolKlineAggregator`）提供。
    *   `period_index` (整数类型)：用于定位特定品种下特定K线周期在扁平化存储中的具体条目。由调用方（如 `SymbolKlineAggregator`）提供。
    *   `KlineData` 对象 (数据结构)：包含OHLCV、精确的理论 `open_time`、`is_final`状态等纯K线行情信息（不含其在存储中的索引信息），用于写入到写缓冲区。
    *   （配置，初始化时）缓冲区切换的时间间隔（例如，指定为毫秒数，如100ms或1000ms）。
    *   （依赖，初始化时）来自 `SymbolMetadataRegistry` 模块的K线数据扁平化存储区所需的总条目数 (`total_kline_slots`)。
    *   （依赖，初始化时，可选）系统内每个品种支持的K线周期总数 (`num_periods_per_symbol`)，用于内部索引计算（也可从`SymbolMetadataRegistry`查询或作为全局配置）。
*   **d. 主要输出：**
    *   `KlineData` 对象 (数据结构)：作为读取请求的响应，从当前读缓冲区安全地复制（或克隆）得到，包含完整的K线信息。
    *   “新K线快照就绪”事件/信号：在模块内部调度的缓冲区切换成功完成原子操作后，由本模块发出，用于通知系统中其他对此感兴趣的模块（如 `RealtimeKlineNotifier` 或 `KlineDataPersistence` 的触发机制，如果KDP不采用独立定时器）。
*   **e. 核心处理逻辑概述：**
    1.  **初始化**：
        a.  启动时，从 `SymbolMetadataRegistry` 模块查询并获取K线数据扁平化存储区所需的总条目数 (`total_kline_slots`)。
        b.  （可选）获取并缓存 `num_periods_per_symbol` 用于后续的索引计算。
        c.  根据配置读取缓冲区切换的固定时间间隔。
        d.  创建并初始化两个结构相同、大小均为 `total_kline_slots` 的独立扁平化K线数据存储区（例如，在Rust中可能是 `Vec<KlineData>`，内部可称为缓冲区A和缓冲区B）。所有条目用表示“无数据”或“未初始化”的默认 `KlineData` 值填充。
        e.  在模块内部维护状态，原子地或安全地指定其中一个缓冲区为当前的“写缓冲区”，另一个为当前的“读缓冲区”（例如，通过内部指针或索引）。
        f.  **启动内部定时调度器**：初始化并启动一个模块内部的、高精度的定时器（或调度机制）。配置该定时器严格按照步骤1c中获取的时间间隔周期性地触发模块自身的“执行缓冲区切换”逻辑（见步骤4）。
    2.  **K线数据写入 (Write Operation)**：
        a.  提供一个公共接口，接收 `symbol_index`, `period_index`, 以及一个待写入的 `KlineData` 对象作为输入。
        b.  根据传入的 `symbol_index`, `period_index` 以及缓存的 `num_periods_per_symbol`，计算出该 `KlineData` 在扁平化存储区中的一维目标索引位置。准确的计算公式为：`flat_index = symbol_index * num_periods_per_symbol + period_index`。
        c.  将传入的 `KlineData` 对象的内容安全地（例如，通过值复制或原子操作，取决于 `KlineData` 的大小和复杂度）更新到**当前指定的“写缓冲区”**的计算出的目标索引位置。此操作应设计为对并发的读取操作无阻塞或影响极小。
    3.  **K线数据读取 (Read Operation)**：
        a.  提供一个公共接口，接收 `symbol_index` 和 `period_index` 作为查询参数。
        b.  与写入操作类似，根据输入参数和 `num_periods_per_symbol`，计算出一维目标索引位置。
        c.  从**当前指定的“读缓冲区”**的计算出的目标索引位置安全地复制（或克隆，确保返回的是一份独立的数据副本）一份 `KlineData` 对象，并将其作为结果返回。如果对应位置无有效数据（例如，尚未被写入），则返回空或错误指示。
    4.  **内部调度与执行缓冲区切换 (Scheduled Swap Logic)**：
        a.  当模块内部的定时器（在步骤1f中启动）到期触发时，自动执行以下操作：
            i.  以原子方式（例如，通过交换内部对缓冲区的引用/指针，或使用轻量级同步原语如 `AtomicPtr` 或 `Mutex` 保护极短的临界区）将“写缓冲区”和“读缓冲区”的角色互换。
            ii. 在原子切换成功完成后，本模块 (`BufferedKlineStore`) 立即向系统中发出一个标准化的“新K线快照就绪”的通知或事件，供其他模块订阅。

---

### 6. `KlineDataPersistence` (K线数据持久化模块)

*   **a. 模块名称：** `KlineDataPersistence` (K线数据持久化模块)
*   **b. 核心职责：** 定期从 `BufferedKlineStore` 获取当前所有K线数据的快照。每条K线数据都应包含其精确的、由所属K线周期规则定义的理论开盘时间 (`open_time`)。本模块负责将这些K线数据通过UPSERT（Update or Insert）操作异步地、批量地持久化到外部数据库，确保数据库中每个特定时间周期（由品种、周期类型、及理论开盘时间唯一确定）的K线记录能够准确反映其最新状态（包括是否最终形成）。
*   **c. 主要输入：**
    *   （配置）数据库连接参数 (如连接字符串、用户名、密码、数据库名、连接池大小等)。
    *   （配置）持久化操作的定时周期 (例如，指定为5秒)。
    *   （依赖，初始化时）获取对 `BufferedKlineStore` 模块实例的引用或句柄，以便调用其批量读取K线快照的接口。
    *   （依赖，初始化时，可选）获取对 `SymbolMetadataRegistry` 模块实例的引用，用于在需要时将 `symbol_index` 和 `period_index` 转换为数据库存储可能使用的 `symbol_name` 和周期字符串 (如果数据库不直接存储数字索引)。
*   **d. 主要输出：**
    *   （主要副作用）K线数据被写入或更新到配置的外部数据库中。
    *   （次要副作用）持久化操作的执行状态（如成功条目数、失败信息、耗时）、性能指标或遇到的任何错误被记录到系统日志或发送到监控系统。
*   **e. 核心处理逻辑概述：**
    1.  **初始化**：
        a.  根据提供的数据库连接配置参数，建立并维护一个到目标外部数据库的连接池或稳定的连接。
        b.  获取并存储对 `BufferedKlineStore` 模块实例的引用。
        c.  （可选）如果需要名称/周期转换，获取并存储对 `SymbolMetadataRegistry` 模块实例的引用。
        d.  从配置中读取并存储持久化操作的固定定时周期。
        e.  启动一个模块内部的定时器（或调度机制），该定时器严格按照配置的周期触发后续的持久化处理流程。
    2.  **定时执行持久化流程**：
        a.  当内部定时器到期触发时，执行以下步骤：
            i.  **获取K线快照**：调用 `BufferedKlineStore` 模块提供的批量读取接口（例如 `get_read_buffer_snapshot()`），以获取其当前“读缓冲区”中所有K线数据的一个完整、一致的快照。此快照预期为一个数据集合（如列表），其中每个元素应包含：
                *   用于数据库定位的上下文信息：`symbol_index` 和 `period_index`。
                *   `KlineData` 对象本身，此对象**必须包含一个精确的、由K线周期规则定义的理论开盘时间字段 (`open_time`)**，以及OHLCV值和 `is_final` 标志。
            ii. **准备UPSERT操作**：遍历从BKS获取到的K线数据集合。对于集合中的每一条K线实例（由其`symbol_index`, `period_index` 和 `KlineData` 对象共同定义）：
                1.  **获取标识符**：如果数据库使用名称而非索引，则调用 `SymbolMetadataRegistry` 将 `symbol_index` 转换为 `symbol_name`，并将 `period_index` 转换为对应的周期字符串（如 "1m"）。否则直接使用索引。
                2.  构造一个针对数据库中K线存储表的UPSERT操作。此操作的目标是数据库中由复合唯一键 `(symbol_identifier, period_identifier, kline.open_time)` 所唯一确定的那一行记录（其中 `kline.open_time` 直接从 `KlineData` 对象中获取）。
                3.  将当前K线实例的OHLCV值、`is_final` 标志，以及其他需要持久化的相关属性，作为此UPSERT操作的待写入或待更新的数据。
                4.  将生成的这些UPSERT操作收集起来（例如，放入一个列表），为下一步的批量提交做准备。
            iii. **异步批量提交**：将收集到的所有UPSERT操作，根据预设的批量大小（例如，每1000条K线一批）和事务策略（例如，每批操作在一个事务中，或所有操作在一个大事务中，取决于数据库性能和数据一致性要求），异步地提交给数据库执行。
            iv. **结果处理与日志记录**：监控异步提交的结果。操作完成后（无论成功或失败），将本次持久化任务的执行摘要（如成功处理的K线数量、遇到的错误详情、总体耗时等）记录到系统日志，并可能将关键性能指标发送到监控系统。妥善处理数据库交互过程中可能发生的任何异常或错误（例如，连接丢失、写入冲突等），并考虑重试逻辑（如果适用）。

---

文档已生成。请您审阅。这份文档是我们协作的成果，希望能为后续的LLM代码生成提供清晰、准确的指导。