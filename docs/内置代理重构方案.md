好的，没问题。

根据我们所有的讨论，从最初的手动循环方案，到对 shadowsocks-rust 库功能的深入挖掘，我们已经得出了一个既能满足你“严格轮询”需求，又在代码上更简洁、更健壮的最终方案。

我将为你输出一份完整的、可以替代原始文件的重构方案文档。

docs\内置代理重构方案.md (最终版)
概述

本项目旨在实现一个内置的Socks5代理服务。该服务能自动从指定的URL下载Clash配置文件，解析出所有可用的Shadowsocks (SS) 节点，并以严格轮询 (Round-Robin) 的负载均衡策略对外提供代理服务。

此方案的核心目的是为了突破单一IP的并发限制，通过将并发请求（如批量下载K线数据）均匀地分发到所有可用的代理节点IP上，实现高效的数据获取。

经过研究与确认，本方案将采用 shadowsocks-rust 库内建的负载均衡功能，通过配置其策略为 RoundRobin 来实现目标，从而取代了最初手动管理TCP连接和轮询索引的方案。

核心优势

代码简洁: 无需手动编写 TcpListener 循环和线程安全的索引计数器，所有底层连接管理和分发逻辑都交由 shadowsocks-rust 库处理，代码意图更清晰。

健壮可靠: 使用库的原生实现比手动实现更可靠，它能更好地处理节点连接失败、超时等边缘情况。

高性能: shadowsocks-rust 是一个为高性能而设计的库，其内部的异步事件处理和调度机制经过了充分优化。

项目设置

请确保 Cargo.toml 文件中包含以下主要依赖。建议使用最新版本以获得最好的功能支持。

Generated toml
[dependencies]
shadowsocks-rust = "1.18.1" # 请检查并使用最新版本
tokio = { version = "1", features = ["full"] }
reqwest = "0.11"
serde = { version = "1.0", features = ["derive"] }
serde_yaml = "0.9"
log = "0.4"
env_logger = "0.10"

完整 Rust 代码

以下是完整的 src/main.rs 文件代码。

Generated rust
use std::str::FromStr;
use std::sync::Arc;
use log::{info, error, warn};
use reqwest::Error as ReqwestError;
use serde::Deserialize;
use shadowsocks_rust::{
    config::{Config, ConfigType, ServerConfig, LocalConfig, BalancerConfig, BalancerStrategy},
    crypto::CipherType,
    plugin::PluginConfig,
    run_local,
};

// 1. 定义与Clash配置文件匹配的结构体
#[derive(Debug, Deserialize)]
struct ClashConfig {
    proxies: Vec<Proxy>,
}

#[derive(Debug, Deserialize, Clone)]
struct Proxy {
    name: String,
    server: String,
    port: u16,
    #[serde(rename = "type")]
    proxy_type: String,
    cipher: String,
    password: String,
    udp: Option<bool>,
    plugin: Option<String>,
    #[serde(rename = "plugin-opts")]
    plugin_opts: Option<PluginOpts>,
}

#[derive(Debug, Deserialize, Clone)]
struct PluginOpts {
    mode: String,
    host: String,
}

// 2. 从 URL 异步下载配置文件
async fn download_config(url: &str) -> Result<String, ReqwestError> {
    info!("正在从 {} 下载配置文件...", url);
    let response = reqwest::get(url).await?.text().await?;
    info!("配置文件下载成功。");
    Ok(response)
}

// 3. 将 Clash 的 Proxy 结构转换为 shadowsocks-rust 的 ServerConfig
fn convert_proxy_to_server_config(proxy: &Proxy) -> Option<ServerConfig> {
    // 只处理 "ss" 类型的代理
    if proxy.proxy_type != "ss" {
        return None;
    }

    // 使用 from_str 动态解析加密方式，更具扩展性
    let cipher_type = match CipherType::from_str(&proxy.cipher) {
        Ok(c) => c,
        Err(_) => {
            warn!("跳过不支持或无法识别的加密方式: {}", proxy.cipher);
            return None;
        }
    };

    let plugin = if let (Some(plugin_name), Some(plugin_opts)) = (&proxy.plugin, &proxy.plugin_opts) {
        Some(PluginConfig {
            plugin: plugin_name.clone(),
            plugin_opts: Some(format!("mode={};host={}", plugin_opts.mode, plugin_opts.host)),
            plugin_args: Vec::new(),
        })
    } else {
        None
    };

    Some(ServerConfig::new(
        (proxy.server.as_str(), proxy.port).into(),
        proxy.password.clone(),
        cipher_type,
        None, // 超时，使用默认值
        plugin,
    ))
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    env_logger::init();

    // 替换为你的Clash订阅链接
    let config_url = "https://api-huacloud.dev/sub?target=clash&insert=true&emoji=true&udp=true&clash.doh=true&new_name=true&filename=Flower_SS&url=https%3A%2F%2Fapi.xmancdn.com%2Fosubscribe.php%3Fsid%3D170048%26token%3Dq5Euf9hXDxgH%26sip002%3D1";

    // 下载并解析配置
    let yaml_str = match download_config(config_url).await {
        Ok(s) => s,
        Err(e) => {
            error!("下载配置文件失败: {}", e);
            return Err(e.into());
        }
    };

    let clash_config: ClashConfig = match serde_yaml::from_str(&yaml_str) {
        Ok(c) => c,
        Err(e) => {
            error!("解析 YAML 配置文件失败: {}", e);
            return Err(e.into());
        }
    };

    // 转换代理配置
    let server_configs: Vec<ServerConfig> = clash_config
        .proxies
        .iter()
        .filter_map(convert_proxy_to_server_config)
        .collect();

    if server_configs.is_empty() {
        error!("没有找到可用的 Shadowsocks 代理节点。");
        return Ok(());
    }

    info!("成功解析并转换了 {} 个 Shadowsocks 代理节点。", server_configs.len());

    // --- 使用库原生功能配置并启动服务 ---

    // 1. 定义本地Socks5代理的监听地址
    let local_addr = "127.0.0.1:78900".parse()?;
    let local_config = LocalConfig::new(local_addr, None);

    // 2. 创建负载均衡配置，并明确指定策略为 RoundRobin
    let balancer_config = BalancerConfig::new(BalancerStrategy::RoundRobin);

    // 3. 创建包含所有配置的主 Config 对象
    let mut config = Config::new(ConfigType::Local);
    config.local = vec![local_config];
    config.server = server_configs;
    config.balancer = Some(balancer_config); // 应用轮询策略

    info!(
        "启动内置代理服务，监听于 {}，将对 {} 个节点进行严格轮询。",
        local_addr,
        config.server.len()
    );

    // 4. 启动服务，函数将接管并运行代理逻辑
    if let Err(err) = run_local(config).await {
        error!("代理服务运行时出错: {}", err);
        return Err(err.into());
    }

    Ok(())
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Rust
IGNORE_WHEN_COPYING_END
代码解析

数据结构 (ClashConfig, Proxy, etc.): 使用 serde 定义了与 Clash YAML 配置中 proxies 字段相匹配的 Rust 结构体，用于自动反序列化。

download_config 函数: 使用 reqwest 库异步下载配置文件文本。

convert_proxy_to_server_config 函数:

这是一个辅助函数，负责将从Clash配置中解析出的 Proxy 对象转换为 shadowsocks-rust 库能理解的 ServerConfig 对象。

重要改进：使用 CipherType::from_str(&proxy.cipher) 来动态解析加密方法字符串。这比硬编码的 match 语句更灵活，只要是 shadowsocks-rust 库支持的加密方式，我们的代码无需修改即可兼容。

main 函数:

启动与解析: 和原方案一样，程序首先初始化日志，然后下载、解析YAML配置文件，并调用 convert_proxy_to_server_config 将所有合法的SS节点转换为 Vec<ServerConfig>。

配置服务 (核心):

我们不再手动创建TCP监听器。

LocalConfig::new(...) 创建一个本地代理的配置，指定了Socks5服务监听的IP和端口。

BalancerConfig::new(BalancerStrategy::RoundRobin) 是关键，我们在这里明确告诉 shadowsocks-rust 我们想要的负载均衡策略是轮询。

最后，将 local_config（监听配置）、server_configs（所有远程节点）和 balancer_config（策略配置）全部装入一个顶层的 Config 对象。

启动服务:

只需调用一次 run_local(config).await。

这个函数会启动完整的本地代理服务，包括监听端口、接受新连接、根据我们配置的轮询策略选择节点、并转发数据。它会一直运行，直到程序被终止。整个复杂的并发管理都由库在内部高效地完成了。

如何运行

将代码保存为 src/main.rs。

在项目根目录下运行 cargo build --release 进行编译。

通过以下命令启动服务：

Generated bash
# 使用 RUST_LOG=info 可以看到详细的日志输出
RUST_LOG=info ./target/release/your_program_name
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Bash
IGNORE_WHEN_COPYING_END

程序启动后，你就可以将需要分发请求的应用程序的代理设置为 socks5://127.0.0.1:78900。每一个新的TCP连接都将被依次分配到配置文件中的下一个节点，从而实现了你的需求。