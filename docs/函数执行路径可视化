

函数执行路径实时可视化前端：技术设计与实现方案
一、 核心目标

构建一个单页面Web应用，通过WebSocket实时接收后端发送的函数调用追踪事件，并将其动态渲染为可交互的调用树和时间轴（甘特图），以实现对程序执行路径的深度分析和性能瓶颈定位。

二、 数据契约 (Data Contract)

前端的生命线是后端通过WebSocket推送的结构化JSON事件。必须严格遵守以下三种事件格式：

span_start (函数调用开始)

Generated json
{
  "type": "span_start",
  "timestamp": "YYYY-MM-DDTHH:mm:ss.sssZ",
  "trace_id": "string",
  "span_id": "string",
  "parent_id": "string" | null,
  "name": "string (函数名)",
  "target": "string (模块/结构体名)"
}


span_end (函数调用结束)

Generated json
{
  "type": "span_end",
  "timestamp": "YYYY-MM-DDTHH:mm:ss.sssZ",
  "trace_id": "string",
  "span_id": "string",
  "duration_ms": number
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Json
IGNORE_WHEN_COPYING_END

log (错误标记)

Generated json
{
  "type": "log",
  "timestamp": "YYYY-MM-DDTHH:mm:ss.sssZ",
  "trace_id": "string",
  "span_id": "string",
  "level": "ERROR",
  "message": "string"
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Json
IGNORE_WHEN_COPYING_END
三、 前端架构与模块设计

应用遵循模块化的**“数据处理 -> 状态管理 -> 渲染”**架构。

WebSocketConnector (连接器): 唯一的职责是建立并维持与 ws://localhost:3001/ws 的连接。它处理连接、断开、重连逻辑，并将收到的原始消息分发给AppController。

AppController (总控制器): 应用的主入口和协调者。

接收来自WebSocketConnector的原始事件。

将事件交给TraceParser处理。

管理UI交互，如暂停/继续、清空、过滤条件变更。

调用Renderer模块来更新视图。

TraceParser (数据解析器): 一个无状态的纯逻辑模块。

接收一个原始事件和当前的TraceStore状态。

根据事件类型（span_start, span_end, log）对TraceStore中的数据进行原子性更新。例如，收到span_start时，它会在对应的Trace对象中创建一个新的Span，并根据parent_id建立父子关系。

TraceStore (状态存储): 应用的单一事实来源（Single Source of Truth）。

其核心是一个以trace_id为键的JavaScript对象，存储所有追踪会话。

每个Trace对象内部，又以span_id为键存储一个扁平化的Span列表，并通过children数组和parentId字段维护树形结构。

提供查询接口，如getTrace(id)、getActiveTrace()、getFilteredTraceSummaries()。

数据结构定义:

Trace Object: { id, rootSpanIds, spans: { spanId: SpanObject }, startTime, duration, hasError, status }

Span Object: { id, traceId, parentId, children: [SpanObject], logs: [LogObject], name, target, startTime, duration, hasError, status }

Renderer (渲染引擎): 负责将TraceStore中的状态可视化为DOM。

TraceListRenderer: 渲染左侧的追踪列表。它只消费TraceStore提供的摘要信息（根函数名、耗时、错误状态）。为避免性能问题，此列表必须使用虚拟滚动技术，只渲染视口内的条目。

TraceDetailRenderer: 渲染右侧的详情面板，包含两种视图模式：

树状视图 (Tree View): 通过递归函数构建。每个Span被渲染成一个DOM节点，其子Span被渲染到该节点的子容器中。使用CSS的margin-left和border-left创建缩进和连接线视觉效果。节点支持点击展开/折叠。

时间轴视图 (Timeline/Gantt View):

计算出整个Trace的开始时间T_start和总时长T_total。

对于每个Span，其在时间轴上的位置和宽度由以下公式决定：

left = (span.startTime - T_start) / T_total * 100%

width = span.duration / T_total * 100%

使用CSS绝对定位将每个Span渲染成一个条形块。不同target的Span使用不同颜色编码。包含错误的Span用红色边框高亮。

四、 核心功能与交互逻辑

实时更新: 应用启动后自动连接WebSocket。每当新事件到达且应用不处于“暂停”状态时，AppController驱动数据解析和UI增量更新。

主交互流程:

用户在左侧追踪列表中看到实时滚动的执行路径摘要。

点击任意摘要项，该Trace被设为“活动Trace”，右侧详情面板立即渲染其调用树视图。

详情面板提供一个切换按钮，允许用户在调用树视图和时间轴视图之间切换。

用户控制:

暂停/继续: 一个全局按钮，可以冻结UI更新，以便用户仔细分析当前屏幕上的内容。后台数据接收和处理可继续，或一并暂停。

清空: 清除TraceStore中的所有数据和屏幕上的所有DOM，重置视图。

过滤与搜索:

提供一个输入框，实时过滤左侧追踪列表和右侧详情视图。

过滤逻辑在TraceStore中实现，可根据函数名(name)、模块名(target)进行匹配。

提供复选框或滑块，按耗时阈值过滤，隐藏执行时间过短的“噪音”Span。

性能保障:

虚拟滚动: 左侧列表和右侧调用树的渲染必须采用虚拟滚动，这是保证应用在处理成千上万条Trace或超深调用栈时保持流畅的关键。

事件节流 (Debouncing/Throttling): 对高频的UI更新（如响应搜索框输入），使用debounce技术，避免在用户快速输入时进行不必要的重复渲染。

增量DOM更新: 渲染更新时，应尽可能只修改变动的部分，而不是完全重绘整个视图。

五、 最终交付物

一个trace_viewer.html文件，它引入一个打包好的JavaScript文件 (main.bundle.js) 和一个CSS文件 (trace_viewer.css)。用户在浏览器中打开此HTML文件，即可启动一个功能完整、高性能的实时函数执行路径可视化工具。