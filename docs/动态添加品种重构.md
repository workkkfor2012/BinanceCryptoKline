

最终方案：基于动态移位的动态品种管理
1. 核心设计原则

本方案旨在实现动态添加和删除交易品种的功能。其核心设计遵循以下原则：

索引的紧凑性：系统的核心数据结构（如KlineAggregator内的扁平数组）应保持数据紧凑，不留空洞。

动态移位：当一个品种被删除时，其后所有品种的数据及索引将前移一位，以填补空缺。

全局同步：索引的变更必须准确、完整地同步到系统中所有依赖索引的模块。KlineAggregator 作为变更的发起者，调用方负责执行全局状态的更新。

添加在末尾：新品种总是被添加到当前数据结构的末尾，其索引为当前的品种总数。

2. KlineAggregator 内部状态与命令定义

文件路径: src/klagg_sub_threads/mod.rs

命令接口需要支持基于品种符号 (String) 的添加和删除操作，并通过 ack 通道返回操作结果。

Generated rust
// In src/klagg_sub_threads/mod.rs

#[derive(Debug)]
pub enum WorkerCmd {
    /// 添加新品种到系统末尾
    AddSymbol {
        symbol: String,
        initial_data: InitialKlineData,
        first_kline_open_time: i64,
        /// ack 返回分配好的新索引
        ack: oneshot::Sender<std::result::Result<usize, String>>,
    },
    /// 根据品种名移除品种，并返回其被删除前的索引以及所有受影响品种的新索引
    RemoveSymbol {
        symbol: String,
        /// ack 返回一个元组: (被删除品种的旧索引, 所有索引变更的列表)
        ack: oneshot::Sender<std::result::Result<(usize, Vec<(String, usize)>), String>>,
    }
}

#[derive(Debug)]
pub enum WsCmd {
    /// 订阅新品种的 WebSocket 数据流
    Subscribe(Vec<String>),
    /// 取消订阅已删除品种的 WebSocket 数据流
    Unsubscribe(Vec<String>),
}


结构体本身不需要大的改动，但需要增加一个反向查找表 global_index_to_symbol_cache，以便在删除后能构建变更集。

Generated rust
// In src/klagg_sub_threads/mod.rs

pub struct KlineAggregator {
    periods: Arc<Vec<String>>,
    kline_expirations: Vec<i64>,
    kline_states: Vec<KlineState>,
    dirty_flags: Vec<bool>,
    dirty_indices: Vec<usize>,

    /// [修改] 全量热路径缓存 (symbol -> global_index)
    local_symbol_cache: HashMap<String, usize>,
    /// [新增] 内部反向缓存 (global_index -> symbol)，用于构建 RemoveSymbol 的 ack 响应
    global_index_to_symbol_cache: Vec<String>,

    managed_symbols_count: usize, // 该字段现在代表当前活跃的品种数量
    cmd_rx: Option<mpsc::Receiver<WorkerCmd>>,
    // ... 其他字段保持不变
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Rust
IGNORE_WHEN_COPYING_END
3. KlineAggregator 核心逻辑实现

文件路径: src/klagg_sub_threads/mod.rs

在初始化时，需要填充 global_index_to_symbol_cache。

Generated rust
// In src/klagg_sub_threads/mod.rs -> KlineAggregator::new

// ...
let mut local_symbol_cache = HashMap::with_capacity(assigned_symbols.len());
// [新增] 初始化反向缓存
let mut global_index_to_symbol_cache = vec![String::new(); assigned_symbols.len()];

let guard = symbol_to_global_index.read().await;
for symbol in assigned_symbols {
    if let Some(&global_index) = guard.get(symbol) {
        local_symbol_cache.insert(symbol.clone(), global_index);
        // [新增] 填充反向缓存
        if global_index < global_index_to_symbol_cache.len() {
            global_index_to_symbol_cache[global_index] = symbol.clone();
        }
        // ... (后续的 K线状态填充逻辑不变)
    }
}

let aggregator = Self {
    // ...
    local_symbol_cache,
    global_index_to_symbol_cache, // [新增]
    managed_symbols_count: assigned_symbols.len(),
    // ...
};
// ...
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Rust
IGNORE_WHEN_COPYING_END

这是方案的核心，AddSymbol 在末尾添加，RemoveSymbol 执行数据前移。

Generated rust
// In src/klagg_sub_threads/mod.rs -> KlineAggregator::process_command

async fn process_command(&mut self, cmd: WorkerCmd) {
    match cmd {
        // --- 添加逻辑 ---
        WorkerCmd::AddSymbol { symbol, initial_data, first_kline_open_time, ack } => {
            // 1. 检查是否已存在
            if self.local_symbol_cache.contains_key(&symbol) {
                let _ = ack.send(Err(format!("Symbol '{}' already exists.", symbol)));
                return;
            }

            // 2. 计算新索引，总是在末尾添加
            let new_global_index = self.managed_symbols_count;
            let max_capacity = self.kline_states.len() / self.periods.len();
            if new_global_index >= max_capacity {
                error!(target: "计算核心", %symbol, new_global_index, max_capacity, "超出预分配容量！");
                let _ = ack.send(Err("Exceeded pre-allocated capacity".to_string()));
                return;
            }

            // 3. 更新内部状态
            self.local_symbol_cache.insert(symbol.clone(), new_global_index);
            self.global_index_to_symbol_cache.push(symbol.clone());
            self.managed_symbols_count += 1;

            // 4. 初始化新槽位的K线数据 (这部分逻辑与之前类似，使用 new_global_index)
            // ... (省略创建创世K线和播种长周期K线的详细代码) ...

            // 5. 发送订阅命令
            if self.ws_cmd_tx.send(WsCmd::Subscribe(vec![symbol.clone()])).await.is_err() {
                warn!(target: "计算核心", %symbol, "向I/O任务发送订阅命令失败");
            }
            
            // 6. 确认成功，返回新索引
            let _ = ack.send(Ok(new_global_index));
        }

        // --- 删除逻辑 ---
        WorkerCmd::RemoveSymbol { symbol, ack } => {
            // 1. 查找要删除的品种及其索引
            let removed_index = match self.local_symbol_cache.get(&symbol) {
                Some(&idx) => idx,
                None => {
                    let _ = ack.send(Err(format!("Symbol '{}' not found.", symbol)));
                    return;
                }
            };
            
            info!(target: "计算核心", %symbol, removed_index, "开始移除品种并前移数据...");
            let num_periods = self.periods.len();
            
            // 2. 执行数据前移 (memmove)
            let move_start_index = (removed_index + 1) * num_periods;
            let move_count = (self.managed_symbols_count - 1 - removed_index) * num_periods;

            if move_count > 0 {
                // `copy_within` 是安全的，因为它能处理重叠的内存区域
                self.kline_states.copy_within(move_start_index.., removed_index * num_periods);
                self.kline_expirations.copy_within(move_start_index.., removed_index * num_periods);
                self.dirty_flags.copy_within(move_start_index.., removed_index * num_periods);
            }
            
            // 3. 截断数组末尾的陈旧数据
            let new_len = (self.managed_symbols_count - 1) * num_periods;
            self.kline_states.truncate(new_len);
            self.kline_expirations.truncate(new_len);
            self.dirty_flags.truncate(new_len);

            // 4. 更新内部的 `managed_symbols_count`
            self.managed_symbols_count -= 1;

            // 5. 重建内部缓存和构建变更集
            self.local_symbol_cache.remove(&symbol);
            self.global_index_to_symbol_cache.remove(removed_index);
            
            let mut index_changes = Vec::new();
            // 从被删除的位置开始，更新后面所有元素的索引
            for i in removed_index..self.managed_symbols_count {
                let sym_to_update = &self.global_index_to_symbol_cache[i];
                if let Some(entry) = self.local_symbol_cache.get_mut(sym_to_update) {
                    *entry = i;
                    index_changes.push((sym_to_update.clone(), i));
                }
            }
            
            // 6. 特别处理脏索引列表 (dirty_indices)
            // 这是一个复杂但必须的步骤：所有在 `removed_index` 之后的脏索引都需要 `-num_periods`
            self.dirty_indices.retain_mut(|dirty_idx| {
                let symbol_idx = *dirty_idx / num_periods;
                if symbol_idx < removed_index {
                    true // 保留不变
                } else if symbol_idx == removed_index {
                    false // 移除属于被删除品种的脏标记
                } else { // symbol_idx > removed_index
                    *dirty_idx -= num_periods; // 前移
                    true
                }
            });
            
            // 7. 发送取消订阅命令
            if self.ws_cmd_tx.send(WsCmd::Unsubscribe(vec![symbol.clone()])).await.is_err() {
                warn!(target: "计算核心", %symbol, "向I/O任务发送取消订阅命令失败");
            }

            // 8. 确认成功，返回被删除的索引和变更集
            info!(target: "计算核心", %symbol, "品种移除完成，通知调用方更新全局索引");
            let _ = ack.send(Ok((removed_index, index_changes)));
        }
    }
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Rust
IGNORE_WHEN_COPYING_END
4. I/O 层逻辑

文件路径: src/klcommon/websocket.rs

I/O 层的 AggTradeClient 需要能够处理 Subscribe 和 Unsubscribe 命令。这部分逻辑在你的文件中已经存在并且是正确的，这里仅作确认和展示。

Generated rust
// In src/klcommon/websocket.rs -> AggTradeClient's loop

// 确认 WsCommand 枚举包含 Unsubscribe
#[derive(Debug, Clone)]
pub enum WsCommand {
    Subscribe(Vec<String>),
    Unsubscribe(Vec<String>),
}

// 确认在 select! 循环中可以处理 WsCommand::Unsubscribe
WsCommand::Unsubscribe(remove_symbols) => {
    info!(target: AGG_TRADE_TARGET, "连接 {} 收到动态取消订阅: {:?}", connection_id, remove_symbols);
    let remove_streams: Vec<String> = remove_symbols.iter()
        .map(|s| format!("{}@aggTrade", s.to_lowercase()))
        .collect();

    let unsub_msg = serde_json::json!({
        "method": "UNSUBSCRIBE",
        "params": &remove_streams,
        "id": chrono::Utc::now().timestamp_millis()
    }).to_string();

    if let Err(e) = ws.write_frame(Frame::text(unsub_msg.into_bytes().into())).await {
        error!(target: AGG_TRADE_TARGET, "发送动态取消订阅失败: {}", e);
        break 'message_loop;
    }

    current_streams.retain(|s| !remove_streams.contains(s));
    
    // ... (更新 connections 状态) ...
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Rust
IGNORE_WHEN_COPYING_END
5. 调用方逻辑 (测试管理器)

文件路径: src/bin/klagg_visual_test.rs

调用方 run_test_symbol_manager 的逻辑现在变得至关重要，它负责接收变更集并执行全局状态的同步。

Generated rust
// In src/bin/klagg_visual_test.rs

async fn run_test_symbol_manager(
    symbol_to_global_index: Arc<RwLock<HashMap<String, usize>>>,
    global_index_to_symbol: Arc<RwLock<Vec<String>>>,
    global_symbol_count: Arc<AtomicUsize>, // 这个原子计数器现在是品种数量的权威
    cmd_tx: mpsc::Sender<WorkerCmd>,
) -> Result<()> {
    // ... (变量定义, 包括 added_symbols: Vec<String>) ...

    loop {
        tokio::select! {
            // --- 添加逻辑 ---
            _ = add_interval.tick() => {
                // ... (与上一版方案类似，构造 AddSymbol 命令) ...
                let cmd = WorkerCmd::AddSymbol {
                    symbol: symbol_to_add.clone(),
                    // ... (其他字段)
                };

                // ... (发送 cmd) ...

                match ack_rx.await {
                    Ok(Ok(new_index)) => {
                        let mut write_map = symbol_to_global_index.write().await;
                        let mut write_vec = global_index_to_symbol.write().await;
                        
                        // 确认新索引与长度匹配
                        if new_index == write_vec.len() {
                            write_map.insert(symbol_to_add.clone(), new_index);
                            write_vec.push(symbol_to_add.clone());
                            global_symbol_count.store(write_vec.len(), Ordering::SeqCst);
                            
                            added_symbols.push(symbol_to_add.clone());
                            info!(target: "品种管理器", symbol = %symbol_to_add, new_index, "成功添加品种，全局视图已更新");
                        } else {
                            error!(target: "品种管理器", "添加品种返回的索引 {} 与预期 {} 不符！", new_index, write_vec.len());
                        }
                    }
                    // ... (错误处理) ...
                }
            },

            // --- 删除逻辑 ---
            _ = remove_interval.tick() => {
                if let Some(symbol_to_remove) = added_symbols.pop() {
                     info!(target: "品种管理器", symbol = %symbol_to_remove, "发起删除品种指令...");
                     
                     let (ack_tx, ack_rx) = oneshot::channel();
                     let cmd = WorkerCmd::RemoveSymbol {
                         symbol: symbol_to_remove.clone(),
                         ack: ack_tx,
                     };

                     // ... (发送 cmd) ...

                     match ack_rx.await {
                         Ok(Ok((removed_index, index_changes))) => {
                            info!(target: "品种管理器", "收到删除确认，开始执行全局索引同步，共 {} 个变更...", index_changes.len());
                            
                            // 获取全局写锁，执行宏观更新
                            let mut write_map = symbol_to_global_index.write().await;
                            let mut write_vec = global_index_to_symbol.write().await;
                            
                            // 1. 从 Vec 和 Map 中移除被删除的品种
                            write_map.remove(&symbol_to_remove);
                            if removed_index < write_vec.len() {
                                write_vec.remove(removed_index);
                            }
                            
                            // 2. 遍历变更集，更新所有受影响的品种
                            for (symbol, new_index) in index_changes {
                                if let Some(entry) = write_map.get_mut(&symbol) {
                                    *entry = new_index;
                                }
                            }
                            
                            // 3. 更新全局计数器
                            global_symbol_count.store(write_vec.len(), Ordering::SeqCst);
                            
                            info!(target: "品种管理器", symbol = %symbol_to_remove, "全局索引同步完成");
                         }
                         // ... (错误处理) ...
                     }
                }
            }
        }
    }
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Rust
IGNORE_WHEN_COPYING_END
6. 下游消费者逻辑 (持久化任务)

文件路径: src/klagg_sub_threads/gateway.rs

由于本方案不存在 _REMOVED_ 占位符，db_writer_task 的 persist_kline_data 函数不需要任何修改。它读取的 global_index_to_symbol 永远是紧凑且有效的，可以直接使用。这是一个优点。

7. 总结

本方案详细阐述了通过数据前移和全局同步来实现动态品种管理的完整流程。

优点:

数据结构保持紧凑，无逻辑空洞。

下游消费者（如持久化任务）逻辑简单，无需处理特殊占位符。

权衡点:

删除操作在计算核心内部会引入一次与品种数量相关的 memmove 操作。

删除操作需要在调用方执行一次重量级的全局状态同步，在同步期间会持有对核心索引数据的写锁，可能短暂阻塞其他任务。

该方案在逻辑上是完备和自洽的，满足了“消除空洞”的核心要求。