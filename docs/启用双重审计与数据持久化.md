å¥½çš„ï¼Œæ˜ç™½äº†ã€‚æˆ‘ä»¬è¦åœ¨ç”Ÿäº§çš„ full-audit æ¨¡å¼ä¸‹ï¼ŒåŒæ—¶å¯ç”¨ç”Ÿå‘½å‘¨æœŸæ ¡éªŒå™¨å’Œæ•°æ®å®Œæ•´æ€§å®¡è®¡å™¨ï¼Œå¹¶ç¡®ä¿å®ƒä»¬éƒ½èƒ½æ­£ç¡®å·¥ä½œã€‚

ä½ æŒ‡å‡ºçš„é—®é¢˜éå¸¸å…³é”®ï¼Œmpsc é€šé“çš„å•ä¸€æ¶ˆè´¹è€…ç‰¹æ€§ç¡®å®é˜»æ­¢äº†æˆ‘ä»¬åŒæ—¶è¿›è¡ŒæŒä¹…åŒ–å’Œæ•°æ®å®Œæ•´æ€§å®¡è®¡ã€‚è¦è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæœ€ç›´æ¥ã€æœ€ç¬¦åˆæˆ‘ä»¬ç°æœ‰æ¶æ„æ€è·¯çš„æ–¹æ¡ˆå°±æ˜¯å°†finalized_kline_tx/rxä»mpsc channelå‡çº§ä¸ºbroadcast channelã€‚

broadcast channel å¤©ç”Ÿå°±æ˜¯ä¸ºâ€œä¸€å¤„ç”Ÿäº§ï¼Œå¤šå¤„æ¶ˆè´¹â€çš„åœºæ™¯è®¾è®¡çš„ï¼Œè¿™å®Œç¾åŒ¹é…æˆ‘ä»¬çš„æ–°éœ€æ±‚ï¼šKlineAggregator ç”Ÿäº§å·²å®Œæˆçš„Kçº¿ï¼Œè€Œfinalized_writer_taskå’Œrun_completeness_auditor_taskä½œä¸ºæ¶ˆè´¹è€…åŒæ—¶æ¥æ”¶ã€‚

ä¸‹é¢ï¼Œæˆ‘å°†ä¸ºä½ æä¾›ä¸€ä¸ªå®Œæ•´çš„ã€å¯ç›´æ¥ç”¨äºæœ¬åœ°AIæ‰§è¡Œçš„æœ€ç»ˆä¿®æ”¹æ–¹æ¡ˆã€‚è¿™ä¸ªæ–¹æ¡ˆä¸ä»…è§£å†³äº†æ ¸å¿ƒé—®é¢˜ï¼Œè¿˜åŒ…å«äº†æ‰€æœ‰å¿…è¦çš„ä¸Šä¸‹æ–‡å’Œé…å¥—ä¿®æ”¹ï¼Œç¡®ä¿é€»è¾‘çš„å®Œæ•´æ€§å’Œå¥å£®æ€§ã€‚

æœ€ç»ˆä¿®æ”¹æ–¹æ¡ˆï¼šå¯ç”¨åŒé‡å®¡è®¡ä¸æ•°æ®æŒä¹…åŒ–
æ ¸å¿ƒä¿®æ”¹é€»è¾‘

é€šé“å‡çº§: åœ¨ KlineAggregator::new ä¸­ï¼Œå°†ç”¨äºåˆ†å‘å·²å®ŒæˆKçº¿çš„é€šé“ä» mpsc channel å‡çº§ä¸º broadcast channelã€‚è¿™å°†å…è®¸æ•°æ®è¢«å¤šä¸ªä¸‹æ¸¸ä»»åŠ¡åŒæ—¶æ¶ˆè´¹ã€‚

æ¶ˆè´¹è€…é€‚é…: ä¿®æ”¹ finalized_writer_taskï¼ˆæŒä¹…åŒ–ä»»åŠ¡ï¼‰çš„ç­¾åå’Œå†…éƒ¨é€»è¾‘ï¼Œä½¿å…¶èƒ½å¤Ÿä» broadcast::Receiver æ¥æ”¶æ•°æ®ï¼Œå¹¶æ­£ç¡®å¤„ç†å¯èƒ½å‡ºç°çš„ Lagged é”™è¯¯ã€‚

å®¡è®¡å™¨æ¥å…¥: åœ¨ klagg_sub_threads.rs çš„å¯åŠ¨é€»è¾‘ä¸­ï¼Œä¸º run_completeness_auditor_taskï¼ˆå®Œæ•´æ€§å®¡è®¡å™¨ï¼‰è®¢é˜…ä¸€ä»½æ¥è‡ªæ–° broadcast channel çš„æ•°æ®æµï¼Œå¹¶å¯åŠ¨è¯¥ä»»åŠ¡ã€‚

å¯è§†åŒ–æµ‹è¯•åŒæ­¥: åœ¨ klagg_visual_test.rs ä¸­åŒæ­¥è¿›è¡Œç›¸ä¼¼çš„ä¿®æ”¹ï¼Œç¡®ä¿æµ‹è¯•ç¯å¢ƒä¸ç”Ÿäº§ç¯å¢ƒè¡Œä¸ºä¸€è‡´ã€‚

ç¬¬ä¸€æ­¥ï¼šä¿®æ”¹ klagg_sub_threads/mod.rs - å‡çº§é€šé“ä¸é€‚é…

æ–‡ä»¶: src/klagg_sub_threads/mod.rs

ä¿®æ”¹é€»è¾‘:

åœ¨ AggregatorOutputs ç»“æ„ä½“ä¸­ï¼Œå°† finalized_kline_rx çš„ç±»å‹ä» mpsc::Receiver æ”¹ä¸º broadcast::Senderã€‚è¿™æ ·åšæ›´ç¬¦åˆé€»è¾‘ï¼Œå› ä¸º Aggregator æ˜¯äº‹ä»¶çš„â€œè¾“å‡ºæ–¹â€ã€‚

åœ¨ KlineAggregator ç»“æ„ä½“ä¸­ï¼Œå°† finalized_kline_tx çš„ç±»å‹åŒæ ·æ”¹ä¸º broadcast::Senderã€‚

åœ¨ KlineAggregator::new å‡½æ•°ä¸­ï¼Œåˆ›å»º broadcast channel å¹¶æ­£ç¡®åœ°åˆå§‹åŒ– AggregatorOutputs å’Œ KlineAggregatorã€‚

åœ¨ KlineAggregator::finalize_and_snapshot_kline å‡½æ•°ä¸­ï¼Œä½¿ç”¨ broadcast::Sender çš„ send æ–¹æ³•ã€‚ç”±äº broadcast çš„ send åœ¨æ²¡æœ‰æ¶ˆè´¹è€…æ—¶ä¹Ÿä¼šè¿”å› Errï¼Œæˆ‘ä»¬éœ€è¦ä¿ç•™ç°æœ‰çš„é”™è¯¯å¤„ç†é€»è¾‘ã€‚

Generated rust
// æ–‡ä»¶: src/klagg_sub_threads/mod.rs

// ... (å…¶ä»– use è¯­å¥)
use tokio::sync::{mpsc, oneshot, watch, RwLock, broadcast}; // [ä¿®æ”¹] å¼•å…¥ broadcast

// ... (å…¶ä»–ç»“æ„ä½“å®šä¹‰)

// [ä¿®æ”¹] å®šä¹‰ç»Ÿä¸€çš„è¾“å‡ºç»“æ„ä½“
pub struct AggregatorOutputs {
    pub ws_cmd_rx: mpsc::Receiver<WsCmd>,
    pub trade_rx: mpsc::Receiver<AggTradePayload>,
    // [ä¿®æ”¹] ç±»å‹å˜æ›´ä¸º broadcast::Senderï¼Œè¡¨ç¤º Aggregator è¾“å‡ºå·²å®Œæˆçš„Kçº¿äº‹ä»¶
    pub finalized_kline_tx: broadcast::Sender<KlineData>,
    #[cfg(feature = "full-audit")]
    pub lifecycle_event_tx: broadcast::Sender<KlineLifecycleEvent>,
}

pub struct KlineAggregator {
    // ... (å…¶ä»–å­—æ®µ)

    // [ä¿®æ”¹] ç±»å‹å˜æ›´ä¸º broadcast::Sender
    finalized_kline_tx: broadcast::Sender<KlineData>,

    #[cfg(feature = "full-audit")]
    lifecycle_event_tx: broadcast::Sender<KlineLifecycleEvent>,
    
    // ... (å…¶ä»–å­—æ®µ)
}

impl KlineAggregator {
    #[allow(clippy::too_many_arguments)]
    #[instrument(target = "è®¡ç®—æ ¸å¿ƒ", level = "info", skip_all, fields(initial_symbols = assigned_symbols.len()))]
    pub async fn new(
        // ... (å‡½æ•°å‚æ•°ä¸å˜)
    ) -> Result<(Self, AggregatorOutputs)> {
        let (full_snapshot_req_tx, full_snapshot_req_rx) = mpsc::channel(8);
        let (deltas_req_tx, deltas_req_rx) = mpsc::channel(8);
        let (ws_cmd_tx, ws_cmd_rx) = mpsc::channel(8);
        let (trade_tx, trade_rx) = mpsc::channel::<AggTradePayload>(10240);
        
        // [æ ¸å¿ƒä¿®æ”¹] åˆ›å»ºå¤§å®¹é‡ broadcast é€šé“ç”¨äºæ¨é€å·²å®Œæˆçš„Kçº¿
        let (finalized_kline_tx, _) = broadcast::channel(10000);

        #[cfg(feature = "full-audit")]
        let (lifecycle_event_tx, _) = broadcast::channel(4096);

        // ... (å…¶ä»–åˆå§‹åŒ–é€»è¾‘ä¸å˜)

        let aggregator = Self {
            // ... (å…¶ä»–å­—æ®µèµ‹å€¼)
            finalized_kline_tx: finalized_kline_tx.clone(), // [ä¿®æ”¹] å…‹éš† Sender
            #[cfg(feature = "full-audit")]
            lifecycle_event_tx: lifecycle_event_tx.clone(),
            // ... (å…¶ä»–å­—æ®µèµ‹å€¼)
        };

        let outputs = AggregatorOutputs {
            ws_cmd_rx,
            trade_rx,
            finalized_kline_tx, // [ä¿®æ”¹] å°† Sender ç§»åŠ¨åˆ° outputs ä¸­
            #[cfg(feature = "full-audit")]
            lifecycle_event_tx,
        };

        Ok((aggregator, outputs))
    }

    // ... (get_read_handle, get_trade_sender, publish_lifecycle_event ä¸å˜)

    fn finalize_and_snapshot_kline(&mut self, kline_offset: usize, final_close: f64, is_final: bool) {
        // ... (å‡½æ•°å‰åŠéƒ¨åˆ†é€»è¾‘ä¸å˜)

        if is_final {
            let global_symbol_index = kline_offset / self.periods.len();
            let period_index = kline_offset % self.periods.len();

            if let (Some(symbol), Some(period)) = (
                self.global_index_to_symbol_cache.get(global_symbol_index),
                self.periods.get(period_index)
            ) {
                let kline_data = KlineData { /* ... */ };

                // [ä¿®æ”¹] ä½¿ç”¨ broadcast::Sender::sendï¼Œå¹¶å¤„ç†é”™è¯¯
                if self.finalized_kline_tx.send(kline_data.clone()).is_err() {
                    // è¿™ä¸ªé”™è¯¯é€šå¸¸æ„å‘³ç€æ²¡æœ‰æ¶ˆè´¹è€…ï¼ˆæŒä¹…åŒ–ä»»åŠ¡æˆ–å®¡è®¡ä»»åŠ¡æœªå¯åŠ¨/å·²é€€å‡ºï¼‰
                    // åœ¨ç”Ÿäº§ç¯å¢ƒä¸­è¿™å¯èƒ½æ˜¯ä¸€ä¸ªé—®é¢˜ï¼Œä½†åœ¨æŸäº›æµ‹è¯•åœºæ™¯ä¸‹æ˜¯æ­£å¸¸çš„ã€‚
                    warn!(
                        target: "è®¡ç®—æ ¸å¿ƒ",
                        log_type = "channel_send_failure",
                        "å·²å®ŒæˆKçº¿æ— äººæ¥æ”¶ï¼Œå¯èƒ½æŒä¹…åŒ–æˆ–å®¡è®¡ä»»åŠ¡æœªè¿è¡Œã€‚"
                    );
                }
            }
        }
        
        // ... (å‡½æ•°ååŠéƒ¨åˆ†é€»è¾‘ä¸å˜)
    }

    // ... (æ‰€æœ‰å…¶ä»–å‡½æ•° process_trade, process_clock_tick ç­‰ä¿æŒä¸å˜)
}

ç¬¬äºŒæ­¥ï¼šä¿®æ”¹ klagg_sub_threads/gateway.rs - é€‚é…æ¶ˆè´¹è€…

æ–‡ä»¶: src/klagg_sub_threads/gateway.rs

ä¿®æ”¹é€»è¾‘:

ä¿®æ”¹ finalized_writer_task çš„å‡½æ•°ç­¾åï¼Œæ¥æ”¶ broadcast::Receiver<super::KlineData>ã€‚

åœ¨å…¶ä¸»å¾ªç¯çš„ select! å®ä¸­ï¼Œæ­£ç¡®å¤„ç† broadcast::Receiver::recv() å¯èƒ½è¿”å›çš„ Ok, Err(RecvError::Closed), å’Œ Err(RecvError::Lagged) ä¸‰ç§æƒ…å†µã€‚

Generated rust
// æ–‡ä»¶: src/klagg_sub_threads/gateway.rs

// ... (å…¶ä»– use è¯­å¥)
use tokio::sync::{mpsc, watch, RwLock, broadcast}; // [ä¿®æ”¹] å¼•å…¥ broadcast
use tokio::sync::broadcast::error::RecvError;    // [æ–°å¢] å¼•å…¥ RecvError

// ... (gateway_task_for_web å’Œå…¶ä»–è¾…åŠ©å‡½æ•°ä¸å˜)

// [ä¿®æ”¹] é«˜ä¼˜å…ˆçº§æŒä¹…åŒ–ä»»åŠ¡ - é€‚é… broadcast channel
#[instrument(target = "æŒä¹…åŒ–ä»»åŠ¡", skip_all, name = "finalized_writer_task")]
pub async fn finalized_writer_task(
    db: Arc<Database>,
    // [æ ¸å¿ƒä¿®æ”¹] æ¥æ”¶ broadcast::Receiver
    mut finalized_kline_rx: broadcast::Receiver<super::KlineData>,
    index_to_symbol: Arc<RwLock<Vec<String>>>,
    periods: Arc<Vec<String>>,
    config: Arc<AggregateConfig>,
    mut shutdown_rx: watch::Receiver<bool>,
    _watchdog: Arc<WatchdogV2>,
) {
    info!(target: "æŒä¹…åŒ–ä»»åŠ¡", "é«˜ä¼˜å…ˆçº§ Finalized-Writer ä»»åŠ¡å·²å¯åŠ¨ (Broadcastæ¨¡å¼)");

    let buffer_max_size = config.persistence.finalized_buffer_size;
    let flush_interval = Duration::from_millis(config.persistence.finalized_flush_interval_ms);

    let mut buffer: Vec<super::KlineData> = Vec::with_capacity(buffer_max_size);
    let mut interval = tokio::time::interval(flush_interval);
    interval.set_missed_tick_behavior(tokio::time::MissedTickBehavior::Skip);

    loop {
        tokio::select! {
            // ä¼˜é›…å…³é—­åˆ†æ”¯ (é€»è¾‘ä¸å˜)
            _ = shutdown_rx.changed() => {
                info!(target: "æŒä¹…åŒ–ä»»åŠ¡", "æ”¶åˆ°å…³é—­ä¿¡å·ï¼Œå¼€å§‹ä¼˜é›…å…³é—­é«˜ä¼˜å…ˆçº§æŒä¹…åŒ–ä»»åŠ¡");
                // [ä¿®æ”¹] åœ¨å…³é—­æ—¶ï¼Œä½¿ç”¨ try_recv å¾ªç¯æ’ç©ºé€šé“
                loop {
                    match finalized_kline_rx.try_recv() {
                        Ok(kline) => buffer.push(kline),
                        Err(RecvError::Empty) => break, // é€šé“å·²ç©º
                        Err(RecvError::Closed) => break, // é€šé“å·²å…³é—­
                        Err(RecvError::Lagged(n)) => warn!(target: "æŒä¹…åŒ–ä»»åŠ¡", count = n, "å…³é—­æ—¶å‘ç°æ»åï¼Œä¸¢å¤±äº†éƒ¨åˆ†æ•°æ®"),
                    }
                }

                if !buffer.is_empty() {
                    info!(target: "æŒä¹…åŒ–ä»»åŠ¡", count = buffer.len(), "ä¼˜é›…å…³é—­ï¼šæŒä¹…åŒ–ç¼“å†²åŒºä¸­çš„å‰©ä½™æ•°æ®");
                    persist_kline_data(db.clone(), &buffer, &index_to_symbol, &periods).await;
                }
                break;
            }

            // [æ ¸å¿ƒä¿®æ”¹] æ¥æ”¶å·²å®Œæˆçš„Kçº¿
            result = finalized_kline_rx.recv() => {
                match result {
                    Ok(kline) => {
                        buffer.push(kline);
                        if buffer.len() >= buffer_max_size {
                            trace!(target: "æŒä¹…åŒ–ä»»åŠ¡", count = buffer.len(), "ç¼“å†²åŒºå·²æ»¡ï¼Œç«‹å³åˆ·ç›˜");
                            persist_kline_data(db.clone(), &buffer, &index_to_symbol, &periods).await;
                            buffer.clear();
                        }
                    },
                    Err(RecvError::Closed) => {
                        warn!(target: "æŒä¹…åŒ–ä»»åŠ¡", "Finalized Kline é€šé“å·²å…³é—­ï¼Œä»»åŠ¡é€€å‡º");
                        break;
                    },
                    Err(RecvError::Lagged(skipped_count)) => {
                        error!(
                            target: "æŒä¹…åŒ–ä»»åŠ¡",
                            log_type = "DATA_LOSS",
                            skipped = skipped_count,
                            "æŒä¹…åŒ–ä»»åŠ¡å¤„ç†ç¼“æ…¢ï¼Œå·²ä¸¢å¤± finalized kline æ•°æ®ï¼"
                        );
                    }
                }
            }

            // å®šæ—¶åˆ·ç›˜ (é€»è¾‘ä¸å˜)
            _ = interval.tick() => {
                if !buffer.is_empty() {
                    trace!(target: "æŒä¹…åŒ–ä»»åŠ¡", count = buffer.len(), "å®šæ—¶åˆ·ç›˜");
                    persist_kline_data(db.clone(), &buffer, &index_to_symbol, &periods).await;
                    buffer.clear();
                }
            }
        }
    }
    warn!(target: "æŒä¹…åŒ–ä»»åŠ¡", "é«˜ä¼˜å…ˆçº§ Finalized-Writer ä»»åŠ¡å·²é€€å‡º");
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Rust
IGNORE_WHEN_COPYING_END
ç¬¬ä¸‰æ­¥ï¼šä¿®æ”¹ auditor.rs - åŒæ ·é€‚é…æ¶ˆè´¹è€…

æ–‡ä»¶: src/klagg_sub_threads/auditor.rs

ä¿®æ”¹é€»è¾‘:
ä¸ä¸Šä¸€æ­¥ç±»ä¼¼ï¼Œä¿®æ”¹ run_completeness_auditor_task ä»¥æ¶ˆè´¹ broadcast::Receiver å¹¶å¤„ç†æ‰€æœ‰å¯èƒ½çš„é”™è¯¯æƒ…å†µã€‚

Generated rust
// æ–‡ä»¶: src/klagg_sub_threads/auditor.rs

// ... (å…¶ä»– use è¯­å¥)
use tokio::sync::{broadcast, watch}; // [ä¿®æ”¹] å¼•å…¥ broadcast
use tokio::sync::broadcast::error::RecvError; // [æ–°å¢] å¼•å…¥ RecvError
use tokio::time::{interval, Duration};
// ... (å…¶ä»– use è¯­å¥)

// ... (AuditStats å’Œ KlineAuditContext ç»“æ„ä½“ä¸å˜)

// [ä¿®æ”¹] å®Œæ•´æ€§å®¡è®¡å™¨ä»»åŠ¡çš„å®ç° - é€‚é… broadcast channel
#[instrument(target = "æ•°æ®å®Œæ•´æ€§å®¡è®¡", skip_all, name = "completeness_auditor_task")]
pub async fn run_completeness_auditor_task(
    // [æ ¸å¿ƒä¿®æ”¹] æ¥æ”¶ broadcast::Receiver
    mut kline_rx: broadcast::Receiver<KlineData>,
    mut shutdown_rx: watch::Receiver<bool>,
) {
    info!(target: "æ•°æ®å®Œæ•´æ€§å®¡è®¡", "æ•°æ®å®Œæ•´æ€§å®¡è®¡å™¨ä»»åŠ¡å¯åŠ¨ (Broadcastæ¨¡å¼)");
    
    let mut stats = AuditStats::default();
    let mut audit_contexts: HashMap<String, KlineAuditContext> = HashMap::new();
    let mut report_interval = interval(Duration::from_secs(300)); // æ¯5åˆ†é’ŸæŠ¥å‘Šä¸€æ¬¡
    
    loop {
        tokio::select! {
            // æ£€æŸ¥å…³é—­ä¿¡å· (é€»è¾‘ä¸å˜)
            _ = shutdown_rx.changed() => {
                if *shutdown_rx.borrow() {
                    info!(target: "æ•°æ®å®Œæ•´æ€§å®¡è®¡", "æ”¶åˆ°å…³é—­ä¿¡å·ï¼Œå®Œæ•´æ€§å®¡è®¡å™¨æ­£åœ¨é€€å‡º");
                    break;
                }
            },
            
            // [æ ¸å¿ƒä¿®æ”¹] æ¥æ”¶Kçº¿æ•°æ®è¿›è¡Œå®¡è®¡
            result = kline_rx.recv() => {
                match result {
                    Ok(kline) => {
                        debug!(
                            target: "æ•°æ®å®Œæ•´æ€§å®¡è®¡",
                            symbol = %kline.symbol,
                            period = %kline.period,
                            open_time = kline.open_time,
                            "æ”¶åˆ°Kçº¿æ•°æ®è¿›è¡Œå®¡è®¡"
                        );
                        stats.record_kline(&kline);
                        audit_kline_data(&kline, &mut audit_contexts, &mut stats);
                    },
                    Err(RecvError::Closed) => {
                        warn!(target: "æ•°æ®å®Œæ•´æ€§å®¡è®¡", "Finalized Kline é€šé“å·²å…³é—­ï¼Œå®¡è®¡å™¨é€€å‡º");
                        break;
                    },
                    Err(RecvError::Lagged(skipped_count)) => {
                        error!(
                            target: "æ•°æ®å®Œæ•´æ€§å®¡è®¡",
                            log_type = "DATA_LOSS",
                            skipped = skipped_count,
                            "å®Œæ•´æ€§å®¡è®¡ä»»åŠ¡å¤„ç†ç¼“æ…¢ï¼Œå·²ä¸¢å¤± finalized kline æ•°æ®ï¼"
                        );
                    }
                }
            },
            
            // å®šæœŸæŠ¥å‘Šç»Ÿè®¡ä¿¡æ¯ (é€»è¾‘ä¸å˜)
            _ = report_interval.tick() => {
                stats.log_summary();
            },
        }
    }
    
    stats.log_summary();
    info!(target: "æ•°æ®å®Œæ•´æ€§å®¡è®¡", "æ•°æ®å®Œæ•´æ€§å®¡è®¡å™¨ä»»åŠ¡å·²é€€å‡º");
}

// ... (audit_kline_data å’Œ get_period_interval_ms å‡½æ•°ä¸å˜)
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Rust
IGNORE_WHEN_COPYING_END
ç¬¬å››æ­¥ï¼šä¿®æ”¹ klagg_sub_threads.rs (ç”Ÿäº§å…¥å£) - å¯åŠ¨åŒé‡å®¡è®¡

æ–‡ä»¶: src/bin/klagg_sub_threads.rs

ä¿®æ”¹é€»è¾‘:

è§£æ„ KlineAggregator::new çš„è¿”å›å€¼æ—¶ï¼Œè·å– finalized_kline_txã€‚

åœ¨ full-audit æ¨¡å¼ä¸‹ï¼Œåˆ†åˆ«ä¸º finalized_writer_task å’Œ run_completeness_auditor_task è®¢é˜… Receiverã€‚

å¯åŠ¨ run_completeness_auditor_task ä»»åŠ¡ã€‚

Generated rust
// æ–‡ä»¶: src/bin/klagg_sub_threads.rs

// ... (å…¶ä»– use è¯­å¥)

async fn run_app(io_runtime: &Runtime) -> Result<()> {
    // ... (åˆå§‹åŒ–é€»è¾‘)

    let (mut aggregator, mut outputs) = klagg::KlineAggregator::new(/* ... */).await?;
    let ws_cmd_rx = outputs.ws_cmd_rx;
    let trade_rx = outputs.trade_rx;
    // [ä¿®æ”¹] è·å– finalized_kline_tx (Sender)
    let finalized_kline_tx = outputs.finalized_kline_tx;

    // ... (å…¶ä»–ä»»åŠ¡å¯åŠ¨é€»è¾‘)

    // [ä¿®æ”¹] å¯åŠ¨ Finalized-Writer æŒä¹…åŒ–ä»»åŠ¡ (é«˜ä¼˜å…ˆçº§)
    info!(target: "åº”ç”¨ç”Ÿå‘½å‘¨æœŸ", "å¯åŠ¨ Finalized-Writer æŒä¹…åŒ–ä»»åŠ¡ (é«˜ä¼˜å…ˆçº§)...");
    // [ä¿®æ”¹] ä¸ºæŒä¹…åŒ–ä»»åŠ¡è®¢é˜…ä¸€ä¸ª Receiver
    let finalized_kline_rx_for_persistence = finalized_kline_tx.subscribe();
    let finalized_persistence_handle = log::context::spawn_instrumented_on(
        klagg::finalized_writer_task(
            db.clone(),
            finalized_kline_rx_for_persistence, // <--- ä¼ å…¥è®¢é˜…çš„ Receiver
            global_index_to_symbol.clone(),
            periods.clone(),
            config.clone(),
            shutdown_rx.clone(),
            watchdog.clone(),
        ),
        io_runtime,
    );

    // ... (snapshot_writer_task å’Œå…¶ä»–ä»»åŠ¡å¯åŠ¨é€»è¾‘ä¸å˜)

    // [æ ¸å¿ƒä¿®æ”¹] åœ¨ full-audit æ¨¡å¼ä¸‹ï¼Œå¯åŠ¨æ‰€æœ‰å®¡è®¡ä»»åŠ¡
    #[cfg(feature = "full-audit")]
    {
        info!(
            target: "åº”ç”¨ç”Ÿå‘½å‘¨æœŸ",
            log_type = "audit_startup",
            "ğŸ” ç”Ÿäº§ç¯å¢ƒï¼šå¯ç”¨ full-auditï¼Œæ­£åœ¨å¯åŠ¨æ‰€æœ‰å®¡è®¡ä»»åŠ¡..."
        );

        // --- 1. å¯åŠ¨ç”Ÿå‘½å‘¨æœŸæ ¡éªŒå™¨ (é€»è¾‘ä¸å˜ï¼Œä½†ä¸ºäº†å®Œæ•´æ€§åŒ…å«åœ¨æ­¤) ---
        let lifecycle_event_rx_for_validator = outputs.lifecycle_event_tx.subscribe();
        let lifecycle_clock_rx = clock_tx.subscribe();
        info!(target: "åº”ç”¨ç”Ÿå‘½å‘¨æœŸ", log_type = "audit_startup", "ğŸš€ å¯åŠ¨ç”Ÿå‘½å‘¨æœŸæ ¡éªŒå™¨ä»»åŠ¡...");
        log::context::spawn_instrumented_on(
            klagg::run_lifecycle_validator_task(
                lifecycle_event_rx_for_validator, 
                shutdown_rx.clone(),
                lifecycle_clock_rx
            ),
            io_runtime,
        );

        // --- 2. [æ–°å¢] å¯åŠ¨æ•°æ®å®Œæ•´æ€§å®¡è®¡å™¨ ---
        info!(target: "åº”ç”¨ç”Ÿå‘½å‘¨æœŸ", log_type = "audit_startup", "ğŸš€ å¯åŠ¨æ•°æ®å®Œæ•´æ€§å®¡è®¡å™¨ä»»åŠ¡...");
        // [æ–°å¢] ä¸ºå®Œæ•´æ€§å®¡è®¡å™¨è®¢é˜…ä¸€ä¸ª Receiver
        let finalized_kline_rx_for_auditor = finalized_kline_tx.subscribe();
        log::context::spawn_instrumented_on(
            klagg::run_completeness_auditor_task(
                finalized_kline_rx_for_auditor, // <--- ä¼ å…¥è®¢é˜…çš„ Receiver
                shutdown_rx.clone()
            ),
            io_runtime,
        );


        info!(
            target: "åº”ç”¨ç”Ÿå‘½å‘¨æœŸ",
            log_type = "audit_startup",
            "âœ… æ‰€æœ‰å®¡è®¡ä»»åŠ¡å¯åŠ¨å®Œæˆ - ç”Ÿäº§ç¯å¢ƒç°åœ¨å…·å¤‡å®Œæ•´çš„ç”Ÿå‘½å‘¨æœŸå’Œæ•°æ®å®Œæ•´æ€§æ ¡éªŒèƒ½åŠ›"
        );
    }
    
    // ... (åç»­é€»è¾‘ä¸å˜)
    Ok(())
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Rust
IGNORE_WHEN_COPYING_END

æ³¨æ„ï¼šæˆ‘å°†ä½ ä¹‹å‰ç¡®è®¤çš„lifecycle_validatorä¿®æ”¹ä¹Ÿä¸€å¹¶æ•´åˆäº†è¿›æ¥ã€‚

ç¬¬äº”æ­¥ï¼šåŒæ­¥ä¿®æ”¹ klagg_visual_test.rs (æµ‹è¯•å…¥å£)

æ–‡ä»¶: src/bin/klagg_visual_test.rs

ä¿®æ”¹é€»è¾‘:
ä¸ç”Ÿäº§å…¥å£çš„ä¿®æ”¹å®Œå…¨å¯¹ç­‰ï¼Œç¡®ä¿æµ‹è¯•ç¯å¢ƒä¸ç”Ÿäº§ç¯å¢ƒçš„å®¡è®¡é€»è¾‘ä¸€è‡´ã€‚

Generated rust
// æ–‡ä»¶: src/bin/klagg_visual_test.rs

// ... (å…¶ä»– use è¯­å¥)

async fn run_visual_test_app(
    io_runtime: &Runtime,
) -> Result<()> {
    // ... (åˆå§‹åŒ–é€»è¾‘)

    let (mut aggregator, mut outputs) = klagg::KlineAggregator::new(/* ... */).await?;
    let ws_cmd_rx = outputs.ws_cmd_rx;
    let trade_rx = outputs.trade_rx;
    // [ä¿®æ”¹] è·å– finalized_kline_tx (Sender)
    let finalized_kline_tx = outputs.finalized_kline_tx;

    // [ä¿®æ”¹] è®¢é˜…ä¸€ä¸ª finalized kline çš„ receiver ç”¨äºæ¨¡æ‹Ÿæ¶ˆè´¹è€…
    let mut finalized_kline_rx_for_drain = finalized_kline_tx.subscribe();

    // ... (å…¶ä»–ä»»åŠ¡å¯åŠ¨é€»è¾‘)

    // [ä¿®æ”¹] æ¨¡æ‹Ÿæ¶ˆè´¹ä»»åŠ¡ç°åœ¨ä» broadcast receiver æ¥æ”¶
    tokio::spawn(async move {
        info!("å¯åŠ¨æ¨¡æ‹Ÿçš„ finalized_kline æ¶ˆè´¹è€…ï¼Œé˜²æ­¢é€šé“é˜»å¡ (Broadcastæ¨¡å¼)");
        loop {
            use tokio::sync::broadcast::error::RecvError;
            match finalized_kline_rx_for_drain.recv().await {
                Ok(_) => { /* ä»€ä¹ˆä¹Ÿä¸åšï¼Œåªæ˜¯æ¶ˆè´¹æ¶ˆæ¯ */ },
                Err(RecvError::Closed) => break,
                Err(RecvError::Lagged(_)) => { /* åœ¨æµ‹è¯•ä¸­å¯ä»¥å¿½ç•¥ */ }
            }
        }
        warn!("finalized_kline é€šé“å·²å…³é—­ï¼Œæ¨¡æ‹Ÿæ¶ˆè´¹è€…é€€å‡º");
    });

    // [æ ¸å¿ƒä¿®æ”¹] åœ¨ full-audit æ¨¡å¼ä¸‹ï¼Œå¯åŠ¨æ‰€æœ‰å®¡è®¡ä»»åŠ¡
    #[cfg(feature = "full-audit")]
    {
        info!(
            target: "åº”ç”¨ç”Ÿå‘½å‘¨æœŸ",
            log_type = "audit_startup",
            "ğŸ” å¯è§†åŒ–æµ‹è¯•æ¨¡å¼ï¼šå¯ç”¨ full-auditï¼Œæ­£åœ¨å¯åŠ¨æ‰€æœ‰å®¡è®¡ä»»åŠ¡..."
        );

        // --- 1. å¯åŠ¨ç”Ÿå‘½å‘¨æœŸæ ¡éªŒå™¨ ---
        let lifecycle_event_rx_for_validator = outputs.lifecycle_event_tx.subscribe();
        let lifecycle_clock_rx = clock_tx.subscribe();
        info!(target: "åº”ç”¨ç”Ÿå‘½å‘¨æœŸ", log_type = "audit_startup", "ğŸš€ å¯åŠ¨ç”Ÿå‘½å‘¨æœŸæ ¡éªŒå™¨ä»»åŠ¡...");
        log::context::spawn_instrumented_on(
            klagg::run_lifecycle_validator_task(
                lifecycle_event_rx_for_validator,
                shutdown_rx.clone(),
                lifecycle_clock_rx
            ),
            io_runtime,
        );

        // --- 2. [æ–°å¢] å¯åŠ¨æ•°æ®å®Œæ•´æ€§å®¡è®¡å™¨ ---
        info!(target: "åº”ç”¨ç”Ÿå‘½å‘¨æœŸ", log_type = "audit_startup", "ğŸš€ å¯åŠ¨æ•°æ®å®Œæ•´æ€§å®¡è®¡å™¨ä»»åŠ¡...");
        let finalized_kline_rx_for_auditor = finalized_kline_tx.subscribe();
        log::context::spawn_instrumented_on(
            klagg::run_completeness_auditor_task(
                finalized_kline_rx_for_auditor,
                shutdown_rx.clone()
            ),
            io_runtime,
        );

        info!(
            target: "åº”ç”¨ç”Ÿå‘½å‘¨æœŸ",
            log_type = "audit_startup",
            "âœ… æ‰€æœ‰å®¡è®¡ä»»åŠ¡å¯åŠ¨å®Œæˆ - ç³»ç»Ÿç°åœ¨å…·å¤‡å®Œæ•´çš„å®¡è®¡èƒ½åŠ›"
        );
    }
    
    // ... (åç»­é€»è¾‘ä¸å˜)
    Ok(())
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Rust
IGNORE_WHEN_COPYING_END

è¿™ä»½å®Œæ•´çš„æ–¹æ¡ˆè§£å†³äº†é€šé“çš„æ¶ˆè´¹é—®é¢˜ï¼Œä½¿å¾—åœ¨ç”Ÿäº§å®¡è®¡æ¨¡å¼ä¸‹ï¼ŒæŒä¹…åŒ–ä»»åŠ¡å’Œæ•°æ®å®Œæ•´æ€§å®¡è®¡ä»»åŠ¡å¯ä»¥å¹¶è¡Œå·¥ä½œï¼Œå…±åŒæ¶ˆè´¹å·²å®Œæˆçš„Kçº¿æ•°æ®ã€‚æ•´ä¸ªé€»è¾‘é“¾æ¡ç°åœ¨æ˜¯å®Œæ•´ä¸”å¥å£®çš„ã€‚