好的，明白了。我们要在生产的 full-audit 模式下，同时启用生命周期校验器和数据完整性审计器，并确保它们都能正确工作。

你指出的问题非常关键，mpsc 通道的单一消费者特性确实阻止了我们同时进行持久化和数据完整性审计。要解决这个问题，最直接、最符合我们现有架构思路的方案就是将finalized_kline_tx/rx从mpsc channel升级为broadcast channel。

broadcast channel 天生就是为“一处生产，多处消费”的场景设计的，这完美匹配我们的新需求：KlineAggregator 生产已完成的K线，而finalized_writer_task和run_completeness_auditor_task作为消费者同时接收。

下面，我将为你提供一个完整的、可直接用于本地AI执行的最终修改方案。这个方案不仅解决了核心问题，还包含了所有必要的上下文和配套修改，确保逻辑的完整性和健壮性。

最终修改方案：启用双重审计与数据持久化
核心修改逻辑

通道升级: 在 KlineAggregator::new 中，将用于分发已完成K线的通道从 mpsc channel 升级为 broadcast channel。这将允许数据被多个下游任务同时消费。

消费者适配: 修改 finalized_writer_task（持久化任务）的签名和内部逻辑，使其能够从 broadcast::Receiver 接收数据，并正确处理可能出现的 Lagged 错误。

审计器接入: 在 klagg_sub_threads.rs 的启动逻辑中，为 run_completeness_auditor_task（完整性审计器）订阅一份来自新 broadcast channel 的数据流，并启动该任务。

可视化测试同步: 在 klagg_visual_test.rs 中同步进行相似的修改，确保测试环境与生产环境行为一致。

第一步：修改 klagg_sub_threads/mod.rs - 升级通道与适配

文件: src/klagg_sub_threads/mod.rs

修改逻辑:

在 AggregatorOutputs 结构体中，将 finalized_kline_rx 的类型从 mpsc::Receiver 改为 broadcast::Sender。这样做更符合逻辑，因为 Aggregator 是事件的“输出方”。

在 KlineAggregator 结构体中，将 finalized_kline_tx 的类型同样改为 broadcast::Sender。

在 KlineAggregator::new 函数中，创建 broadcast channel 并正确地初始化 AggregatorOutputs 和 KlineAggregator。

在 KlineAggregator::finalize_and_snapshot_kline 函数中，使用 broadcast::Sender 的 send 方法。由于 broadcast 的 send 在没有消费者时也会返回 Err，我们需要保留现有的错误处理逻辑。

Generated rust
// 文件: src/klagg_sub_threads/mod.rs

// ... (其他 use 语句)
use tokio::sync::{mpsc, oneshot, watch, RwLock, broadcast}; // [修改] 引入 broadcast

// ... (其他结构体定义)

// [修改] 定义统一的输出结构体
pub struct AggregatorOutputs {
    pub ws_cmd_rx: mpsc::Receiver<WsCmd>,
    pub trade_rx: mpsc::Receiver<AggTradePayload>,
    // [修改] 类型变更为 broadcast::Sender，表示 Aggregator 输出已完成的K线事件
    pub finalized_kline_tx: broadcast::Sender<KlineData>,
    #[cfg(feature = "full-audit")]
    pub lifecycle_event_tx: broadcast::Sender<KlineLifecycleEvent>,
}

pub struct KlineAggregator {
    // ... (其他字段)

    // [修改] 类型变更为 broadcast::Sender
    finalized_kline_tx: broadcast::Sender<KlineData>,

    #[cfg(feature = "full-audit")]
    lifecycle_event_tx: broadcast::Sender<KlineLifecycleEvent>,
    
    // ... (其他字段)
}

impl KlineAggregator {
    #[allow(clippy::too_many_arguments)]
    #[instrument(target = "计算核心", level = "info", skip_all, fields(initial_symbols = assigned_symbols.len()))]
    pub async fn new(
        // ... (函数参数不变)
    ) -> Result<(Self, AggregatorOutputs)> {
        let (full_snapshot_req_tx, full_snapshot_req_rx) = mpsc::channel(8);
        let (deltas_req_tx, deltas_req_rx) = mpsc::channel(8);
        let (ws_cmd_tx, ws_cmd_rx) = mpsc::channel(8);
        let (trade_tx, trade_rx) = mpsc::channel::<AggTradePayload>(10240);
        
        // [核心修改] 创建大容量 broadcast 通道用于推送已完成的K线
        let (finalized_kline_tx, _) = broadcast::channel(10000);

        #[cfg(feature = "full-audit")]
        let (lifecycle_event_tx, _) = broadcast::channel(4096);

        // ... (其他初始化逻辑不变)

        let aggregator = Self {
            // ... (其他字段赋值)
            finalized_kline_tx: finalized_kline_tx.clone(), // [修改] 克隆 Sender
            #[cfg(feature = "full-audit")]
            lifecycle_event_tx: lifecycle_event_tx.clone(),
            // ... (其他字段赋值)
        };

        let outputs = AggregatorOutputs {
            ws_cmd_rx,
            trade_rx,
            finalized_kline_tx, // [修改] 将 Sender 移动到 outputs 中
            #[cfg(feature = "full-audit")]
            lifecycle_event_tx,
        };

        Ok((aggregator, outputs))
    }

    // ... (get_read_handle, get_trade_sender, publish_lifecycle_event 不变)

    fn finalize_and_snapshot_kline(&mut self, kline_offset: usize, final_close: f64, is_final: bool) {
        // ... (函数前半部分逻辑不变)

        if is_final {
            let global_symbol_index = kline_offset / self.periods.len();
            let period_index = kline_offset % self.periods.len();

            if let (Some(symbol), Some(period)) = (
                self.global_index_to_symbol_cache.get(global_symbol_index),
                self.periods.get(period_index)
            ) {
                let kline_data = KlineData { /* ... */ };

                // [修改] 使用 broadcast::Sender::send，并处理错误
                if self.finalized_kline_tx.send(kline_data.clone()).is_err() {
                    // 这个错误通常意味着没有消费者（持久化任务或审计任务未启动/已退出）
                    // 在生产环境中这可能是一个问题，但在某些测试场景下是正常的。
                    warn!(
                        target: "计算核心",
                        log_type = "channel_send_failure",
                        "已完成K线无人接收，可能持久化或审计任务未运行。"
                    );
                }
            }
        }
        
        // ... (函数后半部分逻辑不变)
    }

    // ... (所有其他函数 process_trade, process_clock_tick 等保持不变)
}

第二步：修改 klagg_sub_threads/gateway.rs - 适配消费者

文件: src/klagg_sub_threads/gateway.rs

修改逻辑:

修改 finalized_writer_task 的函数签名，接收 broadcast::Receiver<super::KlineData>。

在其主循环的 select! 宏中，正确处理 broadcast::Receiver::recv() 可能返回的 Ok, Err(RecvError::Closed), 和 Err(RecvError::Lagged) 三种情况。

Generated rust
// 文件: src/klagg_sub_threads/gateway.rs

// ... (其他 use 语句)
use tokio::sync::{mpsc, watch, RwLock, broadcast}; // [修改] 引入 broadcast
use tokio::sync::broadcast::error::RecvError;    // [新增] 引入 RecvError

// ... (gateway_task_for_web 和其他辅助函数不变)

// [修改] 高优先级持久化任务 - 适配 broadcast channel
#[instrument(target = "持久化任务", skip_all, name = "finalized_writer_task")]
pub async fn finalized_writer_task(
    db: Arc<Database>,
    // [核心修改] 接收 broadcast::Receiver
    mut finalized_kline_rx: broadcast::Receiver<super::KlineData>,
    index_to_symbol: Arc<RwLock<Vec<String>>>,
    periods: Arc<Vec<String>>,
    config: Arc<AggregateConfig>,
    mut shutdown_rx: watch::Receiver<bool>,
    _watchdog: Arc<WatchdogV2>,
) {
    info!(target: "持久化任务", "高优先级 Finalized-Writer 任务已启动 (Broadcast模式)");

    let buffer_max_size = config.persistence.finalized_buffer_size;
    let flush_interval = Duration::from_millis(config.persistence.finalized_flush_interval_ms);

    let mut buffer: Vec<super::KlineData> = Vec::with_capacity(buffer_max_size);
    let mut interval = tokio::time::interval(flush_interval);
    interval.set_missed_tick_behavior(tokio::time::MissedTickBehavior::Skip);

    loop {
        tokio::select! {
            // 优雅关闭分支 (逻辑不变)
            _ = shutdown_rx.changed() => {
                info!(target: "持久化任务", "收到关闭信号，开始优雅关闭高优先级持久化任务");
                // [修改] 在关闭时，使用 try_recv 循环排空通道
                loop {
                    match finalized_kline_rx.try_recv() {
                        Ok(kline) => buffer.push(kline),
                        Err(RecvError::Empty) => break, // 通道已空
                        Err(RecvError::Closed) => break, // 通道已关闭
                        Err(RecvError::Lagged(n)) => warn!(target: "持久化任务", count = n, "关闭时发现滞后，丢失了部分数据"),
                    }
                }

                if !buffer.is_empty() {
                    info!(target: "持久化任务", count = buffer.len(), "优雅关闭：持久化缓冲区中的剩余数据");
                    persist_kline_data(db.clone(), &buffer, &index_to_symbol, &periods).await;
                }
                break;
            }

            // [核心修改] 接收已完成的K线
            result = finalized_kline_rx.recv() => {
                match result {
                    Ok(kline) => {
                        buffer.push(kline);
                        if buffer.len() >= buffer_max_size {
                            trace!(target: "持久化任务", count = buffer.len(), "缓冲区已满，立即刷盘");
                            persist_kline_data(db.clone(), &buffer, &index_to_symbol, &periods).await;
                            buffer.clear();
                        }
                    },
                    Err(RecvError::Closed) => {
                        warn!(target: "持久化任务", "Finalized Kline 通道已关闭，任务退出");
                        break;
                    },
                    Err(RecvError::Lagged(skipped_count)) => {
                        error!(
                            target: "持久化任务",
                            log_type = "DATA_LOSS",
                            skipped = skipped_count,
                            "持久化任务处理缓慢，已丢失 finalized kline 数据！"
                        );
                    }
                }
            }

            // 定时刷盘 (逻辑不变)
            _ = interval.tick() => {
                if !buffer.is_empty() {
                    trace!(target: "持久化任务", count = buffer.len(), "定时刷盘");
                    persist_kline_data(db.clone(), &buffer, &index_to_symbol, &periods).await;
                    buffer.clear();
                }
            }
        }
    }
    warn!(target: "持久化任务", "高优先级 Finalized-Writer 任务已退出");
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Rust
IGNORE_WHEN_COPYING_END
第三步：修改 auditor.rs - 同样适配消费者

文件: src/klagg_sub_threads/auditor.rs

修改逻辑:
与上一步类似，修改 run_completeness_auditor_task 以消费 broadcast::Receiver 并处理所有可能的错误情况。

Generated rust
// 文件: src/klagg_sub_threads/auditor.rs

// ... (其他 use 语句)
use tokio::sync::{broadcast, watch}; // [修改] 引入 broadcast
use tokio::sync::broadcast::error::RecvError; // [新增] 引入 RecvError
use tokio::time::{interval, Duration};
// ... (其他 use 语句)

// ... (AuditStats 和 KlineAuditContext 结构体不变)

// [修改] 完整性审计器任务的实现 - 适配 broadcast channel
#[instrument(target = "数据完整性审计", skip_all, name = "completeness_auditor_task")]
pub async fn run_completeness_auditor_task(
    // [核心修改] 接收 broadcast::Receiver
    mut kline_rx: broadcast::Receiver<KlineData>,
    mut shutdown_rx: watch::Receiver<bool>,
) {
    info!(target: "数据完整性审计", "数据完整性审计器任务启动 (Broadcast模式)");
    
    let mut stats = AuditStats::default();
    let mut audit_contexts: HashMap<String, KlineAuditContext> = HashMap::new();
    let mut report_interval = interval(Duration::from_secs(300)); // 每5分钟报告一次
    
    loop {
        tokio::select! {
            // 检查关闭信号 (逻辑不变)
            _ = shutdown_rx.changed() => {
                if *shutdown_rx.borrow() {
                    info!(target: "数据完整性审计", "收到关闭信号，完整性审计器正在退出");
                    break;
                }
            },
            
            // [核心修改] 接收K线数据进行审计
            result = kline_rx.recv() => {
                match result {
                    Ok(kline) => {
                        debug!(
                            target: "数据完整性审计",
                            symbol = %kline.symbol,
                            period = %kline.period,
                            open_time = kline.open_time,
                            "收到K线数据进行审计"
                        );
                        stats.record_kline(&kline);
                        audit_kline_data(&kline, &mut audit_contexts, &mut stats);
                    },
                    Err(RecvError::Closed) => {
                        warn!(target: "数据完整性审计", "Finalized Kline 通道已关闭，审计器退出");
                        break;
                    },
                    Err(RecvError::Lagged(skipped_count)) => {
                        error!(
                            target: "数据完整性审计",
                            log_type = "DATA_LOSS",
                            skipped = skipped_count,
                            "完整性审计任务处理缓慢，已丢失 finalized kline 数据！"
                        );
                    }
                }
            },
            
            // 定期报告统计信息 (逻辑不变)
            _ = report_interval.tick() => {
                stats.log_summary();
            },
        }
    }
    
    stats.log_summary();
    info!(target: "数据完整性审计", "数据完整性审计器任务已退出");
}

// ... (audit_kline_data 和 get_period_interval_ms 函数不变)
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Rust
IGNORE_WHEN_COPYING_END
第四步：修改 klagg_sub_threads.rs (生产入口) - 启动双重审计

文件: src/bin/klagg_sub_threads.rs

修改逻辑:

解构 KlineAggregator::new 的返回值时，获取 finalized_kline_tx。

在 full-audit 模式下，分别为 finalized_writer_task 和 run_completeness_auditor_task 订阅 Receiver。

启动 run_completeness_auditor_task 任务。

Generated rust
// 文件: src/bin/klagg_sub_threads.rs

// ... (其他 use 语句)

async fn run_app(io_runtime: &Runtime) -> Result<()> {
    // ... (初始化逻辑)

    let (mut aggregator, mut outputs) = klagg::KlineAggregator::new(/* ... */).await?;
    let ws_cmd_rx = outputs.ws_cmd_rx;
    let trade_rx = outputs.trade_rx;
    // [修改] 获取 finalized_kline_tx (Sender)
    let finalized_kline_tx = outputs.finalized_kline_tx;

    // ... (其他任务启动逻辑)

    // [修改] 启动 Finalized-Writer 持久化任务 (高优先级)
    info!(target: "应用生命周期", "启动 Finalized-Writer 持久化任务 (高优先级)...");
    // [修改] 为持久化任务订阅一个 Receiver
    let finalized_kline_rx_for_persistence = finalized_kline_tx.subscribe();
    let finalized_persistence_handle = log::context::spawn_instrumented_on(
        klagg::finalized_writer_task(
            db.clone(),
            finalized_kline_rx_for_persistence, // <--- 传入订阅的 Receiver
            global_index_to_symbol.clone(),
            periods.clone(),
            config.clone(),
            shutdown_rx.clone(),
            watchdog.clone(),
        ),
        io_runtime,
    );

    // ... (snapshot_writer_task 和其他任务启动逻辑不变)

    // [核心修改] 在 full-audit 模式下，启动所有审计任务
    #[cfg(feature = "full-audit")]
    {
        info!(
            target: "应用生命周期",
            log_type = "audit_startup",
            "🔍 生产环境：启用 full-audit，正在启动所有审计任务..."
        );

        // --- 1. 启动生命周期校验器 (逻辑不变，但为了完整性包含在此) ---
        let lifecycle_event_rx_for_validator = outputs.lifecycle_event_tx.subscribe();
        let lifecycle_clock_rx = clock_tx.subscribe();
        info!(target: "应用生命周期", log_type = "audit_startup", "🚀 启动生命周期校验器任务...");
        log::context::spawn_instrumented_on(
            klagg::run_lifecycle_validator_task(
                lifecycle_event_rx_for_validator, 
                shutdown_rx.clone(),
                lifecycle_clock_rx
            ),
            io_runtime,
        );

        // --- 2. [新增] 启动数据完整性审计器 ---
        info!(target: "应用生命周期", log_type = "audit_startup", "🚀 启动数据完整性审计器任务...");
        // [新增] 为完整性审计器订阅一个 Receiver
        let finalized_kline_rx_for_auditor = finalized_kline_tx.subscribe();
        log::context::spawn_instrumented_on(
            klagg::run_completeness_auditor_task(
                finalized_kline_rx_for_auditor, // <--- 传入订阅的 Receiver
                shutdown_rx.clone()
            ),
            io_runtime,
        );


        info!(
            target: "应用生命周期",
            log_type = "audit_startup",
            "✅ 所有审计任务启动完成 - 生产环境现在具备完整的生命周期和数据完整性校验能力"
        );
    }
    
    // ... (后续逻辑不变)
    Ok(())
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Rust
IGNORE_WHEN_COPYING_END

注意：我将你之前确认的lifecycle_validator修改也一并整合了进来。

第五步：同步修改 klagg_visual_test.rs (测试入口)

文件: src/bin/klagg_visual_test.rs

修改逻辑:
与生产入口的修改完全对等，确保测试环境与生产环境的审计逻辑一致。

Generated rust
// 文件: src/bin/klagg_visual_test.rs

// ... (其他 use 语句)

async fn run_visual_test_app(
    io_runtime: &Runtime,
) -> Result<()> {
    // ... (初始化逻辑)

    let (mut aggregator, mut outputs) = klagg::KlineAggregator::new(/* ... */).await?;
    let ws_cmd_rx = outputs.ws_cmd_rx;
    let trade_rx = outputs.trade_rx;
    // [修改] 获取 finalized_kline_tx (Sender)
    let finalized_kline_tx = outputs.finalized_kline_tx;

    // [修改] 订阅一个 finalized kline 的 receiver 用于模拟消费者
    let mut finalized_kline_rx_for_drain = finalized_kline_tx.subscribe();

    // ... (其他任务启动逻辑)

    // [修改] 模拟消费任务现在从 broadcast receiver 接收
    tokio::spawn(async move {
        info!("启动模拟的 finalized_kline 消费者，防止通道阻塞 (Broadcast模式)");
        loop {
            use tokio::sync::broadcast::error::RecvError;
            match finalized_kline_rx_for_drain.recv().await {
                Ok(_) => { /* 什么也不做，只是消费消息 */ },
                Err(RecvError::Closed) => break,
                Err(RecvError::Lagged(_)) => { /* 在测试中可以忽略 */ }
            }
        }
        warn!("finalized_kline 通道已关闭，模拟消费者退出");
    });

    // [核心修改] 在 full-audit 模式下，启动所有审计任务
    #[cfg(feature = "full-audit")]
    {
        info!(
            target: "应用生命周期",
            log_type = "audit_startup",
            "🔍 可视化测试模式：启用 full-audit，正在启动所有审计任务..."
        );

        // --- 1. 启动生命周期校验器 ---
        let lifecycle_event_rx_for_validator = outputs.lifecycle_event_tx.subscribe();
        let lifecycle_clock_rx = clock_tx.subscribe();
        info!(target: "应用生命周期", log_type = "audit_startup", "🚀 启动生命周期校验器任务...");
        log::context::spawn_instrumented_on(
            klagg::run_lifecycle_validator_task(
                lifecycle_event_rx_for_validator,
                shutdown_rx.clone(),
                lifecycle_clock_rx
            ),
            io_runtime,
        );

        // --- 2. [新增] 启动数据完整性审计器 ---
        info!(target: "应用生命周期", log_type = "audit_startup", "🚀 启动数据完整性审计器任务...");
        let finalized_kline_rx_for_auditor = finalized_kline_tx.subscribe();
        log::context::spawn_instrumented_on(
            klagg::run_completeness_auditor_task(
                finalized_kline_rx_for_auditor,
                shutdown_rx.clone()
            ),
            io_runtime,
        );

        info!(
            target: "应用生命周期",
            log_type = "audit_startup",
            "✅ 所有审计任务启动完成 - 系统现在具备完整的审计能力"
        );
    }
    
    // ... (后续逻辑不变)
    Ok(())
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Rust
IGNORE_WHEN_COPYING_END

这份完整的方案解决了通道的消费问题，使得在生产审计模式下，持久化任务和数据完整性审计任务可以并行工作，共同消费已完成的K线数据。整个逻辑链条现在是完整且健壮的。