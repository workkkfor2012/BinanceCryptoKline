# 技术接口文档

## API接口

### BinanceApi客户端
```rust
// 初始化
let api = BinanceApi::new();

// 主要接口
api.get_trading_usdt_perpetual_symbols().await?;     // 获取U本位永续合约列表
api.download_continuous_klines(&task).await?;        // 下载连续合约K线
api.get_server_time().await?;                        // 获取服务器时间
```

### 核心数据结构
```rust
// 下载任务
pub struct DownloadTask {
    pub symbol: String,           // 交易对 (BTCUSDT)
    pub interval: String,         // 周期 (1m, 5m, 1h, 1d)
    pub start_time: Option<i64>,  // 开始时间戳(毫秒)
    pub end_time: Option<i64>,    // 结束时间戳(毫秒)
    pub limit: usize,            // 数量限制 (最大1000)
}

// K线数据
pub struct Kline {
    pub open_time: i64,           // 开盘时间戳(毫秒)
    pub open: String,             // 开盘价
    pub high: String,             // 最高价
    pub low: String,              // 最低价
    pub close: String,            // 收盘价
    pub volume: String,           // 成交量
    pub close_time: i64,          // 收盘时间戳(毫秒)
    pub quote_asset_volume: String, // 成交额
}
```

### 配置参数
- **端点**: https://fapi.binance.com (币安期货API)
- **超时**: 连接10秒，请求30秒
- **代理**: 自动检测SOCKS5代理
- **重试**: 关键接口最多5次重试

## WebSocket接口

### 连接配置
- **URL**: `wss://fstream.binance.com/ws`
- **代理**: SOCKS5 (127.0.0.1:1080)
- **TLS**: 支持加密连接
- **限制**: 每连接1个流

### 主要客户端

#### 1. 连续合约K线客户端
```rust
let config = ContinuousKlineConfig {
    use_proxy: true,
    proxy_addr: "127.0.0.1".to_string(),
    proxy_port: 1080,
    symbols: vec!["BTCUSDT".to_string()],
    intervals: vec!["1m".to_string()],
};
let client = ContinuousKlineClient::new(config, db);
client.start().await?;
```

**流格式**: `{pair}_perpetual@continuousKline_{interval}`
- 示例: `btcusdt_perpetual@continuousKline_1m`

#### 2. 归集交易客户端
```rust
let config = AggTradeConfig {
    use_proxy: true,
    proxy_addr: "127.0.0.1".to_string(),
    proxy_port: 1080,
    symbols: vec!["BTCUSDT".to_string()],
};
let client = AggTradeClient::new(config, db, intervals);
client.start().await?;
```

**流格式**: `{symbol}@aggTrade`
- 示例: `btcusdt@aggTrade`

### 连接特性
- **自动重连**: 断线自动重连
- **心跳检测**: 30秒超时，自动Ping
- **消息缓冲**: 1000条异步处理
- **并发连接**: 支持多连接

## 数据库接口

### 表结构

#### symbols表
```sql
CREATE TABLE symbols (
    symbol TEXT PRIMARY KEY,     -- 交易对 (BTCUSDT)
    base_asset TEXT,            -- 基础资产 (BTC)
    quote_asset TEXT,           -- 报价资产 (USDT)
    status TEXT,                -- 交易状态
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### K线数据表 (分表存储)
表名格式：`k_{symbol}_{interval}` (如: k_btc_1m)

```sql
CREATE TABLE k_{symbol}_{interval} (
    open_time INTEGER PRIMARY KEY,     -- 开盘时间戳(毫秒)
    open TEXT NOT NULL,                -- 开盘价
    high TEXT NOT NULL,                -- 最高价
    low TEXT NOT NULL,                 -- 最低价
    close TEXT NOT NULL,               -- 收盘价
    volume TEXT NOT NULL,              -- 成交量
    close_time INTEGER NOT NULL,       -- 收盘时间戳(毫秒)
    quote_asset_volume TEXT NOT NULL   -- 成交额
);
```

### 主要操作
```rust
// 保存K线数据
db.save_klines(symbol, interval, &klines)?;

// 获取最新时间戳
db.get_latest_kline_timestamp(symbol, interval)?;

// 获取K线数量
db.get_kline_count(symbol, interval)?;

// 查询最新K线
db.get_latest_klines(symbol, interval, limit)?;

// 查询时间范围K线
db.get_klines_in_range(symbol, interval, start_time, end_time)?;
```

### 表命名规则
- 交易对: `BTCUSDT` → `btc` (移除USDT，转小写)
- 周期: `1M` → `1m` (转小写)
- 表名: `k_{symbol}_{interval}`

### 配置
- **数据库**: SQLite with WAL mode
- **连接池**: 10个连接
- **写入队列**: 5000任务缓冲
- **价格字段**: TEXT类型保持精度

## 支持的时间周期
- `1m` - 1分钟
- `5m` - 5分钟  
- `30m` - 30分钟
- `1h` - 1小时
- `4h` - 4小时
- `1d` - 1天
- `1w` - 1周

## 工具函数

### 时间处理
```rust
// 时间间隔转毫秒
interval_to_milliseconds("1m") // → 60000

// 时间对齐
get_aligned_time(timestamp_ms, "1m") // → 对齐到分钟00秒
```

### 对齐规则
- **分钟K线**: 对齐到分钟00秒
- **小时K线**: 对齐到小时00分00秒  
- **日K线**: 对齐到UTC 00:00:00
- **周K线**: 对齐到周一UTC 00:00:00

## 错误处理
- **网络错误**: 自动重试(API接口)
- **连接失败**: 自动重连(WebSocket)
- **解析错误**: 记录并继续处理
- **数据库错误**: 记录并继续处理

## 性能特性
- **并发处理**: 多线程/异步处理
- **连接池**: 数据库连接复用
- **消息缓冲**: 异步批量处理
- **内存优化**: 高效数据转换
- **无锁设计**: 原子操作和通道通信

## 🐕 Cerberus 验证系统接口 (新增 - 2025-06-19)

### 系统概述
Cerberus 超级断言系统是一个运行时验证引擎，提供全方位的系统可靠性保障。采用"日志即规格"的设计理念，实现 AI 友好的偏差检测和报告机制。

### 核心接口

#### ValidationRule Trait
```rust
pub trait ValidationRule: Send + Sync {
    /// 规则唯一标识符
    fn id(&self) -> &'static str;

    /// 判断规则是否适用于当前验证上下文
    fn is_applicable(&self, context: &ValidationContext) -> bool;

    /// 执行验证逻辑
    fn validate(&self, context: &ValidationContext) -> ValidationResult;
}
```

#### 验证上下文
```rust
pub struct ValidationContext {
    pub target: String,                                    // 目标模块
    pub event_name: String,                               // 事件名称
    pub timestamp: i64,                                   // 时间戳(毫秒)
    pub fields: HashMap<String, serde_json::Value>,      // 事件字段
    pub span_data: Option<HashMap<String, String>>,      // Span数据
    pub trace_id: Option<String>,                         // 追踪ID
}
```

#### 验证结果
```rust
pub enum ValidationResult {
    Pass,                        // 验证通过
    Deviation(DeviationEvent),   // 检测到偏差
    Skip(String),               // 跳过验证(附带原因)
}
```

#### 偏差事件结构
```rust
pub struct DeviationEvent {
    pub rule_id: String,                                  // 规则ID
    pub deviation_type: String,                           // 偏差类型
    pub timestamp: i64,                                   // 发生时间戳
    pub evidence: HashMap<String, serde_json::Value>,     // 证据数据
}
```

### 验证规则列表

| 规则ID | 级别 | 描述 | 验证目标 |
|--------|------|------|----------|
| INGESTION_DATA_VALIDITY | Critical | 数据摄取有效性 | 价格范围、时间戳、数据完整性 |
| KLINE_OHLC_CONSISTENCY | Critical | K线逻辑一致性 | OHLC关系、成交量一致性 |
| BUFFER_SWAP_INTEGRITY | Critical | 缓冲区交换完整性 | 交换性能、操作完整性 |
| ROUTING_SUCCESS_RATE | Standard | 路由成功率 | 路由健康度、失败检测 |
| KLINE_OPEN_TIME_ACCURACY | Standard | K线时间准确性 | 时间对齐、周期一致性 |
| PERSISTENCE_DATA_CONSISTENCY | Standard | 持久化一致性 | 数据计数、事务完整性 |
| SYMBOL_INDEX_STABILITY | Diagnostic | 品种索引稳定性 | 索引稳定性、元数据完整性 |

### 配置接口
```rust
pub struct CerberusConfig {
    pub enabled: bool,                          // 是否启用验证
    pub performance_top_n: usize,               // 性能报告Top N
    pub state_ttl_seconds: u64,                 // 状态TTL(秒)
    pub max_validation_queue_size: usize,       // 验证队列最大大小
}

impl Default for CerberusConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            performance_top_n: 10,
            state_ttl_seconds: 3600,  // 1小时
            max_validation_queue_size: 10000,
        }
    }
}
```

### 使用示例

#### 基本集成
```rust
use kline_server::klaggregate::cerberus::{create_default_cerberus_layer};
use tracing_subscriber::{layer::SubscriberExt, Registry};

// 创建 Cerberus 验证层
let (cerberus_layer, cerberus_engine) = create_default_cerberus_layer();

// 集成到 tracing 系统
let subscriber = Registry::default()
    .with(cerberus_layer)
    .with(other_layers...);

tracing::subscriber::set_global_default(subscriber)?;

// 启动验证引擎
tokio::spawn(async move {
    cerberus_engine.start().await;
});
```

#### 自定义配置
```rust
use kline_server::klaggregate::cerberus::{create_cerberus_layer, CerberusConfig};

let config = CerberusConfig {
    enabled: true,
    performance_top_n: 20,
    state_ttl_seconds: 7200,  // 2小时
    max_validation_queue_size: 20000,
};

let (cerberus_layer, cerberus_engine) = create_cerberus_layer(config);
```

### 偏差事件格式

#### 标准偏差事件JSON
```json
{
  "event_type": "CERBERUS_DEVIATION",
  "rule_id": "INGESTION_DATA_VALIDITY",
  "deviation_type": "price_out_of_range",
  "timestamp": 1750314025339,
  "timestamp_iso": "2025-06-19T06:20:25.339Z",
  "evidence": {
    "received_price": 2000000.0,
    "symbol": "BTCUSDT",
    "valid_range": {
      "min": 0.0,
      "max": 1000000.0
    },
    "context": "数据摄取验证"
  }
}
```

#### K线逻辑错误示例
```json
{
  "event_type": "CERBERUS_DEVIATION",
  "rule_id": "KLINE_OHLC_CONSISTENCY",
  "deviation_type": "high_price_violation",
  "timestamp": 1750314025525,
  "timestamp_iso": "2025-06-19T06:20:25.525Z",
  "evidence": {
    "symbol": "ETHUSDT",
    "interval": "5m",
    "kline_state": {
      "open": 3000.0,
      "high": 2900.0,
      "low": 2800.0,
      "close": 2950.0
    },
    "violation": "high < open or high < close"
  }
}
```

### 性能指标

#### 验证性能
- **验证延迟**: < 1ms per validation
- **CPU开销**: < 0.1%
- **内存开销**: < 1%
- **队列处理**: 异步非阻塞

#### 状态管理性能
- **并发访问**: 基于 DashMap 的无锁设计
- **内存控制**: TTL 自动清理机制
- **状态隔离**: 每个验证上下文独立状态

### 监控接口

#### 性能统计
```rust
// 获取验证引擎性能报告
let performance_report = cerberus_engine.get_performance_report();

// 获取状态管理器统计
let state_count = cerberus_engine.get_state_stats();
```

#### 验证统计
- **验证规则执行次数**
- **偏差检测数量**
- **验证延迟分布**
- **状态管理器性能**

### 扩展接口

#### 自定义验证规则
```rust
use kline_server::klaggregate::cerberus::{ValidationRule, ValidationContext, ValidationResult};

pub struct CustomRule;

impl ValidationRule for CustomRule {
    fn id(&self) -> &'static str {
        "CUSTOM_VALIDATION_RULE"
    }

    fn is_applicable(&self, context: &ValidationContext) -> bool {
        context.target == "CustomModule" && context.event_name == "custom_event"
    }

    fn validate(&self, context: &ValidationContext) -> ValidationResult {
        // 自定义验证逻辑
        ValidationResult::Pass
    }
}
```

### 集成点

#### 主要验证触发点
1. **MarketDataIngestor**: 数据摄取验证
2. **SymbolKlineAggregator**: K线逻辑验证
3. **BufferedKlineStore**: 缓冲区验证
4. **TradeEventRouter**: 路由验证
5. **KlineDataPersistence**: 持久化验证
6. **SymbolMetadataRegistry**: 元数据验证

#### 事件格式要求
验证事件必须包含 `event_name` 字段：
```rust
tracing::info!(
    target: "ModuleName",
    event_name = "operation_completed",
    field1 = value1,
    field2 = value2,
    "描述信息"
);
```
