# æŠ€æœ¯æ¥å£æ–‡æ¡£

## APIæ¥å£

### BinanceApiå®¢æˆ·ç«¯
```rust
// åˆå§‹åŒ–
let api = BinanceApi::new();

// ä¸»è¦æ¥å£
api.get_trading_usdt_perpetual_symbols().await?;     // è·å–Uæœ¬ä½æ°¸ç»­åˆçº¦åˆ—è¡¨
api.download_continuous_klines(&task).await?;        // ä¸‹è½½è¿ç»­åˆçº¦Kçº¿
api.get_server_time().await?;                        // è·å–æœåŠ¡å™¨æ—¶é—´
```

### æ ¸å¿ƒæ•°æ®ç»“æ„
```rust
// ä¸‹è½½ä»»åŠ¡
pub struct DownloadTask {
    pub symbol: String,           // äº¤æ˜“å¯¹ (BTCUSDT)
    pub interval: String,         // å‘¨æœŸ (1m, 5m, 1h, 1d)
    pub start_time: Option<i64>,  // å¼€å§‹æ—¶é—´æˆ³(æ¯«ç§’)
    pub end_time: Option<i64>,    // ç»“æŸæ—¶é—´æˆ³(æ¯«ç§’)
    pub limit: usize,            // æ•°é‡é™åˆ¶ (æœ€å¤§1000)
}

// Kçº¿æ•°æ®
pub struct Kline {
    pub open_time: i64,           // å¼€ç›˜æ—¶é—´æˆ³(æ¯«ç§’)
    pub open: String,             // å¼€ç›˜ä»·
    pub high: String,             // æœ€é«˜ä»·
    pub low: String,              // æœ€ä½ä»·
    pub close: String,            // æ”¶ç›˜ä»·
    pub volume: String,           // æˆäº¤é‡
    pub close_time: i64,          // æ”¶ç›˜æ—¶é—´æˆ³(æ¯«ç§’)
    pub quote_asset_volume: String, // æˆäº¤é¢
}
```

### é…ç½®å‚æ•°
- **ç«¯ç‚¹**: https://fapi.binance.com (å¸å®‰æœŸè´§API)
- **è¶…æ—¶**: è¿æ¥10ç§’ï¼Œè¯·æ±‚30ç§’
- **ä»£ç†**: è‡ªåŠ¨æ£€æµ‹SOCKS5ä»£ç†
- **é‡è¯•**: å…³é”®æ¥å£æœ€å¤š5æ¬¡é‡è¯•

## WebSocketæ¥å£

### è¿æ¥é…ç½®
- **URL**: `wss://fstream.binance.com/ws`
- **ä»£ç†**: SOCKS5 (127.0.0.1:1080)
- **TLS**: æ”¯æŒåŠ å¯†è¿æ¥
- **é™åˆ¶**: æ¯è¿æ¥1ä¸ªæµ

### ä¸»è¦å®¢æˆ·ç«¯

#### 1. è¿ç»­åˆçº¦Kçº¿å®¢æˆ·ç«¯
```rust
let config = ContinuousKlineConfig {
    use_proxy: true,
    proxy_addr: "127.0.0.1".to_string(),
    proxy_port: 1080,
    symbols: vec!["BTCUSDT".to_string()],
    intervals: vec!["1m".to_string()],
};
let client = ContinuousKlineClient::new(config, db);
client.start().await?;
```

**æµæ ¼å¼**: `{pair}_perpetual@continuousKline_{interval}`
- ç¤ºä¾‹: `btcusdt_perpetual@continuousKline_1m`

#### 2. å½’é›†äº¤æ˜“å®¢æˆ·ç«¯
```rust
let config = AggTradeConfig {
    use_proxy: true,
    proxy_addr: "127.0.0.1".to_string(),
    proxy_port: 1080,
    symbols: vec!["BTCUSDT".to_string()],
};
let client = AggTradeClient::new(config, db, intervals);
client.start().await?;
```

**æµæ ¼å¼**: `{symbol}@aggTrade`
- ç¤ºä¾‹: `btcusdt@aggTrade`

### è¿æ¥ç‰¹æ€§
- **è‡ªåŠ¨é‡è¿**: æ–­çº¿è‡ªåŠ¨é‡è¿
- **å¿ƒè·³æ£€æµ‹**: 30ç§’è¶…æ—¶ï¼Œè‡ªåŠ¨Ping
- **æ¶ˆæ¯ç¼“å†²**: 1000æ¡å¼‚æ­¥å¤„ç†
- **å¹¶å‘è¿æ¥**: æ”¯æŒå¤šè¿æ¥

## æ•°æ®åº“æ¥å£

### è¡¨ç»“æ„

#### symbolsè¡¨
```sql
CREATE TABLE symbols (
    symbol TEXT PRIMARY KEY,     -- äº¤æ˜“å¯¹ (BTCUSDT)
    base_asset TEXT,            -- åŸºç¡€èµ„äº§ (BTC)
    quote_asset TEXT,           -- æŠ¥ä»·èµ„äº§ (USDT)
    status TEXT,                -- äº¤æ˜“çŠ¶æ€
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### Kçº¿æ•°æ®è¡¨ (åˆ†è¡¨å­˜å‚¨)
è¡¨åæ ¼å¼ï¼š`k_{symbol}_{interval}` (å¦‚: k_btc_1m)

```sql
CREATE TABLE k_{symbol}_{interval} (
    open_time INTEGER PRIMARY KEY,     -- å¼€ç›˜æ—¶é—´æˆ³(æ¯«ç§’)
    open TEXT NOT NULL,                -- å¼€ç›˜ä»·
    high TEXT NOT NULL,                -- æœ€é«˜ä»·
    low TEXT NOT NULL,                 -- æœ€ä½ä»·
    close TEXT NOT NULL,               -- æ”¶ç›˜ä»·
    volume TEXT NOT NULL,              -- æˆäº¤é‡
    close_time INTEGER NOT NULL,       -- æ”¶ç›˜æ—¶é—´æˆ³(æ¯«ç§’)
    quote_asset_volume TEXT NOT NULL   -- æˆäº¤é¢
);
```

### ä¸»è¦æ“ä½œ
```rust
// ä¿å­˜Kçº¿æ•°æ®
db.save_klines(symbol, interval, &klines)?;

// è·å–æœ€æ–°æ—¶é—´æˆ³
db.get_latest_kline_timestamp(symbol, interval)?;

// è·å–Kçº¿æ•°é‡
db.get_kline_count(symbol, interval)?;

// æŸ¥è¯¢æœ€æ–°Kçº¿
db.get_latest_klines(symbol, interval, limit)?;

// æŸ¥è¯¢æ—¶é—´èŒƒå›´Kçº¿
db.get_klines_in_range(symbol, interval, start_time, end_time)?;
```

### è¡¨å‘½åè§„åˆ™
- äº¤æ˜“å¯¹: `BTCUSDT` â†’ `btc` (ç§»é™¤USDTï¼Œè½¬å°å†™)
- å‘¨æœŸ: `1M` â†’ `1m` (è½¬å°å†™)
- è¡¨å: `k_{symbol}_{interval}`

### é…ç½®
- **æ•°æ®åº“**: SQLite with WAL mode
- **è¿æ¥æ± **: 10ä¸ªè¿æ¥
- **å†™å…¥é˜Ÿåˆ—**: 5000ä»»åŠ¡ç¼“å†²
- **ä»·æ ¼å­—æ®µ**: TEXTç±»å‹ä¿æŒç²¾åº¦

## æ”¯æŒçš„æ—¶é—´å‘¨æœŸ
- `1m` - 1åˆ†é’Ÿ
- `5m` - 5åˆ†é’Ÿ  
- `30m` - 30åˆ†é’Ÿ
- `1h` - 1å°æ—¶
- `4h` - 4å°æ—¶
- `1d` - 1å¤©
- `1w` - 1å‘¨

## å·¥å…·å‡½æ•°

### æ—¶é—´å¤„ç†
```rust
// æ—¶é—´é—´éš”è½¬æ¯«ç§’
interval_to_milliseconds("1m") // â†’ 60000

// æ—¶é—´å¯¹é½
get_aligned_time(timestamp_ms, "1m") // â†’ å¯¹é½åˆ°åˆ†é’Ÿ00ç§’
```

### å¯¹é½è§„åˆ™
- **åˆ†é’ŸKçº¿**: å¯¹é½åˆ°åˆ†é’Ÿ00ç§’
- **å°æ—¶Kçº¿**: å¯¹é½åˆ°å°æ—¶00åˆ†00ç§’  
- **æ—¥Kçº¿**: å¯¹é½åˆ°UTC 00:00:00
- **å‘¨Kçº¿**: å¯¹é½åˆ°å‘¨ä¸€UTC 00:00:00

## é”™è¯¯å¤„ç†
- **ç½‘ç»œé”™è¯¯**: è‡ªåŠ¨é‡è¯•(APIæ¥å£)
- **è¿æ¥å¤±è´¥**: è‡ªåŠ¨é‡è¿(WebSocket)
- **è§£æé”™è¯¯**: è®°å½•å¹¶ç»§ç»­å¤„ç†
- **æ•°æ®åº“é”™è¯¯**: è®°å½•å¹¶ç»§ç»­å¤„ç†

## æ€§èƒ½ç‰¹æ€§
- **å¹¶å‘å¤„ç†**: å¤šçº¿ç¨‹/å¼‚æ­¥å¤„ç†
- **è¿æ¥æ± **: æ•°æ®åº“è¿æ¥å¤ç”¨
- **æ¶ˆæ¯ç¼“å†²**: å¼‚æ­¥æ‰¹é‡å¤„ç†
- **å†…å­˜ä¼˜åŒ–**: é«˜æ•ˆæ•°æ®è½¬æ¢
- **æ— é”è®¾è®¡**: åŸå­æ“ä½œå’Œé€šé“é€šä¿¡

## ğŸ• Cerberus éªŒè¯ç³»ç»Ÿæ¥å£ (æ–°å¢ - 2025-06-19)

### ç³»ç»Ÿæ¦‚è¿°
Cerberus è¶…çº§æ–­è¨€ç³»ç»Ÿæ˜¯ä¸€ä¸ªè¿è¡Œæ—¶éªŒè¯å¼•æ“ï¼Œæä¾›å…¨æ–¹ä½çš„ç³»ç»Ÿå¯é æ€§ä¿éšœã€‚é‡‡ç”¨"æ—¥å¿—å³è§„æ ¼"çš„è®¾è®¡ç†å¿µï¼Œå®ç° AI å‹å¥½çš„åå·®æ£€æµ‹å’ŒæŠ¥å‘Šæœºåˆ¶ã€‚

### æ ¸å¿ƒæ¥å£

#### ValidationRule Trait
```rust
pub trait ValidationRule: Send + Sync {
    /// è§„åˆ™å”¯ä¸€æ ‡è¯†ç¬¦
    fn id(&self) -> &'static str;

    /// åˆ¤æ–­è§„åˆ™æ˜¯å¦é€‚ç”¨äºå½“å‰éªŒè¯ä¸Šä¸‹æ–‡
    fn is_applicable(&self, context: &ValidationContext) -> bool;

    /// æ‰§è¡ŒéªŒè¯é€»è¾‘
    fn validate(&self, context: &ValidationContext) -> ValidationResult;
}
```

#### éªŒè¯ä¸Šä¸‹æ–‡
```rust
pub struct ValidationContext {
    pub target: String,                                    // ç›®æ ‡æ¨¡å—
    pub event_name: String,                               // äº‹ä»¶åç§°
    pub timestamp: i64,                                   // æ—¶é—´æˆ³(æ¯«ç§’)
    pub fields: HashMap<String, serde_json::Value>,      // äº‹ä»¶å­—æ®µ
    pub span_data: Option<HashMap<String, String>>,      // Spanæ•°æ®
    pub trace_id: Option<String>,                         // è¿½è¸ªID
}
```

#### éªŒè¯ç»“æœ
```rust
pub enum ValidationResult {
    Pass,                        // éªŒè¯é€šè¿‡
    Deviation(DeviationEvent),   // æ£€æµ‹åˆ°åå·®
    Skip(String),               // è·³è¿‡éªŒè¯(é™„å¸¦åŸå› )
}
```

#### åå·®äº‹ä»¶ç»“æ„
```rust
pub struct DeviationEvent {
    pub rule_id: String,                                  // è§„åˆ™ID
    pub deviation_type: String,                           // åå·®ç±»å‹
    pub timestamp: i64,                                   // å‘ç”Ÿæ—¶é—´æˆ³
    pub evidence: HashMap<String, serde_json::Value>,     // è¯æ®æ•°æ®
}
```

### éªŒè¯è§„åˆ™åˆ—è¡¨

| è§„åˆ™ID | çº§åˆ« | æè¿° | éªŒè¯ç›®æ ‡ |
|--------|------|------|----------|
| INGESTION_DATA_VALIDITY | Critical | æ•°æ®æ‘„å–æœ‰æ•ˆæ€§ | ä»·æ ¼èŒƒå›´ã€æ—¶é—´æˆ³ã€æ•°æ®å®Œæ•´æ€§ |
| KLINE_OHLC_CONSISTENCY | Critical | Kçº¿é€»è¾‘ä¸€è‡´æ€§ | OHLCå…³ç³»ã€æˆäº¤é‡ä¸€è‡´æ€§ |
| BUFFER_SWAP_INTEGRITY | Critical | ç¼“å†²åŒºäº¤æ¢å®Œæ•´æ€§ | äº¤æ¢æ€§èƒ½ã€æ“ä½œå®Œæ•´æ€§ |
| ROUTING_SUCCESS_RATE | Standard | è·¯ç”±æˆåŠŸç‡ | è·¯ç”±å¥åº·åº¦ã€å¤±è´¥æ£€æµ‹ |
| KLINE_OPEN_TIME_ACCURACY | Standard | Kçº¿æ—¶é—´å‡†ç¡®æ€§ | æ—¶é—´å¯¹é½ã€å‘¨æœŸä¸€è‡´æ€§ |
| PERSISTENCE_DATA_CONSISTENCY | Standard | æŒä¹…åŒ–ä¸€è‡´æ€§ | æ•°æ®è®¡æ•°ã€äº‹åŠ¡å®Œæ•´æ€§ |
| SYMBOL_INDEX_STABILITY | Diagnostic | å“ç§ç´¢å¼•ç¨³å®šæ€§ | ç´¢å¼•ç¨³å®šæ€§ã€å…ƒæ•°æ®å®Œæ•´æ€§ |

### é…ç½®æ¥å£
```rust
pub struct CerberusConfig {
    pub enabled: bool,                          // æ˜¯å¦å¯ç”¨éªŒè¯
    pub performance_top_n: usize,               // æ€§èƒ½æŠ¥å‘ŠTop N
    pub state_ttl_seconds: u64,                 // çŠ¶æ€TTL(ç§’)
    pub max_validation_queue_size: usize,       // éªŒè¯é˜Ÿåˆ—æœ€å¤§å¤§å°
}

impl Default for CerberusConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            performance_top_n: 10,
            state_ttl_seconds: 3600,  // 1å°æ—¶
            max_validation_queue_size: 10000,
        }
    }
}
```

### ä½¿ç”¨ç¤ºä¾‹

#### åŸºæœ¬é›†æˆ
```rust
use kline_server::klaggregate::cerberus::{create_default_cerberus_layer};
use tracing_subscriber::{layer::SubscriberExt, Registry};

// åˆ›å»º Cerberus éªŒè¯å±‚
let (cerberus_layer, cerberus_engine) = create_default_cerberus_layer();

// é›†æˆåˆ° tracing ç³»ç»Ÿ
let subscriber = Registry::default()
    .with(cerberus_layer)
    .with(other_layers...);

tracing::subscriber::set_global_default(subscriber)?;

// å¯åŠ¨éªŒè¯å¼•æ“
tokio::spawn(async move {
    cerberus_engine.start().await;
});
```

#### è‡ªå®šä¹‰é…ç½®
```rust
use kline_server::klaggregate::cerberus::{create_cerberus_layer, CerberusConfig};

let config = CerberusConfig {
    enabled: true,
    performance_top_n: 20,
    state_ttl_seconds: 7200,  // 2å°æ—¶
    max_validation_queue_size: 20000,
};

let (cerberus_layer, cerberus_engine) = create_cerberus_layer(config);
```

### åå·®äº‹ä»¶æ ¼å¼

#### æ ‡å‡†åå·®äº‹ä»¶JSON
```json
{
  "event_type": "CERBERUS_DEVIATION",
  "rule_id": "INGESTION_DATA_VALIDITY",
  "deviation_type": "price_out_of_range",
  "timestamp": 1750314025339,
  "timestamp_iso": "2025-06-19T06:20:25.339Z",
  "evidence": {
    "received_price": 2000000.0,
    "symbol": "BTCUSDT",
    "valid_range": {
      "min": 0.0,
      "max": 1000000.0
    },
    "context": "æ•°æ®æ‘„å–éªŒè¯"
  }
}
```

#### Kçº¿é€»è¾‘é”™è¯¯ç¤ºä¾‹
```json
{
  "event_type": "CERBERUS_DEVIATION",
  "rule_id": "KLINE_OHLC_CONSISTENCY",
  "deviation_type": "high_price_violation",
  "timestamp": 1750314025525,
  "timestamp_iso": "2025-06-19T06:20:25.525Z",
  "evidence": {
    "symbol": "ETHUSDT",
    "interval": "5m",
    "kline_state": {
      "open": 3000.0,
      "high": 2900.0,
      "low": 2800.0,
      "close": 2950.0
    },
    "violation": "high < open or high < close"
  }
}
```

### æ€§èƒ½æŒ‡æ ‡

#### éªŒè¯æ€§èƒ½
- **éªŒè¯å»¶è¿Ÿ**: < 1ms per validation
- **CPUå¼€é”€**: < 0.1%
- **å†…å­˜å¼€é”€**: < 1%
- **é˜Ÿåˆ—å¤„ç†**: å¼‚æ­¥éé˜»å¡

#### çŠ¶æ€ç®¡ç†æ€§èƒ½
- **å¹¶å‘è®¿é—®**: åŸºäº DashMap çš„æ— é”è®¾è®¡
- **å†…å­˜æ§åˆ¶**: TTL è‡ªåŠ¨æ¸…ç†æœºåˆ¶
- **çŠ¶æ€éš”ç¦»**: æ¯ä¸ªéªŒè¯ä¸Šä¸‹æ–‡ç‹¬ç«‹çŠ¶æ€

### ç›‘æ§æ¥å£

#### æ€§èƒ½ç»Ÿè®¡
```rust
// è·å–éªŒè¯å¼•æ“æ€§èƒ½æŠ¥å‘Š
let performance_report = cerberus_engine.get_performance_report();

// è·å–çŠ¶æ€ç®¡ç†å™¨ç»Ÿè®¡
let state_count = cerberus_engine.get_state_stats();
```

#### éªŒè¯ç»Ÿè®¡
- **éªŒè¯è§„åˆ™æ‰§è¡Œæ¬¡æ•°**
- **åå·®æ£€æµ‹æ•°é‡**
- **éªŒè¯å»¶è¿Ÿåˆ†å¸ƒ**
- **çŠ¶æ€ç®¡ç†å™¨æ€§èƒ½**

### æ‰©å±•æ¥å£

#### è‡ªå®šä¹‰éªŒè¯è§„åˆ™
```rust
use kline_server::klaggregate::cerberus::{ValidationRule, ValidationContext, ValidationResult};

pub struct CustomRule;

impl ValidationRule for CustomRule {
    fn id(&self) -> &'static str {
        "CUSTOM_VALIDATION_RULE"
    }

    fn is_applicable(&self, context: &ValidationContext) -> bool {
        context.target == "CustomModule" && context.event_name == "custom_event"
    }

    fn validate(&self, context: &ValidationContext) -> ValidationResult {
        // è‡ªå®šä¹‰éªŒè¯é€»è¾‘
        ValidationResult::Pass
    }
}
```

### é›†æˆç‚¹

#### ä¸»è¦éªŒè¯è§¦å‘ç‚¹
1. **MarketDataIngestor**: æ•°æ®æ‘„å–éªŒè¯
2. **SymbolKlineAggregator**: Kçº¿é€»è¾‘éªŒè¯
3. **BufferedKlineStore**: ç¼“å†²åŒºéªŒè¯
4. **TradeEventRouter**: è·¯ç”±éªŒè¯
5. **KlineDataPersistence**: æŒä¹…åŒ–éªŒè¯
6. **SymbolMetadataRegistry**: å…ƒæ•°æ®éªŒè¯

#### äº‹ä»¶æ ¼å¼è¦æ±‚
éªŒè¯äº‹ä»¶å¿…é¡»åŒ…å« `event_name` å­—æ®µï¼š
```rust
tracing::info!(
    target: "ModuleName",
    event_name = "operation_completed",
    field1 = value1,
    field2 = value2,
    "æè¿°ä¿¡æ¯"
);
```
