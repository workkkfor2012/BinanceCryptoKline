# 新增四类监控埋点功能说明

## 概述

为了增强日志系统的诊断能力，我们在现有的AI日志系统基础上新增了四类专门的监控埋点，通过不同的`log_type`来区分各类监控事件。这些埋点将被`ProblemSummaryLayer`自动捕获并写入问题摘要文件，为AI提供多维度的系统"体检报告"。

## 四类新增埋点

### 1. 检查点 (Checkpoint) - `log_type="checkpoint"`

**用途**: 标记关键业务流程的重要阶段和里程碑

**使用场景**:
- 流程开始/结束
- 重要步骤完成
- 阶段性成果达成

**示例**:
```rust
// 流程开始
tracing::info!(log_type = "checkpoint", message = "Backfill process started.");

// 重要步骤完成
tracing::info!(log_type = "checkpoint", message = "Symbol acquisition complete.", count = all_symbols.len());

// 流程结束
tracing::info!(log_type = "checkpoint", message = "Backfill process finished.");
```

### 2. 状态快照 (Snapshot) - `log_type="snapshot"`

**用途**: 记录关键资源和系统状态的变化

**使用场景**:
- 数据库表状态变化
- 内存使用情况
- 连接池状态
- 队列长度变化

**示例**:
```rust
// 操作前状态
tracing::info!(
    log_type = "snapshot",
    name = "db_tables_before_creation",
    state = "before",
    existing_count = existing_tables.len(),
    expected_total = total_expected
);

// 操作后状态
tracing::info!(
    log_type = "snapshot",
    name = "db_tables_after_creation", 
    state = "after",
    created_count = created_count,
    final_total = created_count + existing_count
);
```

### 3. 性能断言 (Performance Assertion) - `log_type="assertion"`

**用途**: 检查系统性能指标是否在预期范围内

**使用场景**:
- API响应时间检查
- 数据库操作耗时检查
- 内存使用量检查
- 吞吐量检查

**示例**:
```rust
// API响应时间断言
const MAX_API_RESPONSE_TIME_MS: u128 = 15000;
soft_assert!(
    request_duration_ms <= MAX_API_RESPONSE_TIME_MS,
    message = "API请求响应时间过长。",
    expected_max_ms = MAX_API_RESPONSE_TIME_MS,
    actual_ms = request_duration_ms,
    symbol = task.symbol.clone(),
);

// 数据库写入性能断言
const MAX_AVG_WRITE_TIME_MS: f64 = 10.0;
soft_assert!(
    avg_time_per_kline_ms <= MAX_AVG_WRITE_TIME_MS,
    message = "数据库单条K线平均写入耗时过长。",
    expected_max_avg_ms = MAX_AVG_WRITE_TIME_MS,
    actual_avg_ms = avg_time_per_kline_ms,
    batch_size = klines.len(),
);
```

### 4. 业务逻辑断言 (Logic Assertion) - `log_type="assertion"`

**用途**: 检查业务逻辑和数据完整性

**使用场景**:
- 数据量合理性检查
- 业务规则验证
- 失败率检查
- 数据一致性检查

**示例**:
```rust
// 交易对数量检查
const MIN_EXPECTED_SYMBOLS: usize = 400;
soft_assert!(
    symbol_count >= MIN_EXPECTED_SYMBOLS,
    message = "获取到的交易对数量远低于预期。",
    expected_min = MIN_EXPECTED_SYMBOLS,
    actual_count = symbol_count,
);

// 任务失败率检查
const MAX_FAILURE_RATE: f32 = 0.1;
soft_assert!(
    failure_rate <= MAX_FAILURE_RATE,
    message = "任务失败率过高。",
    loop_name = loop_name.to_string(),
    failure_rate = failure_rate,
    failed_count = failed_tasks.len(),
    total_count = task_count,
);
```

## 技术实现

### ProblemSummaryLayer 增强

修改了`ProblemSummaryLayer`的过滤逻辑，现在会捕获：
- 所有WARN和ERROR级别的事件（原有功能）
- 所有`log_type`为`checkpoint`、`snapshot`或`assertion`的INFO级别事件（新增功能）

```rust
let is_problem = *level <= tracing::Level::WARN;

let log_type = attributes.get("log_type").and_then(|v| v.as_str());
let is_summary_event = match log_type {
    Some("checkpoint") | Some("snapshot") | Some("assertion") => true,
    _ => false,
};

if !is_problem && !is_summary_event {
    return; // 跳过不相关的事件
}
```

### soft_assert! 宏增强

更新了`soft_assert!`宏，自动设置`log_type="assertion"`：

```rust
#[macro_export]
macro_rules! soft_assert {
    ($condition:expr, message = $msg:expr, $($key:ident = $value:expr),+ $(,)?) => {
        if !$condition {
            tracing::warn!(
                log_type = "assertion",
                condition = stringify!($condition),
                message = $msg,
                $($key = $value),+
            );
        }
    };
}
```

## 已植入的埋点位置

### 检查点埋点
- `src/kldata/backfill.rs::run_once()` - 补齐流程的关键阶段

### 状态快照埋点  
- `src/kldata/backfill.rs::ensure_all_tables()` - 数据库表创建前后状态

### 性能断言埋点
- `src/klcommon/api.rs::download_continuous_klines()` - API响应时间检查
- `src/klcommon/db.rs::process_write_task_static()` - 数据库写入性能检查

### 业务逻辑断言埋点
- `src/kldata/backfill.rs::get_symbols()` - 交易对数量检查
- `src/kldata/backfill.rs::execute_tasks()` - 任务失败率检查

## 测试验证

运行测试程序验证功能：
```bash
cargo run --bin test_new_log_types
```

测试结果显示成功捕获了所有四类埋点事件：
- checkpoint(2) + snapshot(1) + assertion(1) + warn/error(2) = 6个事件

## 使用建议

1. **检查点**: 在关键业务流程的开始、重要步骤和结束时使用
2. **状态快照**: 在资源状态发生重要变化的前后使用
3. **性能断言**: 设置合理的性能阈值，避免过于严格导致误报
4. **业务逻辑断言**: 基于业务经验设置合理的数据范围和规则

这些埋点将极大增强AI调试系统的诊断能力，提供从宏观流程到微观性能的全方位问题线索。
