

最终版：日志系统修复与优化方案

你好，经过我们与你本地AI伙伴的共同分析和评估，我们已就日志字段丢失问题达成高度一致的结论，并制定了最终的修复方案。

1. 问题根源确认

我们的集体分析确认，问题的根源在于新重构的 TargetLogLayer 日志层 (src/klcommon/log/target_log.rs)。其采用的“扁平化”日志结构存在设计缺陷：

字段覆盖：将业务字段与元数据字段混合在同一层级，导致了关键的性能统计字段（如 延迟追赶_秒）被意外覆盖或丢失。

结构脆弱：依赖于在同一个 Map 上执行的 remove 和 insert 操作，使日志处理逻辑变得脆弱且难以维护。

2. 最终解决方案

我们将采用恢复嵌套式 fields 对象的方案，彻底解决此问题。正如我们和本地AI都确认的，这样做有以下明显优势：

结构清晰：将业务字段与元数据（timestamp, level 等）完全分离，杜绝键名冲突。

解析简便：固定的元数据结构和独立的 fields 对象，对下游任何日志分析工具都更加友好。

风险最低：此方案恢复了你系统原有的、更健壮的日志结构，是风险最小的修改。

请让你本地的AI应用以下最终修改：

文件: src/klcommon/log/target_log.rs

Generated rust
// 文件: src/klcommon/log/target_log.rs
// ... 其他代码保持不变 ...

// --- TargetLogLayer 实现 ---
pub struct TargetLogLayer;

impl TargetLogLayer {
    pub fn new() -> Self { Self }
}

impl<S> Layer<S> for TargetLogLayer
where
    S: Subscriber + for<'a> tracing_subscriber::registry::LookupSpan<'a>,
{
    fn on_event(&self, event: &Event<'_>, ctx: Context<'_, S>) {
        use crate::klcommon::log::JsonVisitor;
        use serde_json::{json, Value};
        use tracing::trace; // 建议在文件顶部添加

        // 1. 将所有业务字段收集到一个独立的 'fields_map' 中。
        //    例如 `总耗时_秒`, `延迟追赶_秒` 等都会在这里。
        let mut fields_map = serde_json::Map::new();
        let mut visitor = JsonVisitor(&mut fields_map);
        event.record(&mut visitor);

        // 2. 从业务字段中提取 'message'，如果不存在则使用元数据中的名称。
        //    这使得 info!(message="...", ...) 和 info!(..., "...") 两种写法都健壮。
        //    提取后，它将成为顶层 message，不再出现在 "fields" 对象中。
        let message = fields_map.remove("message")
            .and_then(|v| if let Value::String(s) = v { Some(s) } else { Some(v.to_string()) })
            .unwrap_or_else(|| event.metadata().name().to_string());

        // 3. 构建一个全新的、结构清晰的根JSON对象，只包含元数据。
        let mut root_map = serde_json::Map::new();
        root_map.insert("timestamp".to_string(), json!(chrono::Utc::now().to_rfc3339_opts(chrono::SecondsFormat::Millis, true)));
        root_map.insert("level".to_string(), json!(event.metadata().level().to_string()));
        root_map.insert("target".to_string(), json!(event.metadata().target()));
        root_map.insert("message".to_string(), json!(message));

        // 4. 获取并插入 span_path 到元数据中
        if let Some(span) = ctx.lookup_current() {
            let mut path = vec![];
            let mut current = Some(span);
            while let Some(s) = current {
                path.push(s.name());
                current = s.parent();
            }
            path.reverse();
            root_map.insert("span_path".to_string(), json!(path.join(" > ")));
        }

        // 5. 将剩余的所有业务字段作为一个嵌套对象放入 'fields' 键下。
        //    如果业务字段为空，则不添加 'fields' 键，保持日志整洁。
        if !fields_map.is_empty() {
            let fields_count = fields_map.len();
            root_map.insert("fields".to_string(), Value::Object(fields_map));
            // 可选：添加字段数量统计用于调试，正如本地AI建议。
            trace!(target: "target_log", fields_count, "业务字段已添加到日志");
        }

        // 6. 将最终的结构化对象序列化为字符串并发送
        let final_json = Value::Object(root_map);
        if let Ok(json_string) = serde_json::to_string(&final_json) {
            if let Some(sender) = &*TARGET_LOG_SENDER.lock().unwrap() {
                // 使用 try_send 避免在日志高峰期阻塞业务线程
                let _ = sender.try_send(json_string);
            }
        }
    }
}

