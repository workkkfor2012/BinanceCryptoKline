



1 目标: 将 run_clock_task 从一个依赖最短K线周期的模糊定时器，改造成一个严格对齐服务器时间“整分钟”的精准节拍器。

修改逻辑:

时钟任务不再关心K线周期，其唯一目标是计算下一个服务器时间的整分钟时间点（例如 14:31:00.000）。

使用 time_sync_manager.get_calibrated_server_time() 获取当前精确的服务器时间，计算到下一个整分钟点所需的休眠时间。

增加一个小的安全边际 CLOCK_SAFETY_MARGIN_MS (例如10ms)，确保唤醒后一定跨过了目标时间点。

休眠结束后，再次获取精确时间并作为“滴答”信号广播出去，确保所有Worker在几乎相同的时间点收到时钟事件。


2 目标: 解决时钟周期驱动的，新建K线  实现常数级复杂度的周期判断。

修改逻辑:

引入新数据结构: 在 Worker 中新增一个 period_to_kline_indices: Vec<Vec<usize>> 结构。period_to_kline_indices[i] 存储了所有属于第 i 个周期的K线在其主状态数组 kline_states 中的偏移量(offset)。

初始化索引: 在 Worker::new 中，一次性构建这个分桶索引。

重写 process_clock_tick:

不再盲目遍历所有K线。

改为遍历 N 个周期（N=7，一个很小的常数）。

对每个周期，通过时间戳取模运算判断该周期本身是否在当前时间点到期。

仅当某个周期到期时，才去遍历 period_to_kline_indices 中该周期对应的K线偏移量列表，并处理这些K线。

涉及文件: src/klagg_sub_threads/mod.rs




1.2 目标: 改造 Worker 的指令处理逻辑，使其在收到 AddSymbol 指令时，能立即为新品种创建“种子K线”，从而让其无缝融入时钟驱动的生命周期，无需等待第一笔交易的到来。

修改逻辑:

[更新] 丰富 WorkerCmd: 修改 AddSymbol 命令，使其能携带新品种被发现时的初始K线核心数据 (OHLCV)，而不仅仅是价格。



当收到 AddSymbol 指令时，使用保存的 last_clock_tick 和指令携带的初始K线数据，为该品种的所有周期生成对齐的、ohlcv齐全的“种子K线”。



涉及文件: src/klagg_sub_threads/mod.rs, src/bin/klagg_sub_threads.rs

局部代码修改:

Generated rust
// --- 在 src/klagg_sub_threads/mod.rs ---

// [更新] 定义一个结构体来承载新品种的初始K线数据
pub struct SeedKline {
    pub open: f64,
    pub high: f64,
    pub low: f64,
    pub close: f64,
    pub volume: f64,
}

// [更新] 修改 WorkerCmd 枚举
pub enum WorkerCmd {
    AddSymbol {
        symbol: String,
        global_index: usize,
        initial_kline: SeedKline, // <-- 更新字段，携带更完整的初始数据
        ack: oneshot::Sender<std::result::Result<(), String>>,
    },
    // ... 其他指令
}

// 修改 Worker 结构体，增加 last_clock_tick 字段
pub struct Worker {
    // ...
    last_clock_tick: i64, // 在 new() 中使用校准后的服务器时间初始化
    // ...
}

// 修改 process_command 方法
async fn process_command(&mut self, cmd: WorkerCmd) {
    match cmd {
        WorkerCmd::AddSymbol { symbol, global_index, initial_kline, ack } => {
            // [新增] 为新品种的所有周期创建并推送种子K线
            for period_idx in 0..num_periods {
                // ... 使用 self.last_clock_tick 和 initial_kline 创建种子K线
                // ... 更新 self.kline_states
                // ... 推送 self.pending_persistence
            }
            // ...
        }
    }
}


1.3 



