

版本: 2.3
日期: 2025年7月17日
目标: 指导将K线聚合服务从“交易驱动”模式升级为“时钟驱动”模式，以实现数据的绝对完整性、系统的健壮性，并规划高性能的运行时策略。

1. 背景与目标

当前的K线聚合服务依赖于实时的交易数据来创建和更新K线。这种模式在处理成交活跃的品种时工作良好，但对于成交稀疏的品种，或在服务中断重启后，会因长时间无交易或服务离线而导致K线序列出现“数据空洞”，即时间上的不连续。这对于需要连续时间序列的下游应用（如技术分析、策略回测）是致命缺陷。

本次重构的核心目标是解决此问题，将系统升级为时钟驱动模式，确保K线在时间维度上的绝对连续性，无论交易是否活跃、服务是否中断。

核心目标清单:

精确时钟驱动: 建立一个基于服务器校准时间的、精确到分钟的全局时钟节拍，作为K线生命周期管理的唯一驱动力。

健壮高效的启动: 实现服务在启动时从本地数据库高效地批量加载所有品种周期的最新K线状态，作为计算的初始“种子”。这避免了因大量请求外部API导致的速率超限风险，并保证了与持久化状态的绝对一致性，是崩溃恢复后数据不丢失的根本保障。

无缝填充空洞: 在时钟节PAI触发时，系统能自动检测并填充因无交易或服务停机而产生的K线空洞，保证时间序列的完整性。新生成的空洞K线将继承上一周期的收盘价，成交量为零。

无损数据持久化: 改造快照机制，确保在任何单次时钟周期内产生的所有K线（包括终结的、填充的、新生的）都能被完整、无遗漏地捕获并持久化到数据库。

新品种即时激活: 对于通过minitick等方式新发现的品种，系统应能立即为其创建“种子K线”，使其马上进入时钟驱动的生命周期，无需等待第一笔交易。

高性能时钟处理: 优化时钟事件的处理逻辑，避免在绝大多数时间点进行不必要的计算，确保系统在面临大规模品种时依然高效。

2. 重构步骤

目标: 将 run_clock_task 从一个依赖最短K线周期的模糊定时器，改造成一个严格对齐服务器时间“整分钟”的精准节拍器。

修改逻辑:

时钟任务不再关心K线周期，其唯一目标是计算下一个服务器时间的整分钟时间点（例如 14:31:00.000）。

使用 time_sync_manager.get_calibrated_server_time() 获取当前精确的服务器时间，计算到下一个整分钟点所需的休眠时间。

增加一个小的安全边际 CLOCK_SAFETY_MARGIN_MS (例如10ms)，确保唤醒后一定跨过了目标时间点。

休眠结束后，再次获取精确时间并作为“滴答”信号广播出去，确保所有Worker在几乎相同的时间点收到时钟事件。

涉及文件: src/bin/klagg_sub_threads.rs

局部代码修改:

Generated rust
/// 全局时钟任务
#[instrument(target = "全局时钟", skip_all, name="run_clock_task")]
async fn run_clock_task(
    _config: Arc<AggregateConfig>, // config 参数不再需要
    time_sync_manager: Arc<ServerTimeSyncManager>,
    clock_tx: watch::Sender<i64>,
    shutdown_notify: Arc<Notify>,
) {
    const TICK_INTERVAL_MS: i64 = 60_000;
    const CLOCK_SAFETY_MARGIN_MS: i64 = 10;
    const MIN_SLEEP_MS: i64 = 10;

    info!(target: "全局时钟", log_type="low_freq", interval_ms = TICK_INTERVAL_MS, "全局时钟任务已启动，按分钟发送节拍");

    // ... (时间同步有效性检查逻辑保持不变)

    loop {
        let now = time_sync_manager.get_calibrated_server_time();

        // 计算下一个整分钟的时间点
        let next_minute_point = (now / TICK_INTERVAL_MS + 1) * TICK_INTERVAL_MS;
        let wakeup_time = next_minute_point + CLOCK_SAFETY_MARGIN_MS;
        let sleep_duration_ms = (wakeup_time - now).max(MIN_SLEEP_MS) as u64;

        trace!(target: "全局时钟", now, next_minute_point, sleep_duration_ms, "计算下一次唤醒时间");

        tokio::select! {
            _ = sleep(Duration::from_millis(sleep_duration_ms)) => {
                let final_time = time_sync_manager.get_calibrated_server_time();
                if clock_tx.send(final_time).is_err() {
                    break;
                }
                trace!(target: "全局时钟", tick_time = final_time, "发送时钟滴答");
            }
            _ = shutdown_notify.notified() => {
                break;
            }
        }
    }
    warn!(target: "全局时钟", "全局时钟任务已退出");
}


目标: 在 run_app 主流程中，添加一个高效的步骤，用于在Worker创建之前，从本地数据库中批量获取所有品种、所有周期的最新一根K线数据。

修改逻辑:

数据源: 明确初始状态的数据源为本地数据库，而非外部API。这是保证服务崩溃恢复后能正确填充数据空洞的关键。

批量查询: 在 initialize_symbol_indexing 之后，调用一个新的辅助函数 fetch_initial_kline_states。此函数调用一个新的数据库接口 db.get_batch_latest_klines（需在DB层实现），获取所有需要的最新K线。

涉及文件: src/bin/klagg_sub_threads.rs (及 src/klcommon/db.rs)

局部代码修改:

Generated rust
// 在 run_app 函数中的 "let mut worker_read_handles..." 之前添加以下逻辑
// 4.1. [新增] 高效获取所有品种所有周期的初始K线状态
info!(target: "应用生命周期", log_type="low_freq", "正在从本地数据库批量获取所有品种的最新K线状态...");
let initial_kline_states = fetch_initial_kline_states(
    &db,
    &global_index_to_symbol.read().await,
    &periods
).await?;
info!(target: "应用生命周期", log_type="low_freq", "初始K线状态加载完成");

// 修改 Worker 创建循环中的 klagg::Worker::new 调用
// ...
let (mut worker, ws_cmd_rx, trade_rx) = klagg::Worker::new(
    worker_id,
    current_start_index,
    &assigned_symbols,
    &initial_kline_states, // <--- 新增此参数
    //...
)
.await?;
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Rust
IGNORE_WHEN_COPYING_END

目标: 修改 Worker::new 函数，使其能够接收并处理上一步加载的初始K线数据，并健壮地处理数据解析。

修改逻辑:

为 Worker::new 函数签名添加新参数 initial_kline_states。

在解析从数据库读取的K线数据时，进行严格校验，确保数据格式问题能被及时发现并报错（快速失败）。

[关键修改] 移除旧的 snapshot_buffers 和 active_buffer_index，引入新的 pending_persistence: Vec<KlineData> 成员，为步骤四的无损持久化做准备。

涉及文件: src/klagg_sub_threads/mod.rs

局部代码修改:

Generated rust
// 在 Worker 结构体定义中
pub struct Worker {
    // ... (其他字段)
    kline_states: Vec<KlineState>,
    // --- 移除 snapshot_buffers 和 active_buffer_index ---
    // --- 新增持久化缓冲区 ---
    pending_persistence: Vec<KlineData>,
    // ... (其他字段)
}

// 在 Worker::new 函数中
impl Worker {
    pub async fn new(
        // ...
        initial_kline_states: &HashMap<String, Vec<Option<DbKline>>>,
        // ...
    ) -> Result<(Self, /*...*/>) {
        // ...
        // [重大修改] 初始化可增长的待持久化向量，取代旧的双缓冲快照。
        let pending_persistence = Vec::with_capacity(1024);

        // ...
        // [循环] 为每个分配的品种和周期，使用 initial_kline_states 填充 kline_states
        // ...
        
        let worker = Self {
            // ...
            pending_persistence, // 使用新的持久化缓冲区
            // ...
        };
        Ok((worker, /*...*/))
    }
}




目标: 改造 Worker 的指令处理逻辑，使其在收到 AddSymbol 指令时，能立即为新品种创建“种子K线”，从而让其无缝融入时钟驱动的生命周期，无需等待第一笔交易的到来。

修改逻辑:

[更新] 丰富 WorkerCmd: 修改 AddSymbol 命令，使其能携带新品种被发现时的初始K线核心数据 (OHLCV)，而不仅仅是价格。

[更新] 改造 process_command:

在 Worker 中保存最近一次的时钟时间 last_clock_tick。此字段在 Worker::new 时，使用创建Worker那一刻的、经过校准的服务器时间进行初始化，确保其初始值的有效性。

当收到 AddSymbol 指令时，使用保存的 last_clock_tick 和指令携带的初始K线数据，为该品种的所有周期生成对齐的、成交量为零的“种子K线”。

将这些新创建的种子K线也推送到 pending_persistence 缓冲区。

涉及文件: src/klagg_sub_threads/mod.rs, src/bin/klagg_sub_threads.rs

局部代码修改:

Generated rust
// --- 在 src/klagg_sub_threads/mod.rs ---

// [更新] 定义一个结构体来承载新品种的初始K线数据
pub struct SeedKline {
    pub open: f64,
    pub high: f64,
    pub low: f64,
    pub close: f64,
    pub volume: f64,
}

// [更新] 修改 WorkerCmd 枚举
pub enum WorkerCmd {
    AddSymbol {
        symbol: String,
        global_index: usize,
        initial_kline: SeedKline, // <-- 更新字段，携带更完整的初始数据
        ack: oneshot::Sender<std::result::Result<(), String>>,
    },
    // ... 其他指令
}

// 修改 Worker 结构体，增加 last_clock_tick 字段
pub struct Worker {
    // ...
    last_clock_tick: i64, // 在 new() 中使用校准后的服务器时间初始化
    // ...
}

// 修改 process_command 方法
async fn process_command(&mut self, cmd: WorkerCmd) {
    match cmd {
        WorkerCmd::AddSymbol { symbol, global_index, initial_kline, ack } => {
            // [新增] 为新品种的所有周期创建并推送种子K线
            for period_idx in 0..num_periods {
                // ... 使用 self.last_clock_tick 和 initial_kline 创建种子K线
                // ... 更新 self.kline_states
                // ... 推送 self.pending_persistence
            }
            // ...
        }
    }
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Rust
IGNORE_WHEN_COPYING_END

目标: 解决步骤四中 process_clock_tick 的 O(N) 线性扫描在高负载下的性能隐患，用空间换时间的方式实现常数级复杂度的周期判断。

修改逻辑:

引入新数据结构: 在 Worker 中新增一个 period_to_kline_indices: Vec<Vec<usize>> 结构。period_to_kline_indices[i] 存储了所有属于第 i 个周期的K线在其主状态数组 kline_states 中的偏移量(offset)。

初始化索引: 在 Worker::new 中，一次性构建这个分桶索引。

重写 process_clock_tick:

不再盲目遍历所有K线。

改为遍历 N 个周期（N=7，一个很小的常数）。

对每个周期，通过时间戳取模运算判断该周期本身是否在当前时间点到期。

仅当某个周期到期时，才去遍历 period_to_kline_indices 中该周期对应的K线偏移量列表，并处理这些K线。

涉及文件: src/klagg_sub_threads/mod.rs

局部代码修改:

Generated rust
// 在 Worker 结构体定义中
pub struct Worker {
    // ...
    kline_states: Vec<KlineState>,
    pending_persistence: Vec<KlineData>,
    // [新增] 按周期分桶的索引
    period_to_kline_indices: Vec<Vec<usize>>,
    // ...
}

// 在 Worker::new 函数中
impl Worker {
    pub async fn new( /* ... */ ) -> Result<(Self, /*...*/>) {
        // ... (完成 kline_states 的初始化之后)

        // [新增] 构建分桶索引
        info!(target: "计算核心", log_type="low_freq", "正在构建按周期分桶的性能优化索引...");
        let mut period_to_kline_indices = vec![Vec::with_capacity(assigned_symbols.len()); num_periods];
        for (symbol_idx, _symbol) in assigned_symbols.iter().enumerate() {
            for period_idx in 0..num_periods {
                let kline_offset = symbol_idx * num_periods + period_idx;
                period_to_kline_indices[period_idx].push(kline_offset);
            }
        }
        info!(target: "计算核心", log_type="low_freq", "分桶索引构建完成");
        
        let worker = Self {
            // ...
            period_to_kline_indices,
            // ...
        };
        Ok((worker, /*...*/))
    }
}

// 在 Worker impl 块中，重写 process_clock_tick
#[instrument(target = "计算核心", level = "debug", skip(self), fields(current_time))]
fn process_clock_tick(&mut self, current_time: i64) {
    let num_periods = self.periods.len();
    self.last_clock_tick = current_time; // 更新最新的时钟时间

    // 1. 外层循环改为遍历周期 (常数次，如7次)
    for period_idx in 0..num_periods {
        let interval = &self.periods[period_idx];
        let interval_ms = interval_to_milliseconds(interval);

        // 2. 检查此周期本身是否到期
        if current_time > 0 && current_time % interval_ms == 0 {
            trace!(target: "计算核心", period=interval, "周期已到期，开始处理此周期的所有K线");
            
            // 3. 仅遍历此周期对应的K线列表
            for &kline_offset in &self.period_to_kline_indices[period_idx] {
                let kline = &mut self.kline_states[kline_offset];
                if !kline.is_initialized { continue; }

                // ... (此处填充空洞和创建新K线的逻辑与步骤四的内循环逻辑完全相同) ...
            }
        }
    }
}```

#### 3. 设计决策与备选方案

本节记录方案制定过程中的关键决策点和权衡。

*   **启动时批量加载性能 (步骤二)**
    在backfill补齐K线之后，内存中保留下载数据，必然会有所有品种的所有周期的最新1根K线，用于k线聚合启动。

*   **持久化任务的容错性 (步骤四)**
    *   **决策**: Worker 将待持久化数据发送给持久化任务后，不等待确认（ACK），直接清空本地缓冲区。
    *   **理由**: 业务上可接受在极端情况（如DB写入失败且服务在短时间内崩溃）下丢失一小部分最新的K线聚合数据。因为所有历史分钟线数据都可通过数据补齐服务从币安重新获取，数据并非“珍贵”到需要实现复杂的ACK/重试机制。此决策用可接受的微小数据丢失风险换取了系统设计的极大简化和高性能。

*   **[新增] 新品种初始状态的数据源可信度 (步骤五)**
    *   **决策**: 系统信任上游（如 `minitick` 服务）为 `AddSymbol` 指令提供的初始K线数据（`SeedKline`）是准确的，并直接使用它来创建“种子K线”。
    *   **理由**: 这明确了系统的职责边界。K线聚合服务的核心职责是“聚合”和“保证时间连续性”，而不是“校验原始数据的真伪”。数据源的准确性由提供该数据源的服务（最终追溯到交易所）来保证。这种关注点分离的原则让本服务的设计更内聚、更简单。如果上游数据有误，应由上游服务或数据补齐流程来修正。

*   **时钟处理性能权衡 (步骤六)**
    *   **决策**: 将“按周期分桶”作为明确的优化步骤引入。初始实现可以采用步骤四中简单的双重循环（保证逻辑正确性），随后或在性能压力测试后，切换到步骤六的优化实现。
    *   **理由**: 分桶方案是典型的空间换时间。它引入了额外的内存（`period_to_kline_indices`）和初始化开销，但将时钟滴答处理的复杂度从 O(所有K线) 降低到 O(到期周期的K线)。在绝大多数时间点（如 10:01），只有1m周期到期，性能提升显著。在最坏情况（如周一 00:00），性能与简单方案持平。这种优化对于未来扩展到更多交易对、保证系统响应性至关重要。
    *   **结论**: 将其作为独立的、可插拔的优化步骤，使得开发过程可以循序渐进，优先保证功能正确性，再按需部署性能优化。
