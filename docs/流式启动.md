
文档：流式启动架构最终方案 (v3.3 - 终版)

核心思想： 从“数据准备优先”的同步模式，彻底转变为“服务优先”的异步流式激活模式。

最终架构组件：

run_app (点火器): 职责极简。负责创建并启动 SymbolManager, ActivationDispatcher, Worker 等核心服务，然后进入等待状态。

SymbolManager (数据引擎与发现者): 常驻服务。负责管理所有交易对的生命周期（从发现到准备）。

内部包含 KlineBackfiller (处理存量品种) 和 NewSymbolDetector (处理新品种) 两个并行运行的异步任务。

是所有 ActivateSymbol 指令的唯一生产者。

ActivationDispatcher (激活调度器): 常驻服务。负责接收激活指令，并根据路由表将其分发给对应的 Worker。包含指令重试逻辑。

Worker (计算单元): 计算核心。空载启动，通过 ActivateSymbol 指令接收“初始大礼包”并流式激活交易对。

最终决策清单 (Final Decisions)

SymbolManager 内部调度:

决定: KlineBackfiller 和 NewSymbolDetector 作为两个并行的异步任务运行。它们各自完成数据准备后，将激活指令直接发送到同一个 activation_tx 通道。不引入额外的优先级队列。

理由: 并发模型足以处理，设计应保持简洁。

资源控制:

决定: SymbolManager 中历史数据下载的并发数设定为一个较低的可配置值（初始为 2 个品种），以避免在启动初期与核心 Worker 发生资源争抢。

SymbolManager 监控:

决定: SymbolManager 作为一个关键的常驻服务，必须实现 HealthReporter trait 并被 WatchdogV2 监控，特别是其内部的 NewSymbolDetector 的心跳。

“激活缝隙”数据一致性:

决定: 采用严格的时序控制解决该问题。

实施要点: ActivationDispatcher 在收到 Worker 对 ActivateSymbol 指令的成功 ack 确认后，再向该 Worker 对应的 I/O 任务发送指令，命令其订阅该品种的实时行情。

InitialSymbolData 时效性:

决定: 接受初始数据可能存在的秒级延迟，无需引入额外的“微型补齐”逻辑，以保持架构简洁。

Worker 激活失败处理:

决定: 激活失败的重试逻辑由 ActivationDispatcher 负责。

实施要点: Dispatcher 将对失败的激活指令重试 5 次。若最终失败，则记录一条 ERROR 级别的日志报警，无需将失败状态反馈给 SymbolManager。

通道容量:

决定: 为 activation_tx 通道增加冗余，容量从 1024 提升至 2048。

给本地 AI 的核心修改清单 (Core Modification Checklist for Local AI)

1. 新建/重构 SymbolManager 服务 (src/symbol_manager/mod.rs)
* 创建一个新的 SymbolManager 模块。
* 将 src/kldata/backfill.rs 的逻辑重构并移入，作为 SymbolManager 的 KlineBackfiller 子任务。
* 将 src/bin/klagg_sub_threads.rs 中的 run_symbol_manager (即 MiniTicker 逻辑) 移入，作为 NewSymbolDetector 子任务。
* 将 initialize_symbol_indexing 的逻辑移入，作为 SymbolManager 的初始化方法。
* 实现 HealthReporter trait。

2. 新建 ActivationDispatcher 服务 (src/activation_dispatcher/mod.rs)
* 创建一个新的 ActivationDispatcher 模块。
* 实现其核心分发与重试逻辑（如决策 #6 所述）。

3. 重构主启动流程 (src/bin/klagg_sub_threads.rs)
* 修改 run_app 函数:
* 移除所有旧的、同步的数据准备步骤 (backfiller.run_once(), run_micro_backfill 等)。
* 按照流式启动逻辑，实例化并启动 SymbolManager 和 ActivationDispatcher。
* 创建 Worker 时，不再传递任何初始 K 线数据。
* 将 activation_tx 通道容量设为 2048。
* 移除旧代码: 删除 run_micro_backfill 函数。

4. 改造 Worker (src/klagg_sub_threads/mod.rs)
* 添加 SymbolActivationState 枚举: Pending, Activating, Active, Failed。
* 修改 Worker 结构体: 新增 activation_states: Vec<SymbolActivationState> 字段。
* 修改 WorkerCmd 枚举: 移除 AddSymbol，添加新的 ActivateSymbol { symbol, initial_data, ack } 指令。
* 修改 Worker::new: 移除 initial_klines 参数，支持空载启动，初始化所有 activation_states 为 Pending。
* 修改 process_trade 和 process_clock_tick: 在处理逻辑前，必须检查对应品种的 activation_states 是否为 Active。
* 实现 process_command: 添加对 ActivateSymbol 指令的处理逻辑，包括状态切换和应用“初始大礼包”。

5. 改造 I/O 任务 (src/klagg_sub_threads/mod.rs)
* 修改 run_io_loop:
* 需要能够接收新的指令来动态订阅单个品种的行情。
* 修改 WsCmd 枚举，可以添加一个如 SubscribeOne(String) 的新变体。
* ActivationDispatcher 在激活成功后，会调用 Worker 的某个方法，最终将这个指令发送给对应的 I/O 任务。