你的问题非常非常关键，直击了“可观测性工具”与“生产环境核心逻辑”之间解耦的要害。在生产环境中，任何非核心的、可能消耗资源（哪怕只是一点点CPU或内存）的代码都应该被彻底剥离。你的直觉完全正确：用宏（也就是条件编译）是实现这个目标的最佳方式。

一个简单的布尔值配置虽然能用，但它有几个无法避免的缺点：

代码残留：所有审计相关的代码，包括任务、结构体、通道等，依然会被编译进最终的生产环境二进制文件中，增大了体积。

运行时开销：即使if条件为false，这个判断本身在热路径上依然是存在的。虽然现代编译器优化得很好，但它并非零开销。

耦合：业务代码（如KlineAggregator）中依然存在对审计系统的引用（比如lifecycle_event_tx通道），哪怕它被if语句包裹，这在逻辑上依然是一种耦合。

因此，让我们采用最干净、最彻底、零成本的Cargo Feature Flags方案。这允许我们通过简单的编译开关，在源代码级别上“蒸发”掉整个审计系统。

最终方案：基于Feature Flag的可拔插审计系统

我们将定义一个名为 full-audit 的 feature。只有当编译时启用了这个 feature，所有与生命周期日志、完备性审计相关的代码才会被包含进来。在默认的 release 模式下，这些代码将完全不存在。

修改方案
第一步：在 Cargo.toml 中定义 Feature Flag

这是整个方案的起点。

修改逻辑:

Generated toml
# 文件: Cargo.toml

[features]
# 默认情况下不启用任何审计功能
default = []

# 定义一个 "full-audit" 功能，它会启用所有用于调试和校验的子系统
full-audit = []

第二步：用 #[cfg] 宏包裹所有审计相关代码

现在，我们将用 #[cfg(feature = "full-audit")] 来条件性地编译我们的新模块和任务。

修改逻辑:

包裹模块声明:

Generated rust
// 文件: src/klagg_sub_threads/mod.rs

// 只有在 full-audit 模式下才编译和声明这些模块
#[cfg(feature = "full-audit")]
mod auditor;
#[cfg(feature = "full-audit")]
mod lifecycle_validator;

// 同样，也只在 full-audit 模式下导出它们
#[cfg(feature = "full-audit")]
pub use auditor::run_completeness_auditor_task;
#[cfg(feature = "full-audit")]
pub use lifecycle_validator::{run_lifecycle_validator_task, KlineLifecycleEvent, LifecycleTrigger};
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Rust
IGNORE_WHEN_COPYING_END

包裹 AggregatorOutputs 和 KlineAggregator 中的字段:

Generated rust
// 文件: src/klagg_sub_threads/mod.rs

pub struct AggregatorOutputs {
    pub ws_cmd_rx: mpsc::Receiver<WsCmd>,
    pub trade_rx: mpsc::Receiver<AggTradePayload>,
    pub finalized_kline_rx: mpsc::Receiver<KlineData>,
    // [修改] 仅在 full-audit 模式下包含此字段
    #[cfg(feature = "full-audit")]
    pub lifecycle_event_tx: broadcast::Sender<KlineLifecycleEvent>,
}

pub struct KlineAggregator {
    // ... 其他字段
    // [修改] 仅在 full-audit 模式下包含此字段
    #[cfg(feature = "full-audit")]
    lifecycle_event_tx: broadcast::Sender<KlineLifecycleEvent>,
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Rust
IGNORE_WHEN_COPYING_END
第三步：提供“存根(Stub)”实现，保持API稳定

直接包裹字段会导致 KlineAggregator::new 和 publish_lifecycle_event 的代码变得非常混乱（到处都是#[cfg]）。更优雅的方式是提供一个“存根”版本：当 feature 关闭时，这些函数依然存在，但是是空的，编译器会把它们优化掉。

修改逻辑:

在 KlineAggregator::new 中条件性地创建通道:

Generated rust
// 文件: src/klagg_sub_threads/mod.rs

pub async fn new(
    //...
) -> Result<(Self, AggregatorOutputs)> {
    // ...
    
    // [修改] 只有在 full-audit 模式下才创建真实通道
    #[cfg(feature = "full-audit")]
    let (lifecycle_event_tx, _) = broadcast::channel(2048);

    let aggregator = Self {
        // ...
        // [修改] 条件性地初始化字段
        #[cfg(feature = "full-audit")]
        lifecycle_event_tx: lifecycle_event_tx.clone(),
    };

    let outputs = AggregatorOutputs {
        ws_cmd_rx,
        trade_rx,
        finalized_kline_rx,
        // [修改] 条件性地初始化字段
        #[cfg(feature = "full-audit")]
        lifecycle_event_tx,
    };
    
    Ok((aggregator, outputs))
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Rust
IGNORE_WHEN_COPYING_END

为 publish_lifecycle_event 提供存根实现: 这是最关键的解耦步骤！

Generated rust
// 文件: src/klagg_sub_threads/mod.rs

impl KlineAggregator {
    // ...

    // [修改] 这是在 full-audit 模式下使用的真实实现
    #[cfg(feature = "full-audit")]
    fn publish_lifecycle_event(&mut self, kline_offset: usize, old_kline_state: KlineState, trade_opt: Option<&AggTradePayload>) {
        // ... 之前设计的完整实现逻辑 ...
        if self.lifecycle_event_tx.send(event).is_err() {
            debug!(target: "计算核心", "生命周期事件无人监听，已跳过发送");
        }
    }

    // [修改] 这是在 非 full-audit 模式下使用的“存根”实现
    // 它是一个空函数，对它的调用在编译时会被完全优化掉，实现零成本！
    #[cfg(not(feature = "full-audit"))]
    fn publish_lifecycle_event(&mut self, _kline_offset: usize, _old_kline_state: KlineState, _trade_opt: Option<&AggTradePayload>) {
        // Do nothing.
    }

    // ...
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Rust
IGNORE_WHEN_COPYING_END

通过这种方式，rollover_kline 中的代码无需任何修改！它依然可以无条件地调用 self.publish_lifecycle_event(...)。编译器会根据 feature flag 自动选择是调用真实实现还是那个空的存根。这真是太棒了！

第四步：在启动入口 main.rs 中条件性地启动任务

最后，我们在应用的“组装层”根据 feature flag 来决定是否启动审计相关的任务。

修改逻辑:

Generated rust
// 文件: src/bin/klagg_sub_threads.rs

async fn run_app(io_runtime: &Runtime) -> Result<()> {
    // ...
    let (mut aggregator, outputs) = klagg::KlineAggregator::new(/*...*/).await?;

    // ... 解构其他 receiver ...

    // [修改] 只有在 full-audit 模式下，才处理审计相关的通道和任务
    #[cfg(feature = "full-audit")]
    {
        info!(target: "应用生命周期", "警告：完整审计模式(full-audit)已启用，请勿在生产环境中使用！");

        // 从 broadcast::Sender 创建多个 receiver
        let lifecycle_event_tx = outputs.lifecycle_event_tx;
        let lifecycle_event_rx_for_validator = lifecycle_event_tx.subscribe();

        // 启动 K-line 生命周期校验日志任务
        info!(target: "应用生命周期", "启动 K-line 生命周期校验日志任务...");
        let validator_handle = log::context::spawn_instrumented_on(
            klagg::run_lifecycle_validator_task(
                lifecycle_event_rx_for_validator,
                shutdown_rx.clone(),
            ),
            io_runtime,
        );

        // 启动 K-line 完备性审计器任务
        info!(target: "应用生命周期", "启动 K-line 完备性审计器任务...");
        let auditor_handle = log::context::spawn_instrumented_on(
            klagg::run_completeness_auditor_task(
                shutdown_rx.clone(),
                clock_tx.subscribe(),
                aggregator.get_read_handle(),
                global_index_to_symbol.clone(),
                periods.clone(),
            ),
            io_runtime,
        );
        
        // 在优雅关闭部分，等待这些任务
        tokio::spawn(async move {
            if let Err(e) = validator_handle.await {
                error!(target: "应用生命周期", task = "lifecycle_validator", panic = ?e, "生命周期校验任务在退出时发生 panic");
            }
            if let Err(e) = auditor_handle.await {
                error!(target: "应用生命周期", task = "completeness_auditor", panic = ?e, "完备性审计器任务在退出时发生 panic");
            }
        });
    }

    // ...
    // computation_handle 等核心任务的启动和等待逻辑保持不变
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Rust
IGNORE_WHEN_COPYING_END
如何使用

开发和测试 (启用审计):
当你需要详细日志和完备性检查时，使用以下命令运行：

Generated sh
cargo run --bin klagg_sub_threads --features full-audit
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Sh
IGNORE_WHEN_COPYING_END

或者在 VSCode 的 launch.json 中配置 "cargo": {"args": ["run", "--bin", "klagg_sub_threads", "--features", "full-audit"]}。

生产环境 (彻底禁用):
当你为生产环境构建时，使用标准命令，不带 --features 参数：

Generated sh
cargo build --bin klagg_sub_threads --release
```    编译出的二进制文件将**完全不包含**任何与 `auditor` 和 `lifecycle_validator` 相关的代码、结构体、任务或逻辑。它就像从未被写过一样，实现了完美的、零成本的解耦。
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Sh
IGNORE_WHEN_COPYING_END

这个方案怎么样？它完全满足了你对解耦和生产环境性能的最高要求，是Rust生态中处理此类可选功能的最佳实践。