# 队列积压诊断代码说明

## 概述

为了诊断K线系统中可能存在的队列积压问题，我们添加了最小化的"创可贴"式诊断代码。这些代码都用 `[诊断日志开始]` 和 `[诊断日志结束]` 标记，方便事后完全移除。

## 修改的文件

### 1. src/klagg_sub_threads/mod.rs

**修改内容：**
- 将 `run_io_loop` 中的无界通道临时替换为超大容量的有界通道（500,000）
- 添加独立的监控任务，每5秒报告队列使用情况
- 修改消息处理器调用以支持有界通道

**关键监控指标：**
- 队列名称：`IO_to_Worker_Bridge`
- 容量：500,000
- 当前长度和使用百分比
- 超过50%时发出警告

### 2. src/klagg_sub_threads/gateway.rs

**修改内容：**
- 添加数据库写入队列监控
- 每5秒检查队列状态（使用trace级别避免刷屏）
- 超过80%使用率时发出警告

**关键监控指标：**
- 队列名称：`Gateway_to_DBWriter`
- 监控数据库写入队列的积压情况

### 3. src/klcommon/websocket.rs

**修改内容：**
- 为 `AggTradeMessageHandler` 添加有界通道支持
- 新增 `bounded_trade_sender` 字段
- 新增 `with_bounded_trade_sender` 构造函数
- 修改 `handle_message` 方法支持有界通道发送

## 如何使用

1. **启动系统：**
   ```powershell
   .\start_with_pipe_simple.ps1
   ```

2. **观察日志：**
   重点关注 `target: "队列监控"` 的日志输出，特别是：
   - `IO_to_Worker_Bridge` 队列的 `len` 和 `usage_percent`
   - `Gateway_to_DBWriter` 队列的状态

3. **判断积压：**
   - 如果 `IO_to_Worker_Bridge` 队列长度持续增长并维持在高位，说明I/O到Worker的数据传输存在瓶颈
   - 如果 `Gateway_to_DBWriter` 队列积压，说明数据库写入是瓶颈

## 如何移除诊断代码

### 步骤1：恢复 src/klagg_sub_threads/mod.rs

**位置1：第894-900行 - 通道创建**
```rust
// 删除这些行：
// [诊断日志开始]
// 1. 将无界通道临时替换为超大容量的有界通道，以便监控
// 诊断结束后，将下面这行改回:
// let (unbounded_tx, mut unbounded_rx) = tokio::sync::mpsc::unbounded_channel::<AggTradeData>();
const IO_BUFFER_CAPACITY: usize = 500_000; // 设置一个巨大的容量
let (bounded_tx, mut bounded_rx) = tokio::sync::mpsc::channel::<AggTradeData>(IO_BUFFER_CAPACITY);
// [诊断日志结束]

// 恢复为：
let (unbounded_tx, mut unbounded_rx) = tokio::sync::mpsc::unbounded_channel::<AggTradeData>();
```

**位置2：第904-916行 - 桥接任务中的定时日志**
```rust
// 删除这些行：
// [诊断日志开始]
// 2. 在消费数据的循环中，加入定时日志
let mut log_interval = tokio::time::interval(Duration::from_secs(5));
log_interval.set_missed_tick_behavior(tokio::time::MissedTickBehavior::Delay);
// [诊断日志结束]

// 以及在 tokio::select! 中删除：
// [诊断日志开始]
// 3. 定时器触发时，记录处理速率作为积压的间接指标
_ = log_interval.tick() => {
    // 这里我们只记录处理速率，作为积压的间接指标
    let messages_count = metrics_clone.messages_received.load(Ordering::Relaxed);
    trace!(target: "队列监控", worker_id, messages_processed = messages_count, "I/O桥接处理速率");
},
// [诊断日志结束]
```

**位置3：第934-967行 - 独立监控任务**
```rust
// 删除整个监控任务：
// [诊断日志开始]
// 4. 创建一个独立的、专门用于监控的异步任务
let monitor_tx = bounded_tx.clone();
tokio::spawn(async move {
    let mut log_interval = tokio::time::interval(Duration::from_secs(5));
    log_interval.set_missed_tick_behavior(tokio::time::MissedTickBehavior::Delay);
    loop {
        log_interval.tick().await;

        let queue_len = IO_BUFFER_CAPACITY - monitor_tx.capacity();
        let percentage = (queue_len as f32 / IO_BUFFER_CAPACITY as f32) * 100.0;

        info!(
            target: "队列监控",
            worker_id,
            queue_name = "IO_to_Worker_Bridge",
            len = queue_len,
            capacity = IO_BUFFER_CAPACITY,
            usage_percent = format!("{:.2}%", percentage),
            "I/O桥接队列状态"
        );

        if percentage > 50.0 {
            warn!(
                target: "队列监控",
                worker_id,
                queue_name = "IO_to_Worker_Bridge",
                len = queue_len,
                "I/O桥接队列使用率超过50%，可能存在严重积压！"
            );
        }
    }
});
// [诊断日志结束]
```

**位置4：第969-975行 - 消息处理器调用**
```rust
// 删除这些行：
// [诊断日志开始] - 使用有界通道版本的消息处理器
let handler = Arc::new(AggTradeMessageHandler::with_bounded_trade_sender(
    Arc::new(std::sync::atomic::AtomicUsize::new(0)),
    Arc::new(std::sync::atomic::AtomicUsize::new(0)),
    bounded_tx,
));
// [诊断日志结束]

// 恢复为：
let handler = Arc::new(AggTradeMessageHandler::with_trade_sender(
    Arc::new(std::sync::atomic::AtomicUsize::new(0)),
    Arc::new(std::sync::atomic::AtomicUsize::new(0)),
    unbounded_tx,
));
```

**位置5：第922行 - 接收器变量名**
```rust
// 将：
Some(trade) = bounded_rx.recv() => {

// 改回：
Some(trade) = unbounded_rx.recv() => {
```

### 步骤2：恢复 src/klagg_sub_threads/gateway.rs

**位置1：第17行 - 导入**
```rust
// 将：
use tracing::{debug, error, info, instrument, trace, warn};

// 改回：
use tracing::{debug, error, info, instrument, warn};
```

**位置2：第54-58行 - 监控初始化**
```rust
// 删除这些行：
// [诊断日志开始]
let db_queue_capacity = db_queue_tx.capacity();
let mut log_interval = tokio::time::interval(Duration::from_secs(5));
log_interval.set_missed_tick_behavior(tokio::time::MissedTickBehavior::Delay);
// [诊断日志结束]
```

**位置3：第61行 - 日志信息**
```rust
// 将：
info!(target: "网关任务", "网关任务已启动 (双缓冲模式)，Worker数量: {}, 总K线槽位: {}, DB队列容量: {}", num_workers, total_kline_slots, db_queue_capacity);

// 改回：
info!(target: "网关任务", "网关任务已启动 (双缓冲模式)，Worker数量: {}, 总K线槽位: {}", num_workers, total_kline_slots);
```

**位置4：第65-87行 - 主循环中的监控分支**
```rust
// 删除整个分支：
// [诊断日志开始]
_ = log_interval.tick() => {
    let db_queue_len = db_queue_capacity - db_queue_tx.capacity();
    let percentage = (db_queue_len as f32 / db_queue_capacity as f32) * 100.0;

    // 使用 trace 级别，只有在积压时才使用更高级别的日志，避免刷屏
    trace!(
        target: "队列监控",
        queue_name = "Gateway_to_DBWriter",
        len = db_queue_len,
        capacity = db_queue_capacity,
        usage_percent = format!("{:.2}%", percentage),
        "数据库写入队列状态"
    );

    if percentage > 80.0 {
        warn!(
            target: "队列监控",
            queue_name = "Gateway_to_DBWriter",
            len = db_queue_len,
            "数据库写入队列使用率超过80%!"
        );
    }
},
// [诊断日志结束]
```

### 步骤3：恢复 src/klcommon/websocket.rs

**位置1：第276-279行 - 结构体字段**
```rust
// 删除这些行：
// [诊断日志开始] - 临时添加有界通道支持
pub bounded_trade_sender: Option<tokio::sync::mpsc::Sender<AggTradeData>>,
// [诊断日志结束]
```

**位置2：第293-295行 - new方法**
```rust
// 删除这些行：
// [诊断日志开始]
bounded_trade_sender: None,
// [诊断日志结束]
```

**位置3：第309-311行 - with_trade_sender方法**
```rust
// 删除这些行：
// [诊断日志开始]
bounded_trade_sender: None,
// [诊断日志结束]
```

**位置4：第314-330行 - with_bounded_trade_sender方法**
```rust
// 删除整个方法：
// [诊断日志开始] - 临时添加有界通道支持
/// 创建带有有界交易数据发送器的消息处理器（仅用于诊断）
#[instrument(skip_all)]
pub fn with_bounded_trade_sender(
    message_count: Arc<std::sync::atomic::AtomicUsize>,
    error_count: Arc<std::sync::atomic::AtomicUsize>,
    bounded_trade_sender: tokio::sync::mpsc::Sender<AggTradeData>,
) -> Self {
    Self {
        message_count,
        error_count,
        trade_sender: None,
        bounded_trade_sender: Some(bounded_trade_sender),
    }
}
// [诊断日志结束]
```

**位置5：第392-411行 - handle_message方法中的发送逻辑**
```rust
// 删除这些行：
// 将归集交易数据发送给TradeEventRouter
let trade_data = AggTradeData::from_binance_raw(&agg_trade);

// [诊断日志开始] - 支持有界和无界通道
let send_result = if let Some(ref sender) = self.trade_sender {
    // 无界通道
    sender.send(trade_data).map_err(|e| format!("无界通道发送失败: {}", e))
} else if let Some(ref bounded_sender) = self.bounded_trade_sender {
    // 有界通道
    bounded_sender.try_send(trade_data).map_err(|e| format!("有界通道发送失败: {}", e))
} else {
    warn!(target: AGG_TRADE_TARGET, "没有配置交易数据发送器，跳过数据路由");
    Ok(())
};

if let Err(e) = send_result {
    error!(target: AGG_TRADE_TARGET, "发送归集交易数据失败: {}", e);
    self.error_count.fetch_add(1, std::sync::atomic::Ordering::Relaxed);
} else {
    debug!(target: AGG_TRADE_TARGET, "成功发送归集交易数据到路由器");
}
// [诊断日志结束]

// 恢复为原始版本：
// 将归集交易数据发送给TradeEventRouter
if let Some(ref sender) = self.trade_sender {
    // 直接使用本模块的AggTradeData::from_binance_raw方法转换
    let trade_data = AggTradeData::from_binance_raw(&agg_trade);

    // 发送到交易事件路由器
    if let Err(e) = sender.send(trade_data) {
        error!(target: AGG_TRADE_TARGET, "发送归集交易数据失败: {}", e);
        self.error_count.fetch_add(1, std::sync::atomic::Ordering::Relaxed);
    } else {
        debug!(target: AGG_TRADE_TARGET, "成功发送归集交易数据到路由器");
    }
} else {
    warn!(target: AGG_TRADE_TARGET, "没有配置交易数据发送器，跳过数据路由");
}
```

## 快速删除脚本

为了方便快速删除所有诊断代码，可以使用以下PowerShell脚本：

```powershell
# 快速删除诊断代码脚本
Write-Host "开始删除队列积压诊断代码..." -ForegroundColor Yellow

# 备份文件
Copy-Item "src\klagg_sub_threads\mod.rs" "src\klagg_sub_threads\mod.rs.backup"
Copy-Item "src\klagg_sub_threads\gateway.rs" "src\klagg_sub_threads\gateway.rs.backup"
Copy-Item "src\klcommon\websocket.rs" "src\klcommon\websocket.rs.backup"

Write-Host "已创建备份文件" -ForegroundColor Green

# 使用git恢复到诊断代码添加前的状态
# git checkout HEAD~1 -- src/klagg_sub_threads/mod.rs src/klagg_sub_threads/gateway.rs src/klcommon/websocket.rs

Write-Host "请手动按照文档删除标记为 [诊断日志开始] 到 [诊断日志结束] 的代码块" -ForegroundColor Cyan
Write-Host "删除完成后运行: cargo check" -ForegroundColor Cyan
```

## 验证删除是否完整

删除所有诊断代码后，运行以下命令验证：

```powershell
# 1. 编译检查
cargo check

# 2. 搜索是否还有诊断标记
Select-String -Path "src\klagg_sub_threads\mod.rs","src\klagg_sub_threads\gateway.rs","src\klcommon\websocket.rs" -Pattern "诊断日志"

# 3. 搜索是否还有队列监控相关代码
Select-String -Path "src\klagg_sub_threads\mod.rs","src\klagg_sub_threads\gateway.rs" -Pattern "队列监控"
```

如果搜索结果为空，说明删除完整。

## 预期的诊断结果

- **正常情况：** 队列使用率应该保持在较低水平（<10%）
- **I/O瓶颈：** `IO_to_Worker_Bridge` 队列持续积压
- **数据库瓶颈：** `Gateway_to_DBWriter` 队列积压
- **计算瓶颈：** I/O队列正常，但整体系统性能下降

根据诊断结果，可以针对性地优化相应的组件。

## 注意事项

1. **删除顺序：** 建议按照文档中的步骤顺序删除，避免编译错误
2. **备份重要：** 删除前务必备份修改的文件
3. **测试验证：** 删除后务必运行 `cargo check` 确保编译通过
4. **日志观察：** 删除后确认不再有 `target: "队列监控"` 的日志输出
