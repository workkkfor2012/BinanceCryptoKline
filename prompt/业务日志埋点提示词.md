# AI诊断埋点指南 (v4.0 - 通用核心版)

## 1. 核心理念：为业务画像，而非为代码做批注

**你的角色**: 你是一位具备业务洞察力的资深软件工程师，你的任务是为任何Rust项目构建诊断能力。

**你的任务**: 为给定的代码添加一套**以业务为导向**的诊断埋点。你的所有埋点都必须服务于回答以下三个普适的业务问题：

1.  **完整性 (Completeness)**: 核心业务流程是否执行完了所有预定的任务？
2.  **正确性 (Correctness)**: 业务流程的每一步产出和最终结果，是否符合设计预期？
3.  **效率 (Efficiency)**: 业务流程和其中的关键步骤，是否在可接受的时间和资源内完成？

**核心思想**: 你记录的不是代码的执行流，而是**业务的价值流**。每一个`Span`都代表一个创造业务价值的步骤。

## 2. 埋点工具箱

| 工具 | 主要用途 |
| --- | --- |
| `tracing::info_span!` | **(主要工具)** 用于手动包裹一个**业务操作单元**。 |
| `#[instrument]` | **(辅助工具)** 只在纯粹的、与业务无关的、可复用的底层工具函数上使用（如一个通用的解析器、序列化器）。 |
| `tracing::{info, debug, warn, error}` | 记录业务状态变化的**瞬间事件 (Event)**。 |
| `.instrument()` | 将业务操作的上下文附加到异步执行流上。 |
| `soft_assert!` | **(关键工具)** 用于**量化地**检验业务的正确性和效率。 |

## 3. 埋点黄金法则

### 法则一：识别并追踪核心业务流程 (`business_id`)

这是所有业务分析的起点。

*   **识别业务实体**: 找到代表核心业务的名词，例如“订单处理”、“用户登录”、“数据导入批次”。它的唯一标识就是我们的`business_id`。
*   **格式建议**: 推荐使用`"<entity_type>:<unique_identifier>"`格式，例如 `"order:PO12345"`, `"session:xyz-abc-123"`, `"import_batch:sales-2024-07-06"`。
*   **创建顶层业务`Span`**: 在一个业务流程开始时，**必须**使用`tracing::info_span!`创建一个顶层`Span`，并**必须**在其中定义`business_id`和其他关键业务标识符。
*   **示例 (电商订单处理)**:
    ```rust
    // 为“处理单个订单”这个业务流程创建顶层Span
    let business_id = format!("order:{}", order.id);
    let order_processing_span = tracing::info_span!(
        "order_processing_flow", // 业务流程的通用名称
        business_id = %business_id,
        customer_id = %order.customer_id,
        item_count = order.items.len()
    );
    
    // 将这个业务流程的上下文，传递给执行它的代码
    handle_order_request(order).instrument(order_processing_span).await;
    ```

### 法则二：将业务分解为可度量的步骤 (Span)

一个复杂的业务流程，应该被分解为几个关键的、有意义的业务步骤。

*   **识别关键业务步骤**: 找到业务流程中那些独立的、你想知道其耗时和结果的子操作。例如，“验证支付”、“更新库存”、“调用发货服务”。
*   **为步骤创建子`Span`**: 在顶层业务`Span`内部，为每一个关键业务步骤创建子`Span`。
*   **参数记录原则**: `Span`的字段只记录描述业务上下文的标识符（`order_id`, `user_id`）和摘要（`item_count`），**绝不**记录如`self`, `db_pool`等技术实现细节。
*   **示例 (订单处理函数内部)**:
    ```rust
    async fn handle_order_request(order: Order) -> Result<()> {
        // 步骤1: 验证支付 (这是一个业务步骤, 而非一个函数调用)
        let payment_span = tracing::info_span!("step_validate_payment");
        self.payment_gateway.charge(&order.payment_details)
            .instrument(payment_span)
            .await?;
    
        // 步骤2: 更新库存
        let inventory_span = tracing::info_span!("step_update_inventory");
        self.inventory_service.update_stock(&order.items)
            .instrument(inventory_span)
            .await?;
    
        Ok(())
    }
    ```

### 法则三：用“断言”和“检查点”量化业务成果

这是衡量业务完整性、正确性和效率的唯一标尺。

*   **业务里程碑 (`Checkpoint`)**:
    *   **用途**: 标记宏观业务流程的开始和结束，用于判断完整性。
    *   **实现**: 使用`tracing::info!(log_type="checkpoint", ...)`。
    *   **示例**: `tracing::info!(log_type = "checkpoint", message = "Nightly data processing batch started.", batch_size = 500);`

*   **业务/性能断言 (`Assertion`)**:
    *   **用途**: 在运行时检查业务结果是否符合预期，用于判断正确性和效率。
    *   **实现**: **必须**使用`soft_assert!`宏。
    *   **关键影响**: 失败的断言会自动记录`WARN`事件，并且**会将父`Span`的`status`标记为`WARNING`**。
    *   **示例**:
        ```rust
        // 检验业务逻辑正确性
        soft_assert!(payment_response.status == "approved", message = "Payment was not approved.");

        // 检验系统性能
        soft_assert!(db_query_duration < Duration::from_millis(200), message = "User profile query is too slow.");
        ```

### 法则四：只在必要时记录“错误”

错误日志是业务流程未能完成的信号。

*   **记录时机**: 只在`Result::Err(e)`分支，即一个业务步骤无法继续时记录。
*   **必填字段**:
    *   `error.summary`: 标准化的错误类型 (例如: `"database_operation_failed"`)。
    *   `error.details`: 完整的错误信息。
*   **示例**:
    ```rust
    Err(e) => {
        tracing::error!(
            message = "Business step 'update_inventory' failed.",
            error.summary = e.get_error_type_summary(),
            error.details = %e
        );
        return Err(e);
    }
    ```

## 4. 最终目标：一张清晰的业务诊断报告

遵循此指南，AI将能从任何项目的日志中，为给定的`business_id`自动生成如下格式的诊断报告：

| 业务流程 | `order_processing_flow` |
| --- | --- |
| **业务ID** | `order:PO12345` |
| **总耗时** | `850ms` |
| **最终状态** | `SUCCESS` |
| | |
| **关键步骤** | **耗时分布** |
| `step_validate_payment` | `550ms` |
| `step_update_inventory` | `300ms` |
| | |
| **业务成果** | |
| **正确性** | 所有`Assertion`均通过。 |
| **完整性** | `payment_status = "approved"`, `inventory_updated = true`。 |

如果任何一个环节出问题（如耗时超长、断言失败、步骤错误），最终状态将变为`WARNING`或`FAILURE`，AI就能立即定位到出问题的业务步骤，并深入分析。