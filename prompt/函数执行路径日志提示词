你好！你正在分析一份由我们的 TraceDistiller 系统生成的深度诊断报告。这份报告将程序的完整异步执行流程压缩并可视化为一棵“路径原型树”，旨在帮助你从0到1调试程序的逻辑正确性和性能瓶颈。
如何解读这份报告：
基本结构:
报告以一个根 Span (kline_service_app) 开始，代表整个应用的生命周期。
调用关系由缩进表示，子节点是父节点的直接调用。
(...) 内是耗时：(总耗时 | 自身耗时)。自身耗时高通常意味着该函数内部有密集的计算或阻塞操作。
[...] 内是 Span 创建时附加的字段，这是理解其上下文的关键。
🔥 标记了关键路径，即从根节点到最耗时叶子节点的路径。调试性能问题时请重点关注。
❌ 标记了包含错误的路径。调试 bug 时请重点关注。
核心概念：路径原型 (Loop Iteration Archetype):
当你看到一个标有 (循环) 的节点，如 initial_download_loop，它代表一个高频执行的循环。
其下的 路径原型 (出现 N 次, X%) 是对循环体内所有执行路径的聚合。
AI调试关键:
检查原型数量: 理想情况下应该只有少数几个原型（如一个成功原型，一两个错误原型）。如果出现大量低频次的原型，说明循环体内的行为非常不稳定，可能存在逻辑 bug。
分析成功原型: 查看其代表节点的调用树，确认业务逻辑是否符合预期。例如，download_kline_task 的子节点是否包含了 download_continuous_klines 和 save_klines？
分析失败原型 (❌): 这是调试的重点！
如何利用日志进行从0到1的调试:
场景一：某个交易对没有被下载
查看顶层决策: 找到 backfill_run_once Span，检查其下的 🎯 决策点 事件。
找到 decision=classify_symbols 事件，确认 outputs.new_symbols 和 outputs.existing_symbols 的数量是否合理。
如果一个预期的新币没有出现在 new_symbols_count 中，则问题出在最开始的符号收集和分类逻辑。调试方向：get_trading_usdt_perpetual_symbols 和符号过滤代码。
如果分类正确，但最终没有生成任务，检查 summarize_skipped_tasks 事件。如果该交易对出现在被跳过的统计中，说明“跳过”逻辑被触发。调试方向：create_task_for_existing_symbol 中的 if/else 条件。
场景二：程序发生 Panic 或返回严重错误
定位错误源头: 找到第一个被标记为 ❌ 的最深层节点，例如 ❌ download_continuous_klines(...)。
查看代码位置: 该节点的名称后面附带了文件名和行号，如 (src\klcommon\api.rs:262)，直接定位到源码。
分析错误上下文: 查看该节点附带的 💡 错误状态快照。这个快照聚合了其所有父节点的关键字段。
从 download_kline_task.symbol 确认是哪个交易对出的错。
从 initial_download_loop.task_count 确认当时的负载情况。
结合源码和上下文进行推理: “在处理 STEEMUSDT 时，api.rs 的 262 行出错了。根据快照，当时的总任务数是 876。错误信息是...”。这提供了一个完整的、可立即着手调查的 bug 报告。
场景三：逻辑不符合预期，但没有报错
检查路径原型: 查看 initial_download_loop 下的路径原型。是否出现了你不期望的执行路径？例如，你期望所有任务都包含 save_klines，但某个原型里却没有，说明数据没有被保存。
检查决策点: 查看 backfill_run_once 下的决策点事件。其中的输入输出计数是否符合你的心算结果？例如，inputs.api_symbols 是否等于 outputs.new_symbols + outputs.existing_symbols？如果不等，说明符号分类逻辑有 bug。
