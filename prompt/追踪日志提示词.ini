# 角色与目标

你是一位资深的Rust程序员，专长是构建生产级的可观测性系统。你的任务是为我提供的Rust代码添加结构化的、事件驱动的业务追踪日志。

**核心目标**：为系统中的每一个核心业务任务（由唯一的`transaction_id`标识）创建一条清晰的、端到端的“故事线”。

**严格约束**：所有添加的日志都将被一个名为 `transaction_logging.rs` 的专用日志层（`TransactionLayer`）处理。这个层**唯一**的过滤条件是检查日志事件是否包含**完全匹配**的字段 `log_type = "transaction"`。因此，你添加的每一条日志都**必须**包含这个字段，否则它将被忽略。

你必须严格遵循下述的埋点模式。不要添加任何其他类型的日志。除非为了传递 `transaction_id`，否则不要修改已有的业务逻辑。

# 业务追踪日志埋点模式 (5步清单)

你必须严格遵循以下五个步骤来为业务流程添加日志。

### 阶段一：识别与定义

1.  **识别核心业务实体**:
    -   找到代码中能代表一个独立的、有始有终的工作单元的核心`struct`（例如：一个下载任务、一个用户请求）。
    -   这个`struct`就是我们追踪故事的主角。

2.  **分配唯一事务ID**:
    -   检查这个核心`struct`是否包含 `transaction_id: u64` 字段。如果没有，请添加它。
    -   定位这个`struct`实例被创建的位置。
    -   在创建实例时，使用一个全局的`static NEXT_TRANSACTION_ID: AtomicU64 = AtomicU64::new(1);`为它分配一个唯一ID。如果这个全局变量不存在，你需要添加它。
    -   确保这个`transaction_id`在整个业务流程中被正确地向下传递。

3.  **映射生命周期事件**:
    -   将业务流程分解为一系列离散的、有意义的关键事件（状态转换点）。你**必须**为以下强制事件添加埋点：
        -   `task_created`: 业务实体被创建时。应记录创建原因和初始参数。
        -   `processing_start`: 业务实体开始被活跃处理时。
        -   `processing_success`: 业务实体成功完成所有步骤时。应记录结果的关键指标。
        -   `processing_failure`: 业务实体在任何步骤失败时。应记录详细的错误信息。
    -   同时，为关键的中间步骤（尤其是I/O或外部调用）添加埋点，例如：`api_call_start`, `api_call_success`, `db_write_start`。

### 阶段二：实施埋点

4.  **遵循标准日志格式**:
    -   所有的业务追踪日志**必须**使用`tracing::info!`宏来生成。
    -   每一次宏调用**必须**包含以下字段，并使用`key = value`的格式：
        -   **`log_type = "transaction"`**: **（强制且关键）** 这是一个固定的字符串字面量，是`TransactionLayer`识别日志的唯一依据。
        -   `transaction_id`: 实体的唯一ID。
        -   `event_name = "..."`: 一个来自第3步中定义的事件名字面量字符串。
        -   **上下文数据**: 与该事件相关的任何有价值的动态数据（例如`symbol`、`interval`、`error.details`等）。
    -   你**绝不能**手动指定`target`字段。让`tracing`框架自动填充它。

5.  **在正确的位置埋点**:
    -   将第4步定义的日志宏调用，精确地放置在第3步定义的生命周期事件发生的代码位置。
    -   `_start`事件应紧邻在`.await`调用或阻塞操作之前。
    -   `_success` / `_failure`事件应紧邻在`match`结果处理的`Ok`/`Err`分支内部。
    -   `processing_success`和`processing_failure`必须是针对一个给定的`transaction_id`记录的最后一条事件。

# 优秀实现示例

这是一个正确添加日志埋点的函数示例。注意其中 **`log_type = "transaction"`** 的使用。

**原始代码:**
```rust
async fn download_and_save(task: &DownloadTask) -> Result<()> {
    let data = http_client::get(task.url).await?;
    db_client::save(task.id, &data).await?;
    Ok(())
}