# Rust文件持续监控转换为txt脚本
$targetFolderName = "tempfold"

# 定义要监控的文件列表
$sourceFiles = @(
    "src\bin\kline_data_service.rs",
    "src\bin\kline_aggregate_service.rs",
    "src\kldata\backfill.rs",
    "src\klcommon\log\trace_distiller.rs",
    "src\klcommon\log\trace_visualization.rs",
    "src\klcommon\api.rs",
    "src\klcommon\db.rs",
    "src\klcommon\log\module_logging.rs",
    "src\klcommon\log\observability.rs"
)

$htmlFilePath = "src\weblog\static\index.html"
$currentPath = Get-Location

# 准备目标文件夹
$targetFolderPath = Join-Path -Path $currentPath -ChildPath $targetFolderName

if (Test-Path -Path $targetFolderPath -PathType Container) {
    Write-Host "清空目标文件夹..." -ForegroundColor Yellow
    Get-ChildItem -Path $targetFolderPath -Force | Remove-Item -Recurse -Force
} else {
    Write-Host "创建目标文件夹..." -ForegroundColor Yellow
    New-Item -Path $targetFolderPath -ItemType Directory | Out-Null
}

# 复制文件的函数
function Copy-FileToTxt {
    param(
        [string]$SourcePath,
        [string]$TargetFolder
    )

    if (Test-Path -Path $SourcePath -PathType Leaf) {
        $fileName = [System.IO.Path]::GetFileNameWithoutExtension($SourcePath)
        $extension = [System.IO.Path]::GetExtension($SourcePath)

        if ($extension -eq ".rs") {
            $newFileName = "$fileName.txt"
        } elseif ($extension -eq ".html") {
            $newFileName = "index.html"
        } else {
            $newFileName = "$fileName.txt"
        }

        $destinationPath = Join-Path -Path $TargetFolder -ChildPath $newFileName
        Copy-Item -Path $SourcePath -Destination $destinationPath -Force
        $timestamp = Get-Date -Format "HH:mm:ss"
        Write-Host "[$timestamp] ✅ 文件已更新: $SourcePath -> $newFileName" -ForegroundColor Green
        return $true
    }
    return $false
}

# 初始复制所有文件
Write-Host "开始初始复制..." -ForegroundColor Cyan
$copiedCount = 0
$notFoundFiles = @()

foreach ($filePath in $sourceFiles) {
    if (Copy-FileToTxt -SourcePath $filePath -TargetFolder $targetFolderPath) {
        $copiedCount++
    } else {
        $notFoundFiles += $filePath
        Write-Host "  ❌ 未找到: $filePath" -ForegroundColor Red
    }
}

# 复制HTML文件
if (Copy-FileToTxt -SourcePath $htmlFilePath -TargetFolder $targetFolderPath) {
    Write-Host "✅ HTML文件初始复制完成" -ForegroundColor Green
}

Write-Host "✅ 初始复制完成，成功复制 $copiedCount 个文件" -ForegroundColor Green
if ($notFoundFiles.Count -gt 0) {
    Write-Host "❌ 未找到 $($notFoundFiles.Count) 个文件" -ForegroundColor Red
}

# 创建文件监控器
Write-Host "`n🔍 开始监控文件变化..." -ForegroundColor Cyan
Write-Host "按 Ctrl+C 停止监控" -ForegroundColor Yellow

# 清理之前可能残留的事件订阅
Write-Host "  [清理] 清除之前的事件订阅..." -ForegroundColor Gray
Get-EventSubscriber | Where-Object { $_.SourceIdentifier -like "FileChanged_*" -or $_.SourceIdentifier -like "FileRenamed_*" } | Unregister-Event

# 将所有要监控的文件路径转换为绝对路径
$allFilesToWatch = $sourceFiles + @($htmlFilePath)
$watchedFiles = @{}

foreach ($file in $allFilesToWatch) {
    # 确保我们只处理存在的文件
    if (Test-Path -Path $file -PathType Leaf) {
        $absolutePath = (Resolve-Path $file).Path
        $watchedFiles[$absolutePath] = $file # 键: 绝对路径, 值: 原始相对路径
        Write-Host "  [准备监控] $absolutePath" -ForegroundColor Gray
    }
}

# 创建文件系统监控器
$watchers = @()

# 获取所有需要监控的目录 (并去重)
$dirsToWatch = @()
$watchedFiles.Keys | ForEach-Object {
    $dir = Split-Path -Path $_ -Parent
    if ($dirsToWatch -notcontains $dir) {
        $dirsToWatch += $dir
    }
}

# 为每个目录创建监控器
foreach ($dir in $dirsToWatch) {
    Write-Host "  [设置监控器] 目录: $dir" -ForegroundColor Gray
    $watcher = New-Object System.IO.FileSystemWatcher
    $watcher.Path = $dir
    $watcher.Filter = "*.*" # 监控所有文件，因为我们会在 action 中进行精确过滤

    # 同时监控内容写入、文件创建和重命名，以应对所有类型的编辑器保存操作
    $watcher.NotifyFilter = [System.IO.NotifyFilters]::LastWrite `
                         -bor [System.IO.NotifyFilters]::FileName

    # 定义事件处理器 (Action)
    $action = {
        $path = $Event.SourceEventArgs.FullPath
        $changeType = $Event.SourceEventArgs.ChangeType
        $timestamp = Get-Date -Format "HH:mm:ss"

        Write-Host "[$timestamp] ⚡ 事件触发: 类型[$changeType] 路径[$path]" -ForegroundColor DarkGray

        # 使用 $using: 访问主脚本中的变量
        $localWatchedFiles = $using:watchedFiles
        $localTargetFolder = $using:targetFolderPath

        # 检查发生变化的绝对路径是否在我们关心的文件列表中
        if ($localWatchedFiles.ContainsKey($path)) {

            # 短暂等待，确保文件已完全写入磁盘
            Start-Sleep -Milliseconds 200

            try {
                # 【核心修复】直接将绝对路径 $path 传递给函数
                & $using:Function:Copy-FileToTxt -SourcePath $path -TargetFolder $localTargetFolder
            } catch {
                Write-Host "[$timestamp] ❌ 在事件处理器中复制文件时出错: $($_.Exception.Message)" -ForegroundColor Red
            }
        }
    }

    # 注册 'Changed' 和 'Renamed' 事件。'Created' 通常会被 'Renamed' 覆盖，所以这两个足够了。
    # 使用 -SourceIdentifier 来给每个事件订阅一个唯一的名字，避免冲突
    $id_suffix = ($dir -replace '[^a-zA-Z0-9]', '_') # 创建一个合法的标识符
    Register-ObjectEvent -InputObject $watcher -EventName "Changed" -Action $action -SourceIdentifier "FileChanged_$id_suffix" | Out-Null
    Register-ObjectEvent -InputObject $watcher -EventName "Renamed" -Action $action -SourceIdentifier "FileRenamed_$id_suffix" | Out-Null

    $watcher.EnableRaisingEvents = $true
    $watchers += $watcher
}

try {
    # 保持脚本运行
    while ($true) {
        Start-Sleep -Seconds 1
    }
} finally {
    # 清理资源
    Write-Host "`n🛑 停止监控..." -ForegroundColor Yellow
    foreach ($watcher in $watchers) {
        if ($watcher -ne $null) {
            $watcher.EnableRaisingEvents = $false
            $watcher.Dispose()
        }
    }
    # 清理所有相关的事件订阅
    Get-EventSubscriber | Where-Object { $_.SourceIdentifier -like "FileChanged_*" -or $_.SourceIdentifier -like "FileRenamed_*" } | Unregister-Event
    Write-Host "✅ 监控已停止，资源已清理" -ForegroundColor Green
}
