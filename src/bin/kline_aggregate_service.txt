//! K线聚合服务启动文件
//!
//! 启动完整的K线聚合系统，包括数据接入、聚合、存储和持久化。

use kline_server::klaggregate::{KlineAggregateSystem, AggregateConfig};
use kline_server::klaggregate::observability::WebSocketLogForwardingLayer;
use kline_server::klcommon::{Result, AppError};
use std::path::Path;
use tokio::signal;
use tokio::time::{Duration};
use tracing::{instrument, info, error, warn, Instrument};
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt, Registry};
use chrono;

/// 默认配置文件路径
const DEFAULT_CONFIG_PATH: &str = "config/aggregate_config.toml";

#[tokio::main]
#[instrument(target = "KlineAggregateService")]
async fn main() -> Result<()> {
    println!("🚀 [DEBUG] K线聚合服务启动 - 开始执行main函数");

    // 处理命令行参数
    println!("🔧 [DEBUG] 步骤1: 处理命令行参数");
    if !handle_args() {
        println!("❌ [DEBUG] 命令行参数处理失败，退出程序");
        return Ok(());
    }
    println!("✅ [DEBUG] 命令行参数处理完成");

    // 初始化可观察性系统
    println!("🔧 [DEBUG] 步骤2: 初始化可观察性系统");
    match init_observability_system() {
        Ok(_) => println!("✅ [DEBUG] 可观察性系统初始化成功"),
        Err(e) => {
            println!("❌ [DEBUG] 可观察性系统初始化失败: {}", e);
            return Err(e);
        }
    }

    info!(target = "KlineAggregateService", event_name = "服务启动", "启动K线聚合服务...");

    // 加载配置
    println!("🔧 [DEBUG] 步骤3: 加载配置文件");
    let config = match load_config().await {
        Ok(config) => {
            println!("✅ [DEBUG] 配置文件加载成功");
            config
        }
        Err(e) => {
            println!("❌ [DEBUG] 配置文件加载失败: {}", e);
            return Err(e);
        }
    };
    info!(target = "KlineAggregateService", event_name = "配置加载完成", "配置加载完成");

    // 创建K线聚合系统
    println!("🔧 [DEBUG] 步骤4: 创建K线聚合系统");
    let system = match KlineAggregateSystem::new(config).await {
        Ok(system) => {
            println!("✅ [DEBUG] K线聚合系统创建成功");
            info!(target = "KlineAggregateService", event_name = "系统创建成功", "K线聚合系统创建成功");
            system
        }
        Err(e) => {
            println!("❌ [DEBUG] K线聚合系统创建失败: {}", e);
            error!(target = "KlineAggregateService", event_name = "系统创建失败", error = %e, "创建K线聚合系统失败");
            return Err(e);
        }
    };

    // 启动系统
    println!("🔧 [DEBUG] 步骤5: 启动K线聚合系统");
    if let Err(e) = system.start().await {
        println!("❌ [DEBUG] K线聚合系统启动失败: {}", e);
        error!(target = "KlineAggregateService", event_name = "系统启动失败", error = %e, "启动K线聚合系统失败");
        return Err(e);
    }
    println!("✅ [DEBUG] K线聚合系统启动成功");

    info!(target = "KlineAggregateService", event_name = "服务启动完成", "K线聚合服务启动完成");

    // 启动状态监控任务
    println!("🔧 [DEBUG] 步骤6: 启动状态监控任务");
    start_status_monitor(system.clone()).await;
    println!("✅ [DEBUG] 状态监控任务启动完成");

    // 启动测试日志任务
    println!("🔧 [DEBUG] 步骤7: 启动测试日志任务");
    start_test_logging().await;
    println!("✅ [DEBUG] 测试日志任务启动完成");

    // 等待关闭信号
    println!("🔧 [DEBUG] 步骤8: 等待关闭信号");
    println!("🎉 [DEBUG] K线聚合服务完全启动成功，开始等待关闭信号...");
    wait_for_shutdown_signal().await;

    // 优雅关闭
    info!(target = "KlineAggregateService", event_name = "收到关闭信号", "收到关闭信号，开始优雅关闭...");
    if let Err(e) = system.stop().await {
        error!(target = "KlineAggregateService", event_name = "系统停止失败", error = %e, "关闭K线聚合系统失败");
    } else {
        info!(target = "KlineAggregateService", event_name = "服务优雅关闭", "K线聚合服务已优雅关闭");
    }

    Ok(())
}

/// 初始化可观察性系统
fn init_observability_system() -> Result<()> {
    use std::sync::{Once, Mutex};

    // 使用更安全的方式存储初始化结果
    static OBSERVABILITY_INIT: Once = Once::new();
    static INIT_RESULT: Mutex<Option<bool>> = Mutex::new(None);

    let mut init_success = false;

    OBSERVABILITY_INIT.call_once(|| {
        match init_observability_system_inner() {
            Ok(_) => {
                init_success = true;
                if let Ok(mut result) = INIT_RESULT.lock() {
                    *result = Some(true);
                }
            }
            Err(e) => {
                eprintln!("可观察性系统初始化失败: {}", e);
                if let Ok(mut result) = INIT_RESULT.lock() {
                    *result = Some(false);
                }
            }
        }
    });

    // 检查初始化结果
    if let Ok(result) = INIT_RESULT.lock() {
        match *result {
            Some(true) => Ok(()),
            Some(false) => Err(AppError::ConfigError("可观察性系统初始化失败".to_string())),
            None => {
                // 如果是第一次调用且在call_once中成功了
                if init_success {
                    Ok(())
                } else {
                    Err(AppError::ConfigError("可观察性系统初始化状态未知".to_string()))
                }
            }
        }
    } else {
        Err(AppError::ConfigError("无法获取初始化状态".to_string()))
    }
}

/// 内部初始化函数，只会被调用一次
fn init_observability_system_inner() -> Result<()> {
    // 从配置文件读取日志设置，如果失败则使用环境变量或默认值
    let (log_level, log_transport, pipe_name) = match load_logging_config() {
        Ok((level, transport, pipe)) => (level, transport, pipe),
        Err(_) => {
            // 配置文件读取失败，使用环境变量或默认值
            let log_level = std::env::var("RUST_LOG").unwrap_or_else(|_| "trace".to_string());
            let log_transport = std::env::var("LOG_TRANSPORT").unwrap_or_else(|_| "named_pipe".to_string());
            let pipe_name = std::env::var("PIPE_NAME").unwrap_or_else(|_| r"\\.\pipe\kline_log_pipe".to_string());
            (log_level, log_transport, pipe_name)
        }
    };

    let log_forwarding_layer = match log_transport.as_str() {
        "named_pipe" => {
            WebSocketLogForwardingLayer::new_named_pipe(pipe_name.clone())
        }
        "websocket" => {
            let web_port = std::env::var("WEB_PORT")
                .unwrap_or_else(|_| "3000".to_string())
                .parse::<u16>()
                .unwrap_or(3000);
            WebSocketLogForwardingLayer::new_websocket(web_port)
        }
        _ => {
            WebSocketLogForwardingLayer::new_named_pipe(pipe_name.clone())
        }
    };

    // 设置tracing订阅器，遵循WebLog日志规范
    let init_result = match log_transport.as_str() {
        "named_pipe" => {
            // 命名管道模式：只发送JSON格式到WebLog，不使用控制台输出层
            Registry::default()
                .with(log_forwarding_layer) // 只有JSON格式发送到WebLog
                .with(create_env_filter(&log_level))
                .try_init()
        }
        _ => {
            // 其他模式：保持原有行为
            Registry::default()
                .with(log_forwarding_layer)
                .with(
                    tracing_subscriber::fmt::layer()
                        .with_target(true)
                        .with_level(true)
                ) // 添加控制台输出层（文本格式）
                .with(create_env_filter(&log_level))
                .try_init()
        }
    };

    // 检查tracing订阅器初始化结果并决定是否初始化LogTracer
    let tracing_init_success = match init_result {
        Ok(_) => {
            // tracing订阅器初始化成功，我们是第一个初始化的
            true
        }
        Err(e) => {
            // 如果已经初始化过，这是正常情况，不需要报错
            eprintln!("注意: tracing订阅器已存在: {}", e);
            false
        }
    };

    // 设置log到tracing的桥接，捕获第三方库的log日志
    // 尝试初始化LogTracer，无论tracing订阅器是否是我们初始化的
    match tracing_log::LogTracer::init_with_filter(log::LevelFilter::Warn) {
        Ok(_) => {
            // 初始化成功，设置了warn级别过滤
            tracing::debug!(target = "KlineAggregateService", event_name = "log桥接器初始化成功", "log桥接器初始化成功，第三方库日志过滤级别: warn");
        }
        Err(e) => {
            // 如果失败，尝试不带过滤器的初始化
            match tracing_log::LogTracer::init() {
                Ok(_) => {
                    tracing::debug!(target = "KlineAggregateService", event_name = "log桥接器初始化成功", "log桥接器初始化成功（无过滤器）");
                }
                Err(e2) => {
                    // 两种方式都失败，可能已经有其他logger
                    tracing::warn!(target = "KlineAggregateService", event_name = "log桥接器初始化失败",
                        error1 = %e, error2 = %e2,
                        "log桥接器初始化失败，可能已有其他logger。第三方库日志可能无法被过滤");
                }
            }
        }
    }

    // 等待一小段时间确保tracing系统完全初始化
    std::thread::sleep(std::time::Duration::from_millis(10));

    tracing::info!(target = "KlineAggregateService", event_name = "可观察性系统初始化完成", log_level = %log_level, "🔍 可观察性系统初始化完成，级别: {}", log_level);
    tracing::info!(target = "KlineAggregateService", event_name = "规格验证层状态", "📊 规格验证层已禁用，减少日志输出");
    tracing::info!(target = "KlineAggregateService", event_name = "日志传输配置", transport = %log_transport, "📡 日志传输方式: {}", log_transport);

    // 显示传输配置信息
    match log_transport.as_str() {
        "named_pipe" => {
            tracing::info!(target = "KlineAggregateService", event_name = "日志传输详情", transport_type = "named_pipe", pipe_name = %pipe_name, "📡 使用命名管道传输日志: {}", pipe_name);
        }
        "websocket" => {
            let web_port = std::env::var("WEB_PORT")
                .unwrap_or_else(|_| "3000".to_string())
                .parse::<u16>()
                .unwrap_or(3000);
            tracing::info!(target = "KlineAggregateService", event_name = "日志传输详情", transport_type = "websocket", web_port = web_port, "🌐 使用WebSocket传输日志，端口: {}", web_port);
        }
        _ => {
            tracing::warn!(target = "KlineAggregateService", event_name = "未知传输方式", configured_transport = %log_transport, "⚠️ 未知传输方式 '{}', 使用默认命名管道", log_transport);
        }
    }

    // 发送测试日志确保传输工作
    tracing::info!(target = "KlineAggregateService", event_name = "可观测性测试日志", test_id = 1, "🧪 测试日志1: 可观察性系统测试");
    tracing::warn!(target = "KlineAggregateService", event_name = "可观测性测试日志", test_id = 2, "🧪 测试日志2: 警告级别测试");
    tracing::error!(target = "KlineAggregateService", event_name = "可观测性测试日志", test_id = 3, "🧪 测试日志3: 错误级别测试");

    Ok(())
}

/// 加载日志配置
fn load_logging_config() -> Result<(String, String, String)> {
    let config_path = std::env::var("CONFIG_PATH").unwrap_or_else(|_| DEFAULT_CONFIG_PATH.to_string());

    if Path::new(&config_path).exists() {
        let config = AggregateConfig::from_file(&config_path)?;

        // 确保管道名称格式正确（Windows命名管道需要完整路径）
        let pipe_name = if config.logging.pipe_name.starts_with(r"\\.\pipe\") {
            config.logging.pipe_name
        } else {
            format!(r"\\.\pipe\{}", config.logging.pipe_name)
        };

        Ok((
            config.logging.log_level,
            config.logging.log_transport,
            pipe_name,
        ))
    } else {
        Err(AppError::ConfigError("配置文件不存在".to_string()))
    }
}

/// 加载配置
#[instrument(target = "KlineAggregateService", err)]
async fn load_config() -> Result<AggregateConfig> {
    let config_path = std::env::var("CONFIG_PATH").unwrap_or_else(|_| DEFAULT_CONFIG_PATH.to_string());
    
    if Path::new(&config_path).exists() {
        info!(target = "KlineAggregateService", event_name = "从文件加载配置", path = %config_path, "从文件加载配置: {}", config_path);
        AggregateConfig::from_file(&config_path)
    } else {
        warn!(target = "KlineAggregateService", event_name = "配置文件不存在", path = %config_path, "配置文件不存在: {}，使用默认配置", config_path);

        // 创建默认配置
        let config = AggregateConfig::default();

        // 尝试创建配置目录
        if let Some(parent) = Path::new(&config_path).parent() {
            if !parent.exists() {
                std::fs::create_dir_all(parent)
                    .map_err(|e| AppError::IoError(e))?;
            }
        }

        // 保存默认配置到文件
        if let Err(e) = config.save_to_file(&config_path) {
            warn!(target = "KlineAggregateService", event_name = "默认配置保存失败", path = %config_path, error = %e, "保存默认配置失败");
        } else {
            info!(target = "KlineAggregateService", event_name = "默认配置已保存", path = %config_path, "默认配置已保存到: {}", config_path);
        }
        
        Ok(config)
    }
}

/// 启动状态监控任务
async fn start_status_monitor(system: KlineAggregateSystem) {
    tokio::spawn(
        async move {
            let mut interval = tokio::time::interval(Duration::from_secs(60));

            loop {
                interval.tick().await;

                let status = system.get_status().await;
                info!(
                    target = "KlineAggregateService",
                    event_name = "系统状态报告",
                    total_symbols = status.total_symbols,
                    active_connections = status.active_connections,
                    buffer_swap_count = status.buffer_swap_count,
                    persistence_status = %status.persistence_status,
                    "系统状态报告"
                );
            }
        }.instrument(tracing::info_span!("status_monitor_task"))
    );
}

/// 启动测试日志任务（每10秒发送一次测试日志）
async fn start_test_logging() {
    tokio::spawn(
        async move {
            let mut interval = tokio::time::interval(Duration::from_secs(10));
            let mut counter = 0;

            loop {
                interval.tick().await;
                counter += 1;

                info!(
                    target = "KlineAggregateService",
                    event_name = "定期测试日志",
                    counter = counter,
                    timestamp = %chrono::Utc::now().format("%Y-%m-%d %H:%M:%S UTC"),
                    "🧪 定期测试日志 #{}: 系统运行正常",
                    counter
                );

                if counter % 3 == 0 {
                    warn!(target = "KlineAggregateService", event_name = "定期测试警告", counter = counter, "🧪 警告测试日志 #{}: 这是一个测试警告", counter);
                }
            }
        }.instrument(tracing::info_span!("periodic_test_log_task"))
    );
}

/// 等待关闭信号
async fn wait_for_shutdown_signal() {
    let ctrl_c = async {
        signal::ctrl_c()
            .await
            .expect("安装Ctrl+C处理器失败");
    };

    #[cfg(unix)]
    let terminate = async {
        signal::unix::signal(signal::unix::SignalKind::terminate())
            .expect("安装SIGTERM处理器失败")
            .recv()
            .await;
    };

    #[cfg(not(unix))]
    let terminate = std::future::pending::<()>();

    tokio::select! {
        _ = ctrl_c => {
            info!(target = "KlineAggregateService", event_name = "信号接收", signal = "Ctrl+C", "收到Ctrl+C信号");
        },
        _ = terminate => {
            info!(target = "KlineAggregateService", event_name = "信号接收", signal = "SIGTERM", "收到SIGTERM信号");
        },
    }
}

/// 显示帮助信息
fn show_help() {
    println!("K线聚合服务");
    println!();
    println!("用法:");
    println!("  kline_aggregate_service [选项]");
    println!();
    println!("选项:");
    println!("  -h, --help     显示此帮助信息");
    println!("  -v, --version  显示版本信息");
    println!();
    println!("环境变量:");
    println!("  CONFIG_PATH    配置文件路径 (默认: {})", DEFAULT_CONFIG_PATH);
    println!("  RUST_LOG       日志级别 (默认: trace)");
    println!();
    println!("示例:");
    println!("  # 使用默认配置启动");
    println!("  kline_aggregate_service");
    println!();
    println!("  # 使用自定义配置文件");
    println!("  CONFIG_PATH=my_config.toml kline_aggregate_service");
    println!();
    println!("  # 启用调试日志");
    println!("  RUST_LOG=debug kline_aggregate_service");
}

/// 显示版本信息
fn show_version() {
    println!("K线聚合服务 v{}", env!("CARGO_PKG_VERSION"));
}

/// 处理命令行参数
fn handle_args() -> bool {
    let args: Vec<String> = std::env::args().collect();

    for arg in &args[1..] {
        match arg.as_str() {
            "-h" | "--help" => {
                show_help();
                return false;
            }
            "-v" | "--version" => {
                show_version();
                return false;
            }
            _ => {
                eprintln!("未知参数: {}", arg);
                eprintln!("使用 --help 查看帮助信息");
                return false;
            }
        }
    }

    true
}

/// 创建环境过滤器，始终过滤掉第三方库的调试日志
fn create_env_filter(log_level: &str) -> tracing_subscriber::EnvFilter {
    // 无论应用日志级别如何，都过滤掉第三方库的噪音日志
    // 确保第三方库只显示warn和error级别的日志
    let filter_str = format!(
        "{},hyper=warn,reqwest=warn,tokio_tungstenite=warn,tungstenite=warn,rustls=warn,h2=warn,sqlx=warn,rusqlite=warn,tokio=warn,mio=warn,want=warn,tower=warn,fastwebsockets=warn,socks5=warn,webpki_roots=warn,ring=warn",
        log_level
    );

    tracing_subscriber::EnvFilter::new(filter_str)
}
