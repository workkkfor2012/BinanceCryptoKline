// K线数据服务主程序 - 专注于K线补齐功能
use kline_server::klcommon::{Database, Result};
use kline_server::kldata::KlineBackfiller;

use std::sync::Arc;
use tracing::{info, error, instrument, info_span, Instrument};

// ========================================
// 🔧 测试开关配置
// ========================================
/// 是否启用测试模式（限制为只处理 BTCUSDT）
const TEST_MODE: bool = true;

/// 测试模式下使用的交易对
const TEST_SYMBOLS: &[&str] = &["BTCUSDT"];
// ========================================

#[tokio::main]
async fn main() -> Result<()> {
    // K线周期配置
    let intervals = "1m,5m,30m,1h,4h,1d,1w".to_string();
    let interval_list = intervals.split(',').map(|s| s.trim().to_string()).collect::<Vec<String>>();

    // 初始化简单日志
    init_simple_logging();

    info!("启动K线数据补齐服务");
    info!("使用周期: {}", intervals);

    // 创建数据库连接
    let db_path = std::path::PathBuf::from("./data/klines.db");
    let db = Arc::new(Database::new(&db_path)?);

    // 执行K线数据补齐
    info!("开始补齐K线数据...");

    // 创建补齐器实例
    let backfiller = if TEST_MODE {
        info!("🔧 启用测试模式，限制交易对为: {:?}", TEST_SYMBOLS);
        KlineBackfiller::new_test_mode(
            db.clone(),
            interval_list,
            TEST_SYMBOLS.iter().map(|s| s.to_string()).collect()
        )
    } else {
        info!("📡 生产模式，将获取所有交易对");
        KlineBackfiller::new(db.clone(), interval_list)
    };

    // 运行一次性补齐流程
    match backfiller.run_once().await {
        Ok(_) => {
            info!("历史K线补齐完成");
        },
        Err(e) => {
            error!("历史K线补齐失败: {}", e);
            return Err(e);
        }
    }

    // 检查是否为WebSocket模式，如果是则保持服务运行
    let log_transport = std::env::var("LOG_TRANSPORT").unwrap_or_else(|_| "file".to_string());
    if log_transport == "websocket" {
        info!("WebSocket模式：保持服务运行以提供日志可视化...");
        info!("访问 http://localhost:3000/trace 查看函数执行路径可视化");

        // 定期生成一些测试日志以便观察
        let mut interval = tokio::time::interval(tokio::time::Duration::from_secs(10));
        loop {
            interval.tick().await;

            // 创建一个根 span 并设置 trace_id
            let trace_id = uuid::Uuid::new_v4().to_string();
            let root_span = info_span!(
                "kline_data_service_cycle",
                trace_id = %trace_id
            );

            // 在根 span 的上下文中执行测试
            async {
                test_span_logging().await;
            }.instrument(root_span).await;
        }
    } else {
        info!("K线数据补齐服务完成");
    }

    Ok(())
}

/// 测试span日志生成 - 用于演示路径可视化
#[instrument(target = "test_span", skip_all)]
async fn test_span_logging() {
    info!("开始测试span日志生成");

    // 模拟一些嵌套的函数调用
    test_database_operation().await;
    test_api_call().await;
    test_data_processing().await;

    info!("测试span日志生成完成");
}

#[instrument(target = "Database", skip_all)]
async fn test_database_operation() {
    info!("执行数据库操作");

    // 模拟数据库查询
    test_query_symbols().await;
    test_insert_klines().await;

    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
    info!("数据库操作完成");
}

#[instrument(target = "Database", skip_all)]
async fn test_query_symbols() {
    info!("查询交易对列表");
    tokio::time::sleep(tokio::time::Duration::from_millis(50)).await;
    info!("查询到 437 个交易对");
}

#[instrument(target = "Database", skip_all)]
async fn test_insert_klines() {
    info!("插入K线数据");
    tokio::time::sleep(tokio::time::Duration::from_millis(80)).await;
    info!("插入了 100 条K线记录");
}

#[instrument(target = "BinanceApi", skip_all)]
async fn test_api_call() {
    info!("调用币安API");

    // 模拟API调用
    test_get_exchange_info().await;
    test_get_klines().await;

    tokio::time::sleep(tokio::time::Duration::from_millis(200)).await;
    info!("API调用完成");
}

#[instrument(target = "BinanceApi", skip_all)]
async fn test_get_exchange_info() {
    info!("获取交易所信息");
    tokio::time::sleep(tokio::time::Duration::from_millis(120)).await;
    info!("获取交易所信息成功");
}

#[instrument(target = "BinanceApi", skip_all)]
async fn test_get_klines() {
    info!("获取K线数据");
    tokio::time::sleep(tokio::time::Duration::from_millis(150)).await;
    info!("获取到 1000 条K线数据");
}

#[instrument(target = "DataProcessor", skip_all)]
async fn test_data_processing() {
    info!("开始数据处理");

    // 模拟数据处理
    test_validate_data().await;
    test_transform_data().await;

    tokio::time::sleep(tokio::time::Duration::from_millis(80)).await;
    info!("数据处理完成");
}

#[instrument(target = "DataProcessor", skip_all)]
async fn test_validate_data() {
    info!("验证数据格式");
    tokio::time::sleep(tokio::time::Duration::from_millis(30)).await;
    info!("数据验证通过");
}

#[instrument(target = "DataProcessor", skip_all)]
async fn test_transform_data() {
    info!("转换数据格式");
    tokio::time::sleep(tokio::time::Duration::from_millis(40)).await;
    info!("数据转换完成");
}

/// 初始化日志系统（同时支持模块日志和trace可视化）
#[instrument(target = "kline_data_service", skip_all)]
fn init_simple_logging() {
    use kline_server::klcommon::log::{
        observability::UniversalLogForwardingLayer,
        trace_visualization::TraceVisualizationLayer,
    };
    use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt, Registry};

    // 确保日志目录存在
    std::fs::create_dir_all("logs").unwrap_or_else(|_| {
        // 日志目录创建失败，忽略错误
    });

    // 获取日志配置
    let log_level = std::env::var("RUST_LOG").unwrap_or_else(|_| "info".to_string());
    let log_transport = std::env::var("LOG_TRANSPORT").unwrap_or_else(|_| "file".to_string());
    let pipe_name = std::env::var("PIPE_NAME").unwrap_or_else(|_| r"\\.\pipe\kline_log_pipe".to_string());

    // 根据传输方式初始化日志
    match log_transport.as_str() {
        "named_pipe" => {
            // 命名管道模式 - 同时支持模块日志和trace可视化
            let observability_layer = UniversalLogForwardingLayer::new_named_pipe(pipe_name.clone());
            let trace_layer = TraceVisualizationLayer::new_named_pipe(pipe_name.clone());

            Registry::default()
                .with(observability_layer)  // 处理普通模块日志
                .with(trace_layer)          // 处理 span 日志用于路径可视化
                .with(create_env_filter(&log_level))
                .init();

            info!("双重日志系统已初始化（命名管道模式）");
            info!("- 模块日志: 按target分类显示");
            info!("- Trace可视化: 函数执行路径");
            info!("管道名称: {}", pipe_name);
        }
        "websocket" => {
            // WebSocket模式 - 同时支持模块日志和trace可视化
            let web_port = std::env::var("WEB_PORT")
                .unwrap_or_else(|_| "3000".to_string())
                .parse::<u16>()
                .unwrap_or(3000);

            let observability_layer = UniversalLogForwardingLayer::new_websocket(web_port);
            let trace_layer = TraceVisualizationLayer::new_websocket(web_port);

            Registry::default()
                .with(observability_layer)  // 处理普通模块日志
                .with(trace_layer)          // 处理 span 日志用于路径可视化
                .with(create_env_filter(&log_level))
                .init();

            info!("🚀 双重日志系统已初始化（WebSocket模式）");
            info!("📊 模块日志: 按target分类显示 (index.html)");
            info!("🔍 Trace可视化: 函数执行路径 (trace_viewer.html)");
            info!("🌐 WebSocket端口: {}", web_port);
        }
        _ => {
            // 文件模式（默认）
            tracing_subscriber::fmt()
                .with_env_filter(create_env_filter(&log_level))
                .with_target(true)
                .with_level(true)
                .with_timer(tracing_subscriber::fmt::time::UtcTime::rfc_3339())
                .init();

            info!("日志系统已初始化（文件模式）");
        }
    }

    info!("日志级别: {}", log_level);
}

/// 创建环境过滤器，始终过滤掉第三方库的调试日志
#[instrument(target = "kline_data_service", skip_all)]
fn create_env_filter(log_level: &str) -> tracing_subscriber::EnvFilter {
    // 无论应用日志级别如何，都过滤掉第三方库的噪音日志
    let filter_str = format!(
        "{},hyper=warn,reqwest=warn,tokio_tungstenite=warn,tungstenite=warn,rustls=warn,h2=warn,sqlx=warn,rusqlite=warn",
        log_level
    );

    tracing_subscriber::EnvFilter::new(filter_str)
}
