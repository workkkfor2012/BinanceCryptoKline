// Kçº¿æ•°æ®æœåŠ¡ä¸»ç¨‹åº - ä¸“æ³¨äºKçº¿è¡¥é½åŠŸèƒ½
use kline_server::klcommon::{Database, Result};
use kline_server::kldata::KlineBackfiller;

use std::sync::Arc;
use tracing::{info, error, instrument, info_span, Instrument};

// ========================================
// ğŸ”§ æµ‹è¯•å¼€å…³é…ç½®
// ========================================
/// æ˜¯å¦å¯ç”¨æµ‹è¯•æ¨¡å¼ï¼ˆé™åˆ¶ä¸ºåªå¤„ç† BTCUSDTï¼‰
const TEST_MODE: bool = true;

/// æµ‹è¯•æ¨¡å¼ä¸‹ä½¿ç”¨çš„äº¤æ˜“å¯¹
const TEST_SYMBOLS: &[&str] = &["BTCUSDT"];
// ========================================

#[tokio::main]
async fn main() -> Result<()> {
    // Kçº¿å‘¨æœŸé…ç½®
    let intervals = "1m,5m,30m,1h,4h,1d,1w".to_string();
    let interval_list = intervals.split(',').map(|s| s.trim().to_string()).collect::<Vec<String>>();

    // åˆå§‹åŒ–ç®€å•æ—¥å¿—
    init_simple_logging();

    info!("å¯åŠ¨Kçº¿æ•°æ®è¡¥é½æœåŠ¡");
    info!("ä½¿ç”¨å‘¨æœŸ: {}", intervals);

    // åˆ›å»ºæ•°æ®åº“è¿æ¥
    let db_path = std::path::PathBuf::from("./data/klines.db");
    let db = Arc::new(Database::new(&db_path)?);

    // æ‰§è¡ŒKçº¿æ•°æ®è¡¥é½
    info!("å¼€å§‹è¡¥é½Kçº¿æ•°æ®...");

    // åˆ›å»ºè¡¥é½å™¨å®ä¾‹
    let backfiller = if TEST_MODE {
        info!("ğŸ”§ å¯ç”¨æµ‹è¯•æ¨¡å¼ï¼Œé™åˆ¶äº¤æ˜“å¯¹ä¸º: {:?}", TEST_SYMBOLS);
        KlineBackfiller::new_test_mode(
            db.clone(),
            interval_list,
            TEST_SYMBOLS.iter().map(|s| s.to_string()).collect()
        )
    } else {
        info!("ğŸ“¡ ç”Ÿäº§æ¨¡å¼ï¼Œå°†è·å–æ‰€æœ‰äº¤æ˜“å¯¹");
        KlineBackfiller::new(db.clone(), interval_list)
    };

    // è¿è¡Œä¸€æ¬¡æ€§è¡¥é½æµç¨‹
    match backfiller.run_once().await {
        Ok(_) => {
            info!("å†å²Kçº¿è¡¥é½å®Œæˆ");
        },
        Err(e) => {
            error!("å†å²Kçº¿è¡¥é½å¤±è´¥: {}", e);
            return Err(e);
        }
    }

    // æ£€æŸ¥æ˜¯å¦ä¸ºWebSocketæ¨¡å¼ï¼Œå¦‚æœæ˜¯åˆ™ä¿æŒæœåŠ¡è¿è¡Œ
    let log_transport = std::env::var("LOG_TRANSPORT").unwrap_or_else(|_| "file".to_string());
    if log_transport == "websocket" {
        info!("WebSocketæ¨¡å¼ï¼šä¿æŒæœåŠ¡è¿è¡Œä»¥æä¾›æ—¥å¿—å¯è§†åŒ–...");
        info!("è®¿é—® http://localhost:3000/trace æŸ¥çœ‹å‡½æ•°æ‰§è¡Œè·¯å¾„å¯è§†åŒ–");

        // å®šæœŸç”Ÿæˆä¸€äº›æµ‹è¯•æ—¥å¿—ä»¥ä¾¿è§‚å¯Ÿ
        let mut interval = tokio::time::interval(tokio::time::Duration::from_secs(10));
        loop {
            interval.tick().await;

            // åˆ›å»ºä¸€ä¸ªæ ¹ span å¹¶è®¾ç½® trace_id
            let trace_id = uuid::Uuid::new_v4().to_string();
            let root_span = info_span!(
                "kline_data_service_cycle",
                trace_id = %trace_id
            );

            // åœ¨æ ¹ span çš„ä¸Šä¸‹æ–‡ä¸­æ‰§è¡Œæµ‹è¯•
            async {
                test_span_logging().await;
            }.instrument(root_span).await;
        }
    } else {
        info!("Kçº¿æ•°æ®è¡¥é½æœåŠ¡å®Œæˆ");
    }

    Ok(())
}

/// æµ‹è¯•spanæ—¥å¿—ç”Ÿæˆ - ç”¨äºæ¼”ç¤ºè·¯å¾„å¯è§†åŒ–
#[instrument(target = "test_span", skip_all)]
async fn test_span_logging() {
    info!("å¼€å§‹æµ‹è¯•spanæ—¥å¿—ç”Ÿæˆ");

    // æ¨¡æ‹Ÿä¸€äº›åµŒå¥—çš„å‡½æ•°è°ƒç”¨
    test_database_operation().await;
    test_api_call().await;
    test_data_processing().await;

    info!("æµ‹è¯•spanæ—¥å¿—ç”Ÿæˆå®Œæˆ");
}

#[instrument(target = "Database", skip_all)]
async fn test_database_operation() {
    info!("æ‰§è¡Œæ•°æ®åº“æ“ä½œ");

    // æ¨¡æ‹Ÿæ•°æ®åº“æŸ¥è¯¢
    test_query_symbols().await;
    test_insert_klines().await;

    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
    info!("æ•°æ®åº“æ“ä½œå®Œæˆ");
}

#[instrument(target = "Database", skip_all)]
async fn test_query_symbols() {
    info!("æŸ¥è¯¢äº¤æ˜“å¯¹åˆ—è¡¨");
    tokio::time::sleep(tokio::time::Duration::from_millis(50)).await;
    info!("æŸ¥è¯¢åˆ° 437 ä¸ªäº¤æ˜“å¯¹");
}

#[instrument(target = "Database", skip_all)]
async fn test_insert_klines() {
    info!("æ’å…¥Kçº¿æ•°æ®");
    tokio::time::sleep(tokio::time::Duration::from_millis(80)).await;
    info!("æ’å…¥äº† 100 æ¡Kçº¿è®°å½•");
}

#[instrument(target = "BinanceApi", skip_all)]
async fn test_api_call() {
    info!("è°ƒç”¨å¸å®‰API");

    // æ¨¡æ‹ŸAPIè°ƒç”¨
    test_get_exchange_info().await;
    test_get_klines().await;

    tokio::time::sleep(tokio::time::Duration::from_millis(200)).await;
    info!("APIè°ƒç”¨å®Œæˆ");
}

#[instrument(target = "BinanceApi", skip_all)]
async fn test_get_exchange_info() {
    info!("è·å–äº¤æ˜“æ‰€ä¿¡æ¯");
    tokio::time::sleep(tokio::time::Duration::from_millis(120)).await;
    info!("è·å–äº¤æ˜“æ‰€ä¿¡æ¯æˆåŠŸ");
}

#[instrument(target = "BinanceApi", skip_all)]
async fn test_get_klines() {
    info!("è·å–Kçº¿æ•°æ®");
    tokio::time::sleep(tokio::time::Duration::from_millis(150)).await;
    info!("è·å–åˆ° 1000 æ¡Kçº¿æ•°æ®");
}

#[instrument(target = "DataProcessor", skip_all)]
async fn test_data_processing() {
    info!("å¼€å§‹æ•°æ®å¤„ç†");

    // æ¨¡æ‹Ÿæ•°æ®å¤„ç†
    test_validate_data().await;
    test_transform_data().await;

    tokio::time::sleep(tokio::time::Duration::from_millis(80)).await;
    info!("æ•°æ®å¤„ç†å®Œæˆ");
}

#[instrument(target = "DataProcessor", skip_all)]
async fn test_validate_data() {
    info!("éªŒè¯æ•°æ®æ ¼å¼");
    tokio::time::sleep(tokio::time::Duration::from_millis(30)).await;
    info!("æ•°æ®éªŒè¯é€šè¿‡");
}

#[instrument(target = "DataProcessor", skip_all)]
async fn test_transform_data() {
    info!("è½¬æ¢æ•°æ®æ ¼å¼");
    tokio::time::sleep(tokio::time::Duration::from_millis(40)).await;
    info!("æ•°æ®è½¬æ¢å®Œæˆ");
}

/// åˆå§‹åŒ–æ—¥å¿—ç³»ç»Ÿï¼ˆåŒæ—¶æ”¯æŒæ¨¡å—æ—¥å¿—å’Œtraceå¯è§†åŒ–ï¼‰
#[instrument(target = "kline_data_service", skip_all)]
fn init_simple_logging() {
    use kline_server::klcommon::log::{
        observability::UniversalLogForwardingLayer,
        trace_visualization::TraceVisualizationLayer,
    };
    use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt, Registry};

    // ç¡®ä¿æ—¥å¿—ç›®å½•å­˜åœ¨
    std::fs::create_dir_all("logs").unwrap_or_else(|_| {
        // æ—¥å¿—ç›®å½•åˆ›å»ºå¤±è´¥ï¼Œå¿½ç•¥é”™è¯¯
    });

    // è·å–æ—¥å¿—é…ç½®
    let log_level = std::env::var("RUST_LOG").unwrap_or_else(|_| "info".to_string());
    let log_transport = std::env::var("LOG_TRANSPORT").unwrap_or_else(|_| "file".to_string());
    let pipe_name = std::env::var("PIPE_NAME").unwrap_or_else(|_| r"\\.\pipe\kline_log_pipe".to_string());

    // æ ¹æ®ä¼ è¾“æ–¹å¼åˆå§‹åŒ–æ—¥å¿—
    match log_transport.as_str() {
        "named_pipe" => {
            // å‘½åç®¡é“æ¨¡å¼ - åŒæ—¶æ”¯æŒæ¨¡å—æ—¥å¿—å’Œtraceå¯è§†åŒ–
            let observability_layer = UniversalLogForwardingLayer::new_named_pipe(pipe_name.clone());
            let trace_layer = TraceVisualizationLayer::new_named_pipe(pipe_name.clone());

            Registry::default()
                .with(observability_layer)  // å¤„ç†æ™®é€šæ¨¡å—æ—¥å¿—
                .with(trace_layer)          // å¤„ç† span æ—¥å¿—ç”¨äºè·¯å¾„å¯è§†åŒ–
                .with(create_env_filter(&log_level))
                .init();

            info!("åŒé‡æ—¥å¿—ç³»ç»Ÿå·²åˆå§‹åŒ–ï¼ˆå‘½åç®¡é“æ¨¡å¼ï¼‰");
            info!("- æ¨¡å—æ—¥å¿—: æŒ‰targetåˆ†ç±»æ˜¾ç¤º");
            info!("- Traceå¯è§†åŒ–: å‡½æ•°æ‰§è¡Œè·¯å¾„");
            info!("ç®¡é“åç§°: {}", pipe_name);
        }
        "websocket" => {
            // WebSocketæ¨¡å¼ - åŒæ—¶æ”¯æŒæ¨¡å—æ—¥å¿—å’Œtraceå¯è§†åŒ–
            let web_port = std::env::var("WEB_PORT")
                .unwrap_or_else(|_| "3000".to_string())
                .parse::<u16>()
                .unwrap_or(3000);

            let observability_layer = UniversalLogForwardingLayer::new_websocket(web_port);
            let trace_layer = TraceVisualizationLayer::new_websocket(web_port);

            Registry::default()
                .with(observability_layer)  // å¤„ç†æ™®é€šæ¨¡å—æ—¥å¿—
                .with(trace_layer)          // å¤„ç† span æ—¥å¿—ç”¨äºè·¯å¾„å¯è§†åŒ–
                .with(create_env_filter(&log_level))
                .init();

            info!("ğŸš€ åŒé‡æ—¥å¿—ç³»ç»Ÿå·²åˆå§‹åŒ–ï¼ˆWebSocketæ¨¡å¼ï¼‰");
            info!("ğŸ“Š æ¨¡å—æ—¥å¿—: æŒ‰targetåˆ†ç±»æ˜¾ç¤º (index.html)");
            info!("ğŸ” Traceå¯è§†åŒ–: å‡½æ•°æ‰§è¡Œè·¯å¾„ (trace_viewer.html)");
            info!("ğŸŒ WebSocketç«¯å£: {}", web_port);
        }
        _ => {
            // æ–‡ä»¶æ¨¡å¼ï¼ˆé»˜è®¤ï¼‰
            tracing_subscriber::fmt()
                .with_env_filter(create_env_filter(&log_level))
                .with_target(true)
                .with_level(true)
                .with_timer(tracing_subscriber::fmt::time::UtcTime::rfc_3339())
                .init();

            info!("æ—¥å¿—ç³»ç»Ÿå·²åˆå§‹åŒ–ï¼ˆæ–‡ä»¶æ¨¡å¼ï¼‰");
        }
    }

    info!("æ—¥å¿—çº§åˆ«: {}", log_level);
}

/// åˆ›å»ºç¯å¢ƒè¿‡æ»¤å™¨ï¼Œå§‹ç»ˆè¿‡æ»¤æ‰ç¬¬ä¸‰æ–¹åº“çš„è°ƒè¯•æ—¥å¿—
#[instrument(target = "kline_data_service", skip_all)]
fn create_env_filter(log_level: &str) -> tracing_subscriber::EnvFilter {
    // æ— è®ºåº”ç”¨æ—¥å¿—çº§åˆ«å¦‚ä½•ï¼Œéƒ½è¿‡æ»¤æ‰ç¬¬ä¸‰æ–¹åº“çš„å™ªéŸ³æ—¥å¿—
    let filter_str = format!(
        "{},hyper=warn,reqwest=warn,tokio_tungstenite=warn,tungstenite=warn,rustls=warn,h2=warn,sqlx=warn,rusqlite=warn",
        log_level
    );

    tracing_subscriber::EnvFilter::new(filter_str)
}
