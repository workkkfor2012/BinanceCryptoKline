//! å¯è§‚å¯Ÿæ€§å’Œè§„æ ¼éªŒè¯æ¨¡å—
//!
//! æä¾›åŸºäºtracingçš„è§„æ ¼éªŒè¯å±‚å’Œæ€§èƒ½ç›‘æ§åŠŸèƒ½

use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use std::time::{Instant, SystemTime, UNIX_EPOCH};
use tracing::{Event, Id, Subscriber, info, warn, error, Instrument};
use tracing_subscriber::{layer::Context, Layer};

/// éªŒè¯ç»“æœçŠ¶æ€
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ValidationStatus {
    #[serde(rename = "PASS")]
    Pass,
    #[serde(rename = "FAIL")]
    Fail,
    #[serde(rename = "WARN")]
    Warn,
}

/// éªŒè¯ç»“æœäº‹ä»¶
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ValidationEvent {
    /// äº‹ä»¶å‘ç”Ÿæ—¶é—´æˆ³
    pub timestamp: u64,
    /// éªŒè¯è§„åˆ™ID
    pub validation_rule_id: String,
    /// äº§ç”Ÿäº‹ä»¶çš„æ¨¡å—
    pub module: String,
    /// éªŒè¯çŠ¶æ€
    pub status: ValidationStatus,
    /// éªŒè¯ä¸Šä¸‹æ–‡æ•°æ®
    pub context: serde_json::Value,
    /// éªŒè¯ç»“æœæè¿°
    pub message: String,
}

/// æ€§èƒ½æŒ‡æ ‡äº‹ä»¶
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PerformanceEvent {
    /// äº‹ä»¶å‘ç”Ÿæ—¶é—´æˆ³
    pub timestamp: u64,
    /// äº‹ä»¶ç±»å‹
    pub event_type: String,
    /// Spanåç§°
    pub span_name: String,
    /// æŒç»­æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
    pub duration_ms: f64,
    /// ä¸Šä¸‹æ–‡æ•°æ®
    pub context: serde_json::Value,
}

/// Spanæ€§èƒ½æ•°æ®
#[derive(Debug, Clone)]
struct SpanPerformanceData {
    start_time: Instant,
    metadata: HashMap<String, String>,
}

/// è§„æ ¼éªŒè¯è§„åˆ™
pub struct ValidationRule {
    pub id: String,
    pub description: String,
    pub validator: Box<dyn Fn(&ValidationContext) -> ValidationResult + Send + Sync>,
}

/// éªŒè¯ä¸Šä¸‹æ–‡
#[derive(Debug, Clone)]
pub struct ValidationContext {
    pub module: String,
    pub operation: String,
    pub fields: HashMap<String, serde_json::Value>,
    pub span_data: Option<HashMap<String, String>>,
}

/// éªŒè¯ç»“æœ
#[derive(Debug, Clone)]
pub struct ValidationResult {
    pub status: ValidationStatus,
    pub message: String,
    pub context: serde_json::Value,
}

/// è§„æ ¼éªŒè¯å±‚
pub struct SpecValidationLayer {
    /// éªŒè¯è§„åˆ™é›†åˆ
    rules: Arc<Mutex<HashMap<String, ValidationRule>>>,
    /// Spanæ€§èƒ½æ•°æ®
    span_data: Arc<Mutex<HashMap<Id, SpanPerformanceData>>>,
    /// äº‹ä»¶è¾“å‡ºå™¨
    event_sender: Arc<dyn EventSender + Send + Sync>,
}

/// äº‹ä»¶è¾“å‡ºæ¥å£
pub trait EventSender {
    fn send_validation_event(&self, event: ValidationEvent);
    fn send_performance_event(&self, event: PerformanceEvent);
}

/// æ§åˆ¶å°äº‹ä»¶è¾“å‡ºå™¨
pub struct ConsoleEventSender;

impl EventSender for ConsoleEventSender {
    fn send_validation_event(&self, _event: ValidationEvent) {
        // ç¦ç”¨éªŒè¯äº‹ä»¶è¾“å‡º
        // if let Ok(json) = serde_json::to_string(&event) {
        //     println!("VALIDATION_EVENT: {}", json);
        // }
    }

    fn send_performance_event(&self, event: PerformanceEvent) {
        if let Ok(json) = serde_json::to_string(&event) {
            info!(target: "SystemObservability", "æ€§èƒ½äº‹ä»¶: {}", json);
        }
    }
}

/// å‘½åç®¡é“æ—¥å¿—ç®¡ç†å™¨
pub struct NamedPipeLogManager {
    pipe_name: String,
    pipe_writer: Arc<tokio::sync::Mutex<Option<tokio::io::BufWriter<tokio::net::windows::named_pipe::NamedPipeClient>>>>,
    connection_task_started: Arc<std::sync::atomic::AtomicBool>,
}

impl NamedPipeLogManager {
    /// åˆ›å»ºæ–°çš„å‘½åç®¡é“æ—¥å¿—ç®¡ç†å™¨
    pub fn new(pipe_name: String) -> Self {
        Self {
            pipe_name,
            pipe_writer: Arc::new(tokio::sync::Mutex::new(None)),
            connection_task_started: Arc::new(std::sync::atomic::AtomicBool::new(false)),
        }
    }

    /// è¿æ¥åˆ°å‘½åç®¡é“æœåŠ¡å™¨
    pub async fn connect(&self) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        use tokio::net::windows::named_pipe::ClientOptions;
        use tokio::io::BufWriter;

        info!(target: "SystemObservability", "ğŸ“¡ å°è¯•è¿æ¥åˆ°å‘½åç®¡é“: {}", self.pipe_name);

        // å°è¯•è¿æ¥åˆ°å‘½åç®¡é“æœåŠ¡å™¨ï¼ˆåŒæ­¥æ“ä½œï¼‰
        let client = ClientOptions::new().open(&self.pipe_name)?;
        info!(target: "SystemObservability", "âœ… æˆåŠŸè¿æ¥åˆ°å‘½åç®¡é“æœåŠ¡å™¨");

        // åˆ›å»ºç¼“å†²å†™å…¥å™¨
        let writer = BufWriter::new(client);

        // ä¿å­˜è¿æ¥
        let mut pipe_writer = self.pipe_writer.lock().await;
        *pipe_writer = Some(writer);

        // å‘é€ä¼šè¯å¼€å§‹æ ‡è®°
        self.send_session_start_marker().await;

        Ok(())
    }

    /// å‘é€ä¼šè¯å¼€å§‹æ ‡è®°
    async fn send_session_start_marker(&self) {
        let session_start_marker = serde_json::json!({
            "timestamp": chrono::DateTime::<chrono::Utc>::from(std::time::SystemTime::now())
                .format("%Y-%m-%dT%H:%M:%S%.6fZ").to_string(),
            "level": "INFO",
            "target": "SystemObservability",
            "message": "SESSION_START",
            "fields": {
                "session_start": true,
                "session_id": format!("session_{}", std::time::SystemTime::now()
                    .duration_since(std::time::UNIX_EPOCH)
                    .unwrap_or_default()
                    .as_millis())
            }
        });

        if let Ok(marker_json) = serde_json::to_string(&session_start_marker) {
            self.send_log(marker_json).await;
            info!(target: "SystemObservability", "ğŸ†• å·²å‘é€ä¼šè¯å¼€å§‹æ ‡è®°");
        }
    }

    /// å‘é€æ—¥å¿—åˆ°å‘½åç®¡é“
    pub async fn send_log(&self, log_line: String) {
        use tokio::io::AsyncWriteExt;

        if let Ok(mut pipe_writer_guard) = self.pipe_writer.try_lock() {
            if let Some(ref mut writer) = *pipe_writer_guard {
                let line_with_newline = format!("{}\n", log_line);
                if let Err(e) = writer.write_all(line_with_newline.as_bytes()).await {
                    error!(target: "SystemObservability", "å‘é€æ—¥å¿—åˆ°å‘½åç®¡é“å¤±è´¥: {}", e);
                    // è¿æ¥æ–­å¼€ï¼Œæ¸…é™¤writer
                    *pipe_writer_guard = None;
                } else {
                    // ç«‹å³åˆ·æ–°ç¼“å†²åŒº
                    let _ = writer.flush().await;
                }
            }
        }
    }

    /// å¯åŠ¨å‘½åç®¡é“è¿æ¥ä»»åŠ¡
    pub fn start_connection_task(&self) {
        // ä½¿ç”¨åŸå­æ“ä½œç¡®ä¿åªå¯åŠ¨ä¸€æ¬¡
        if self.connection_task_started.compare_exchange(
            false,
            true,
            std::sync::atomic::Ordering::SeqCst,
            std::sync::atomic::Ordering::SeqCst
        ).is_err() {
            // å·²ç»å¯åŠ¨è¿‡äº†
            return;
        }

        let pipe_name = self.pipe_name.clone();
        let manager = Arc::new(self.clone());

        // å¦‚æœåœ¨Tokioè¿è¡Œæ—¶ä¸­ï¼Œç›´æ¥spawn
        if let Ok(handle) = tokio::runtime::Handle::try_current() {
            handle.spawn(async move {
                Self::connection_loop(manager, pipe_name).await;
            }.instrument(tracing::info_span!("named_pipe_connection_task")));
        } else {
            // å¦‚æœä¸åœ¨Tokioè¿è¡Œæ—¶ä¸­ï¼Œåˆ›å»ºæ–°çº¿ç¨‹å’Œè¿è¡Œæ—¶
            std::thread::spawn(move || {
                let rt = tokio::runtime::Runtime::new().unwrap();
                rt.block_on(async move {
                    Self::connection_loop(manager, pipe_name).await;
                });
            });
        }
    }

    /// è¿æ¥å¾ªç¯é€»è¾‘
    async fn connection_loop(manager: Arc<NamedPipeLogManager>, pipe_name: String) {
        loop {
            // æ£€æŸ¥æ˜¯å¦å·²è¿æ¥
            {
                let pipe_writer = manager.pipe_writer.lock().await;
                if pipe_writer.is_some() {
                    // å·²è¿æ¥ï¼Œç­‰å¾…ä¸€æ®µæ—¶é—´å†æ£€æŸ¥
                    drop(pipe_writer);
                    tokio::time::sleep(tokio::time::Duration::from_secs(5)).await;
                    continue;
                }
            }

            // å°è¯•è¿æ¥
            info!(target: "SystemObservability", "ğŸ“¡ å°è¯•è¿æ¥åˆ°å‘½åç®¡é“æœåŠ¡å™¨: {}", pipe_name);
            match manager.connect().await {
                Ok(_) => {
                    info!(target: "SystemObservability", "âœ… å‘½åç®¡é“è¿æ¥æˆåŠŸ");
                }
                Err(e) => {
                    warn!(target: "SystemObservability", "âŒ å‘½åç®¡é“è¿æ¥å¤±è´¥: {}, 5ç§’åé‡è¯•", e);
                    tokio::time::sleep(tokio::time::Duration::from_secs(5)).await;
                }
            }
        }
    }
}

impl Clone for NamedPipeLogManager {
    fn clone(&self) -> Self {
        Self {
            pipe_name: self.pipe_name.clone(),
            pipe_writer: self.pipe_writer.clone(),
            connection_task_started: self.connection_task_started.clone(),
        }
    }
}











/// æ¨¡å—æ—¥å¿—å±‚ - å°†æ‰€æœ‰ä¸åœ¨ä»»ä½• Span å†…éƒ¨çš„æ—¥å¿—äº‹ä»¶ä½œä¸ºæ¨¡å—çº§æ—¥å¿—è¿›è¡Œè½¬å‘
pub struct ModuleLayer {
    manager: Arc<NamedPipeLogManager>,
}

impl ModuleLayer {
    /// åˆ›å»ºä¸€ä¸ªæ–°çš„æ¨¡å—æ—¥å¿—å±‚
    /// å®ƒéœ€è¦ä¸€ä¸ªå·²ç»åˆ›å»ºå¥½çš„ã€å¯å…±äº«çš„ NamedPipeLogManager å®ä¾‹
    pub fn new(manager: Arc<NamedPipeLogManager>) -> Self {
        Self { manager }
    }
}

impl<S> Layer<S> for ModuleLayer
where
    S: Subscriber + for<'lookup> tracing_subscriber::registry::LookupSpan<'lookup>,
{
    fn on_event(&self, event: &Event<'_>, ctx: Context<'_, S>) {
        // ã€å…³é”®é€»è¾‘ã€‘å¦‚æœäº‹ä»¶åœ¨ Span å†…éƒ¨ï¼Œåˆ™å¿½ç•¥ï¼Œäº¤ç”±å…¶ä»– Layer å¤„ç†
        if ctx.lookup_current().is_some() {
            return;
        }

        // --- åªå¤„ç†é¡¶å±‚æ—¥å¿— ---
        let metadata = event.metadata();

        let mut fields = serde_json::Map::new();
        // ä½¿ç”¨ trace_visualization ä¸­çš„ JsonVisitor
        let mut visitor = super::trace_visualization::JsonVisitor::new(&mut fields);
        event.record(&mut visitor);

        let message = fields.remove("message")
            .and_then(|v| v.as_str().map(String::from))
            .unwrap_or_else(String::new);

        let module_log_obj = serde_json::json!({
            "log_type": "module",
            "timestamp": chrono::Utc::now().to_rfc3339(),
            "level": metadata.level().to_string(),
            "target": metadata.target(),
            "message": message,
            "fields": fields,
        });

        if let Ok(log_line) = serde_json::to_string(&module_log_obj) {
            let manager = self.manager.clone();
            // åœ¨å¼‚æ­¥è¿è¡Œæ—¶ä¸­å‘é€æ—¥å¿—
            if let Ok(handle) = tokio::runtime::Handle::try_current() {
                handle.spawn(async move {
                    manager.send_log(log_line).await;
                }.instrument(tracing::info_span!("module_log_send_task")));
            }
        }
    }
}

/// å‘½åç®¡é“æ—¥å¿—è½¬å‘å±‚ - å‘åå…¼å®¹çš„åŒ…è£…å™¨
pub struct NamedPipeLogForwardingLayer {
    inner: ModuleLayer,
}

impl NamedPipeLogForwardingLayer {
    /// åˆ›å»ºå‘½åç®¡é“æ—¥å¿—è½¬å‘å±‚ï¼ˆå‘åå…¼å®¹ï¼‰
    pub fn new(pipe_name: String) -> Self {
        let manager = Arc::new(NamedPipeLogManager::new(pipe_name));
        manager.start_connection_task();
        Self {
            inner: ModuleLayer::new(manager)
        }
    }
}

impl<S> Layer<S> for NamedPipeLogForwardingLayer
where
    S: Subscriber + for<'lookup> tracing_subscriber::registry::LookupSpan<'lookup>,
{
    fn on_event(&self, event: &Event<'_>, ctx: Context<'_, S>) {
        self.inner.on_event(event, ctx)
    }
}



impl SpecValidationLayer {
    /// åˆ›å»ºæ–°çš„è§„æ ¼éªŒè¯å±‚
    pub fn new(event_sender: Arc<dyn EventSender + Send + Sync>) -> Self {
        let mut layer = Self {
            rules: Arc::new(Mutex::new(HashMap::new())),
            span_data: Arc::new(Mutex::new(HashMap::new())),
            event_sender,
        };

        // æ³¨å†Œé»˜è®¤éªŒè¯è§„åˆ™
        layer.register_default_rules();
        layer
    }

    /// æ³¨å†ŒéªŒè¯è§„åˆ™
    pub fn register_rule(&self, rule: ValidationRule) {
        if let Ok(mut rules) = self.rules.lock() {
            rules.insert(rule.id.clone(), rule);
        }
    }

    /// æ³¨å†Œé»˜è®¤éªŒè¯è§„åˆ™
    fn register_default_rules(&mut self) {
        // è¿™é‡Œå°†åœ¨åç»­å®ç°å…·ä½“çš„éªŒè¯è§„åˆ™
    }

    /// ä»äº‹ä»¶ä¸­æå–éªŒè¯ä¸Šä¸‹æ–‡
    fn extract_validation_context<S>(&self, event: &Event, _ctx: &Context<S>) -> Option<ValidationContext>
    where
        S: Subscriber + for<'lookup> tracing_subscriber::registry::LookupSpan<'lookup>,
    {
        let metadata = event.metadata();
        let module = metadata.target().split("::").nth(2).unwrap_or("unknown").to_string();

        let mut fields = HashMap::new();
        let mut visitor = FieldVisitor::new(&mut fields);
        event.record(&mut visitor);

        Some(ValidationContext {
            module,
            operation: metadata.name().to_string(),
            fields,
            span_data: None,
        })
    }

    /// åº”ç”¨éªŒè¯è§„åˆ™
    fn apply_validation_rules(&self, _context: &ValidationContext) {
        // ç¦ç”¨éªŒè¯è§„åˆ™åº”ç”¨
        // if let Ok(rules) = self.rules.lock() {
        //     for (rule_id, rule) in rules.iter() {
        //         let result = (rule.validator)(context);
        //
        //         let event = ValidationEvent {
        //             timestamp: SystemTime::now()
        //                 .duration_since(UNIX_EPOCH)
        //                 .unwrap_or_default()
        //                 .as_millis() as u64,
        //             validation_rule_id: rule_id.clone(),
        //             module: context.module.clone(),
        //             status: result.status,
        //             context: result.context,
        //             message: result.message,
        //         };
        //
        //         self.event_sender.send_validation_event(event);
        //     }
        // }
    }
}

/// å­—æ®µè®¿é—®å™¨ï¼Œç”¨äºæå–äº‹ä»¶å­—æ®µ
struct FieldVisitor<'a> {
    fields: &'a mut HashMap<String, serde_json::Value>,
}

impl<'a> FieldVisitor<'a> {
    fn new(fields: &'a mut HashMap<String, serde_json::Value>) -> Self {
        Self { fields }
    }
}

impl<'a> tracing::field::Visit for FieldVisitor<'a> {
    fn record_debug(&mut self, field: &tracing::field::Field, value: &dyn std::fmt::Debug) {
        self.fields.insert(
            field.name().to_string(),
            serde_json::Value::String(format!("{:?}", value)),
        );
    }

    fn record_str(&mut self, field: &tracing::field::Field, value: &str) {
        self.fields.insert(
            field.name().to_string(),
            serde_json::Value::String(value.to_string()),
        );
    }

    fn record_i64(&mut self, field: &tracing::field::Field, value: i64) {
        self.fields.insert(
            field.name().to_string(),
            serde_json::Value::Number(serde_json::Number::from(value)),
        );
    }

    fn record_u64(&mut self, field: &tracing::field::Field, value: u64) {
        self.fields.insert(
            field.name().to_string(),
            serde_json::Value::Number(serde_json::Number::from(value)),
        );
    }

    fn record_f64(&mut self, field: &tracing::field::Field, value: f64) {
        if let Some(num) = serde_json::Number::from_f64(value) {
            self.fields.insert(
                field.name().to_string(),
                serde_json::Value::Number(num),
            );
        }
    }

    fn record_bool(&mut self, field: &tracing::field::Field, value: bool) {
        self.fields.insert(
            field.name().to_string(),
            serde_json::Value::Bool(value),
        );
    }
}

impl<S> Layer<S> for SpecValidationLayer
where
    S: Subscriber + for<'lookup> tracing_subscriber::registry::LookupSpan<'lookup>,
{
    fn on_new_span(&self, attrs: &tracing::span::Attributes<'_>, id: &Id, _ctx: Context<'_, S>) {
        let _metadata = attrs.metadata();
        let mut fields = HashMap::new();
        let mut visitor = FieldVisitor::new(&mut fields);
        attrs.record(&mut visitor);

        let span_data = SpanPerformanceData {
            start_time: Instant::now(),
            metadata: fields.into_iter()
                .map(|(k, v)| (k, v.to_string()))
                .collect(),
        };

        if let Ok(mut data) = self.span_data.lock() {
            data.insert(id.clone(), span_data);
        }
    }

    fn on_event(&self, event: &Event<'_>, ctx: Context<'_, S>) {
        if let Some(validation_context) = self.extract_validation_context(event, &ctx) {
            self.apply_validation_rules(&validation_context);
        }
    }

    fn on_close(&self, id: Id, ctx: Context<'_, S>) {
        if let Ok(mut data) = self.span_data.lock() {
            if let Some(span_data) = data.remove(&id) {
                let duration = span_data.start_time.elapsed();

                if let Some(span) = ctx.span(&id) {
                    let metadata = span.metadata();

                    let performance_event = PerformanceEvent {
                        timestamp: SystemTime::now()
                            .duration_since(UNIX_EPOCH)
                            .unwrap_or_default()
                            .as_millis() as u64,
                        event_type: "PerformanceMetric".to_string(),
                        span_name: metadata.name().to_string(),
                        duration_ms: duration.as_secs_f64() * 1000.0,
                        context: serde_json::to_value(&span_data.metadata).unwrap_or_default(),
                    };

                    self.event_sender.send_performance_event(performance_event);
                }
            }
        }
    }
}

/// éªŒè¯è§„åˆ™IDå¸¸é‡
pub mod validation_rules {
    pub const SYMBOL_INDEX_STABILITY: &str = "SYMBOL_INDEX_STABILITY";
    pub const KLINE_OPEN_TIME_ACCURACY: &str = "KLINE_OPEN_TIME_ACCURACY";
    pub const KLINE_IS_FINAL_CORRECTNESS: &str = "KLINE_IS_FINAL_CORRECTNESS";
    pub const EMPTY_KLINE_HANDLING: &str = "EMPTY_KLINE_HANDLING";
    pub const BUFFER_SWAP_NOTIFICATION: &str = "BUFFER_SWAP_NOTIFICATION";
    pub const PERSISTENCE_UPSERT_LOGIC: &str = "PERSISTENCE_UPSERT_LOGIC";
    pub const DATA_FLOW_INTEGRITY: &str = "DATA_FLOW_INTEGRITY";
}
