//! 可观察性和规格验证模块
//!
//! 提供基于tracing的规格验证层和性能监控功能

use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use std::time::{Instant, SystemTime, UNIX_EPOCH};
use tracing::{Event, Id, Subscriber, info, warn, error, Instrument};
use tracing_subscriber::{layer::Context, Layer};

/// 验证结果状态
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ValidationStatus {
    #[serde(rename = "PASS")]
    Pass,
    #[serde(rename = "FAIL")]
    Fail,
    #[serde(rename = "WARN")]
    Warn,
}

/// 验证结果事件
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ValidationEvent {
    /// 事件发生时间戳
    pub timestamp: u64,
    /// 验证规则ID
    pub validation_rule_id: String,
    /// 产生事件的模块
    pub module: String,
    /// 验证状态
    pub status: ValidationStatus,
    /// 验证上下文数据
    pub context: serde_json::Value,
    /// 验证结果描述
    pub message: String,
}

/// 性能指标事件
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PerformanceEvent {
    /// 事件发生时间戳
    pub timestamp: u64,
    /// 事件类型
    pub event_type: String,
    /// Span名称
    pub span_name: String,
    /// 持续时间（毫秒）
    pub duration_ms: f64,
    /// 上下文数据
    pub context: serde_json::Value,
}

/// Span性能数据
#[derive(Debug, Clone)]
struct SpanPerformanceData {
    start_time: Instant,
    metadata: HashMap<String, String>,
}

/// 规格验证规则
pub struct ValidationRule {
    pub id: String,
    pub description: String,
    pub validator: Box<dyn Fn(&ValidationContext) -> ValidationResult + Send + Sync>,
}

/// 验证上下文
#[derive(Debug, Clone)]
pub struct ValidationContext {
    pub module: String,
    pub operation: String,
    pub fields: HashMap<String, serde_json::Value>,
    pub span_data: Option<HashMap<String, String>>,
}

/// 验证结果
#[derive(Debug, Clone)]
pub struct ValidationResult {
    pub status: ValidationStatus,
    pub message: String,
    pub context: serde_json::Value,
}

/// 规格验证层
pub struct SpecValidationLayer {
    /// 验证规则集合
    rules: Arc<Mutex<HashMap<String, ValidationRule>>>,
    /// Span性能数据
    span_data: Arc<Mutex<HashMap<Id, SpanPerformanceData>>>,
    /// 事件输出器
    event_sender: Arc<dyn EventSender + Send + Sync>,
}

/// 事件输出接口
pub trait EventSender {
    fn send_validation_event(&self, event: ValidationEvent);
    fn send_performance_event(&self, event: PerformanceEvent);
}

/// 控制台事件输出器
pub struct ConsoleEventSender;

impl EventSender for ConsoleEventSender {
    fn send_validation_event(&self, _event: ValidationEvent) {
        // 禁用验证事件输出
        // if let Ok(json) = serde_json::to_string(&event) {
        //     println!("VALIDATION_EVENT: {}", json);
        // }
    }

    fn send_performance_event(&self, event: PerformanceEvent) {
        if let Ok(json) = serde_json::to_string(&event) {
            info!(target: "SystemObservability", "性能事件: {}", json);
        }
    }
}

/// 命名管道日志管理器
pub struct NamedPipeLogManager {
    pipe_name: String,
    pipe_writer: Arc<tokio::sync::Mutex<Option<tokio::io::BufWriter<tokio::net::windows::named_pipe::NamedPipeClient>>>>,
    connection_task_started: Arc<std::sync::atomic::AtomicBool>,
}

impl NamedPipeLogManager {
    /// 创建新的命名管道日志管理器
    pub fn new(pipe_name: String) -> Self {
        Self {
            pipe_name,
            pipe_writer: Arc::new(tokio::sync::Mutex::new(None)),
            connection_task_started: Arc::new(std::sync::atomic::AtomicBool::new(false)),
        }
    }

    /// 连接到命名管道服务器
    pub async fn connect(&self) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        use tokio::net::windows::named_pipe::ClientOptions;
        use tokio::io::BufWriter;

        info!(target: "SystemObservability", "📡 尝试连接到命名管道: {}", self.pipe_name);

        // 尝试连接到命名管道服务器（同步操作）
        let client = ClientOptions::new().open(&self.pipe_name)?;
        info!(target: "SystemObservability", "✅ 成功连接到命名管道服务器");

        // 创建缓冲写入器
        let writer = BufWriter::new(client);

        // 保存连接
        let mut pipe_writer = self.pipe_writer.lock().await;
        *pipe_writer = Some(writer);

        // 发送会话开始标记
        self.send_session_start_marker().await;

        Ok(())
    }

    /// 发送会话开始标记
    async fn send_session_start_marker(&self) {
        let session_start_marker = serde_json::json!({
            "timestamp": chrono::DateTime::<chrono::Utc>::from(std::time::SystemTime::now())
                .format("%Y-%m-%dT%H:%M:%S%.6fZ").to_string(),
            "level": "INFO",
            "target": "SystemObservability",
            "message": "SESSION_START",
            "fields": {
                "session_start": true,
                "session_id": format!("session_{}", std::time::SystemTime::now()
                    .duration_since(std::time::UNIX_EPOCH)
                    .unwrap_or_default()
                    .as_millis())
            }
        });

        if let Ok(marker_json) = serde_json::to_string(&session_start_marker) {
            self.send_log(marker_json).await;
            info!(target: "SystemObservability", "🆕 已发送会话开始标记");
        }
    }

    /// 发送日志到命名管道
    pub async fn send_log(&self, log_line: String) {
        use tokio::io::AsyncWriteExt;

        if let Ok(mut pipe_writer_guard) = self.pipe_writer.try_lock() {
            if let Some(ref mut writer) = *pipe_writer_guard {
                let line_with_newline = format!("{}\n", log_line);
                if let Err(e) = writer.write_all(line_with_newline.as_bytes()).await {
                    error!(target: "SystemObservability", "发送日志到命名管道失败: {}", e);
                    // 连接断开，清除writer
                    *pipe_writer_guard = None;
                } else {
                    // 立即刷新缓冲区
                    let _ = writer.flush().await;
                }
            }
        }
    }

    /// 启动命名管道连接任务
    pub fn start_connection_task(&self) {
        // 使用原子操作确保只启动一次
        if self.connection_task_started.compare_exchange(
            false,
            true,
            std::sync::atomic::Ordering::SeqCst,
            std::sync::atomic::Ordering::SeqCst
        ).is_err() {
            // 已经启动过了
            return;
        }

        let pipe_name = self.pipe_name.clone();
        let manager = Arc::new(self.clone());

        // 如果在Tokio运行时中，直接spawn
        if let Ok(handle) = tokio::runtime::Handle::try_current() {
            handle.spawn(async move {
                Self::connection_loop(manager, pipe_name).await;
            }.instrument(tracing::info_span!("named_pipe_connection_task")));
        } else {
            // 如果不在Tokio运行时中，创建新线程和运行时
            std::thread::spawn(move || {
                let rt = tokio::runtime::Runtime::new().unwrap();
                rt.block_on(async move {
                    Self::connection_loop(manager, pipe_name).await;
                });
            });
        }
    }

    /// 连接循环逻辑
    async fn connection_loop(manager: Arc<NamedPipeLogManager>, pipe_name: String) {
        loop {
            // 检查是否已连接
            {
                let pipe_writer = manager.pipe_writer.lock().await;
                if pipe_writer.is_some() {
                    // 已连接，等待一段时间再检查
                    drop(pipe_writer);
                    tokio::time::sleep(tokio::time::Duration::from_secs(5)).await;
                    continue;
                }
            }

            // 尝试连接
            info!(target: "SystemObservability", "📡 尝试连接到命名管道服务器: {}", pipe_name);
            match manager.connect().await {
                Ok(_) => {
                    info!(target: "SystemObservability", "✅ 命名管道连接成功");
                }
                Err(e) => {
                    warn!(target: "SystemObservability", "❌ 命名管道连接失败: {}, 5秒后重试", e);
                    tokio::time::sleep(tokio::time::Duration::from_secs(5)).await;
                }
            }
        }
    }
}

impl Clone for NamedPipeLogManager {
    fn clone(&self) -> Self {
        Self {
            pipe_name: self.pipe_name.clone(),
            pipe_writer: self.pipe_writer.clone(),
            connection_task_started: self.connection_task_started.clone(),
        }
    }
}











/// 模块日志层 - 将所有不在任何 Span 内部的日志事件作为模块级日志进行转发
pub struct ModuleLayer {
    manager: Arc<NamedPipeLogManager>,
}

impl ModuleLayer {
    /// 创建一个新的模块日志层
    /// 它需要一个已经创建好的、可共享的 NamedPipeLogManager 实例
    pub fn new(manager: Arc<NamedPipeLogManager>) -> Self {
        Self { manager }
    }
}

impl<S> Layer<S> for ModuleLayer
where
    S: Subscriber + for<'lookup> tracing_subscriber::registry::LookupSpan<'lookup>,
{
    fn on_event(&self, event: &Event<'_>, ctx: Context<'_, S>) {
        // 【关键逻辑】如果事件在 Span 内部，则忽略，交由其他 Layer 处理
        if ctx.lookup_current().is_some() {
            return;
        }

        // --- 只处理顶层日志 ---
        let metadata = event.metadata();

        let mut fields = serde_json::Map::new();
        // 使用 trace_visualization 中的 JsonVisitor
        let mut visitor = super::trace_visualization::JsonVisitor::new(&mut fields);
        event.record(&mut visitor);

        let message = fields.remove("message")
            .and_then(|v| v.as_str().map(String::from))
            .unwrap_or_else(String::new);

        let module_log_obj = serde_json::json!({
            "log_type": "module",
            "timestamp": chrono::Utc::now().to_rfc3339(),
            "level": metadata.level().to_string(),
            "target": metadata.target(),
            "message": message,
            "fields": fields,
        });

        if let Ok(log_line) = serde_json::to_string(&module_log_obj) {
            let manager = self.manager.clone();
            // 在异步运行时中发送日志
            if let Ok(handle) = tokio::runtime::Handle::try_current() {
                handle.spawn(async move {
                    manager.send_log(log_line).await;
                }.instrument(tracing::info_span!("module_log_send_task")));
            }
        }
    }
}

/// 命名管道日志转发层 - 向后兼容的包装器
pub struct NamedPipeLogForwardingLayer {
    inner: ModuleLayer,
}

impl NamedPipeLogForwardingLayer {
    /// 创建命名管道日志转发层（向后兼容）
    pub fn new(pipe_name: String) -> Self {
        let manager = Arc::new(NamedPipeLogManager::new(pipe_name));
        manager.start_connection_task();
        Self {
            inner: ModuleLayer::new(manager)
        }
    }
}

impl<S> Layer<S> for NamedPipeLogForwardingLayer
where
    S: Subscriber + for<'lookup> tracing_subscriber::registry::LookupSpan<'lookup>,
{
    fn on_event(&self, event: &Event<'_>, ctx: Context<'_, S>) {
        self.inner.on_event(event, ctx)
    }
}



impl SpecValidationLayer {
    /// 创建新的规格验证层
    pub fn new(event_sender: Arc<dyn EventSender + Send + Sync>) -> Self {
        let mut layer = Self {
            rules: Arc::new(Mutex::new(HashMap::new())),
            span_data: Arc::new(Mutex::new(HashMap::new())),
            event_sender,
        };

        // 注册默认验证规则
        layer.register_default_rules();
        layer
    }

    /// 注册验证规则
    pub fn register_rule(&self, rule: ValidationRule) {
        if let Ok(mut rules) = self.rules.lock() {
            rules.insert(rule.id.clone(), rule);
        }
    }

    /// 注册默认验证规则
    fn register_default_rules(&mut self) {
        // 这里将在后续实现具体的验证规则
    }

    /// 从事件中提取验证上下文
    fn extract_validation_context<S>(&self, event: &Event, _ctx: &Context<S>) -> Option<ValidationContext>
    where
        S: Subscriber + for<'lookup> tracing_subscriber::registry::LookupSpan<'lookup>,
    {
        let metadata = event.metadata();
        let module = metadata.target().split("::").nth(2).unwrap_or("unknown").to_string();

        let mut fields = HashMap::new();
        let mut visitor = FieldVisitor::new(&mut fields);
        event.record(&mut visitor);

        Some(ValidationContext {
            module,
            operation: metadata.name().to_string(),
            fields,
            span_data: None,
        })
    }

    /// 应用验证规则
    fn apply_validation_rules(&self, _context: &ValidationContext) {
        // 禁用验证规则应用
        // if let Ok(rules) = self.rules.lock() {
        //     for (rule_id, rule) in rules.iter() {
        //         let result = (rule.validator)(context);
        //
        //         let event = ValidationEvent {
        //             timestamp: SystemTime::now()
        //                 .duration_since(UNIX_EPOCH)
        //                 .unwrap_or_default()
        //                 .as_millis() as u64,
        //             validation_rule_id: rule_id.clone(),
        //             module: context.module.clone(),
        //             status: result.status,
        //             context: result.context,
        //             message: result.message,
        //         };
        //
        //         self.event_sender.send_validation_event(event);
        //     }
        // }
    }
}

/// 字段访问器，用于提取事件字段
struct FieldVisitor<'a> {
    fields: &'a mut HashMap<String, serde_json::Value>,
}

impl<'a> FieldVisitor<'a> {
    fn new(fields: &'a mut HashMap<String, serde_json::Value>) -> Self {
        Self { fields }
    }
}

impl<'a> tracing::field::Visit for FieldVisitor<'a> {
    fn record_debug(&mut self, field: &tracing::field::Field, value: &dyn std::fmt::Debug) {
        self.fields.insert(
            field.name().to_string(),
            serde_json::Value::String(format!("{:?}", value)),
        );
    }

    fn record_str(&mut self, field: &tracing::field::Field, value: &str) {
        self.fields.insert(
            field.name().to_string(),
            serde_json::Value::String(value.to_string()),
        );
    }

    fn record_i64(&mut self, field: &tracing::field::Field, value: i64) {
        self.fields.insert(
            field.name().to_string(),
            serde_json::Value::Number(serde_json::Number::from(value)),
        );
    }

    fn record_u64(&mut self, field: &tracing::field::Field, value: u64) {
        self.fields.insert(
            field.name().to_string(),
            serde_json::Value::Number(serde_json::Number::from(value)),
        );
    }

    fn record_f64(&mut self, field: &tracing::field::Field, value: f64) {
        if let Some(num) = serde_json::Number::from_f64(value) {
            self.fields.insert(
                field.name().to_string(),
                serde_json::Value::Number(num),
            );
        }
    }

    fn record_bool(&mut self, field: &tracing::field::Field, value: bool) {
        self.fields.insert(
            field.name().to_string(),
            serde_json::Value::Bool(value),
        );
    }
}

impl<S> Layer<S> for SpecValidationLayer
where
    S: Subscriber + for<'lookup> tracing_subscriber::registry::LookupSpan<'lookup>,
{
    fn on_new_span(&self, attrs: &tracing::span::Attributes<'_>, id: &Id, _ctx: Context<'_, S>) {
        let _metadata = attrs.metadata();
        let mut fields = HashMap::new();
        let mut visitor = FieldVisitor::new(&mut fields);
        attrs.record(&mut visitor);

        let span_data = SpanPerformanceData {
            start_time: Instant::now(),
            metadata: fields.into_iter()
                .map(|(k, v)| (k, v.to_string()))
                .collect(),
        };

        if let Ok(mut data) = self.span_data.lock() {
            data.insert(id.clone(), span_data);
        }
    }

    fn on_event(&self, event: &Event<'_>, ctx: Context<'_, S>) {
        if let Some(validation_context) = self.extract_validation_context(event, &ctx) {
            self.apply_validation_rules(&validation_context);
        }
    }

    fn on_close(&self, id: Id, ctx: Context<'_, S>) {
        if let Ok(mut data) = self.span_data.lock() {
            if let Some(span_data) = data.remove(&id) {
                let duration = span_data.start_time.elapsed();

                if let Some(span) = ctx.span(&id) {
                    let metadata = span.metadata();

                    let performance_event = PerformanceEvent {
                        timestamp: SystemTime::now()
                            .duration_since(UNIX_EPOCH)
                            .unwrap_or_default()
                            .as_millis() as u64,
                        event_type: "PerformanceMetric".to_string(),
                        span_name: metadata.name().to_string(),
                        duration_ms: duration.as_secs_f64() * 1000.0,
                        context: serde_json::to_value(&span_data.metadata).unwrap_or_default(),
                    };

                    self.event_sender.send_performance_event(performance_event);
                }
            }
        }
    }
}

/// 验证规则ID常量
pub mod validation_rules {
    pub const SYMBOL_INDEX_STABILITY: &str = "SYMBOL_INDEX_STABILITY";
    pub const KLINE_OPEN_TIME_ACCURACY: &str = "KLINE_OPEN_TIME_ACCURACY";
    pub const KLINE_IS_FINAL_CORRECTNESS: &str = "KLINE_IS_FINAL_CORRECTNESS";
    pub const EMPTY_KLINE_HANDLING: &str = "EMPTY_KLINE_HANDLING";
    pub const BUFFER_SWAP_NOTIFICATION: &str = "BUFFER_SWAP_NOTIFICATION";
    pub const PERSISTENCE_UPSERT_LOGIC: &str = "PERSISTENCE_UPSERT_LOGIC";
    pub const DATA_FLOW_INTEGRITY: &str = "DATA_FLOW_INTEGRITY";
}
