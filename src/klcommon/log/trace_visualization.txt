//! å‡½æ•°æ‰§è¡Œè·¯å¾„å¯è§†åŒ–æ¨¡å—
//! 
//! ä¸“é—¨ç”¨äºæ”¯æŒå‰ç«¯çš„å‡½æ•°è°ƒç”¨é“¾è·¯è¿½è¸ªå’Œå¯è§†åŒ–

use serde_json;
use std::time::Instant;
use tracing::{Event, Id, Subscriber};
use tracing_subscriber::{layer::Context, Layer};
use std::fmt;

// é‡æ–°å¯¼å…¥éœ€è¦çš„ç±»å‹
use super::observability::NamedPipeLogManager;
use std::sync::Arc;

/// Traceå¯è§†åŒ–å±‚ - ä¸“é—¨ç”¨äºå‡½æ•°æ‰§è¡Œè·¯å¾„å¯è§†åŒ–
pub struct TraceVisualizationLayer {
    manager: Arc<NamedPipeLogManager>,
}

impl TraceVisualizationLayer {
    /// åˆ›å»ºä¸€ä¸ªæ–°çš„ Trace å¯è§†åŒ–å±‚
    /// å®ƒéœ€è¦ä¸€ä¸ªå·²ç»åˆ›å»ºå¥½çš„ã€å¯å…±äº«çš„ NamedPipeLogManager å®ä¾‹
    pub fn new(manager: Arc<NamedPipeLogManager>) -> Self {
        Self { manager }
    }

    /// åˆ›å»ºå‘½åç®¡é“traceå¯è§†åŒ–å±‚ï¼ˆå‘åå…¼å®¹ï¼‰
    pub fn new_named_pipe(pipe_name: String) -> Self {
        let manager = Arc::new(NamedPipeLogManager::new(pipe_name));
        manager.start_connection_task();
        Self::new(manager)
    }
}

/// å¸®åŠ©ä» Span å±æ€§ä¸­æå–å­—æ®µçš„è®¿é—®å™¨
pub struct JsonVisitor<'a> {
    fields: &'a mut serde_json::Map<String, serde_json::Value>,
}

impl<'a> JsonVisitor<'a> {
    pub fn new(fields: &'a mut serde_json::Map<String, serde_json::Value>) -> Self {
        Self { fields }
    }
}

impl<'a> tracing::field::Visit for JsonVisitor<'a> {
    fn record_f64(&mut self, field: &tracing::field::Field, value: f64) { 
        self.fields.insert(field.name().to_string(), serde_json::json!(value)); 
    }
    
    fn record_i64(&mut self, field: &tracing::field::Field, value: i64) { 
        self.fields.insert(field.name().to_string(), serde_json::json!(value)); 
    }
    
    fn record_u64(&mut self, field: &tracing::field::Field, value: u64) { 
        self.fields.insert(field.name().to_string(), serde_json::json!(value)); 
    }
    
    fn record_bool(&mut self, field: &tracing::field::Field, value: bool) { 
        self.fields.insert(field.name().to_string(), serde_json::json!(value)); 
    }
    
    fn record_str(&mut self, field: &tracing::field::Field, value: &str) { 
        self.fields.insert(field.name().to_string(), serde_json::json!(value)); 
    }
    
    fn record_debug(&mut self, field: &tracing::field::Field, value: &dyn fmt::Debug) {
        self.fields.insert(field.name().to_string(), serde_json::json!(format!("{:?}", value)));
    }
}

// Spanç”Ÿå‘½å‘¨æœŸä¸­éœ€è¦å­˜å‚¨çš„ä¸´æ—¶æ•°æ®
#[derive(Clone)]
struct SpanData {
    start_time: Instant,
}

impl<S> Layer<S> for TraceVisualizationLayer
where
    S: Subscriber + for<'lookup> tracing_subscriber::registry::LookupSpan<'lookup>,
{
    // on_new_span æ˜¯ç”Ÿæˆ span_start äº‹ä»¶çš„æœ€ä½³æ—¶æœº
    fn on_new_span(&self, _attrs: &tracing::span::Attributes<'_>, id: &Id, ctx: Context<'_, S>) {
        let span = if let Some(span) = ctx.span(id) { span } else { return };

        // å­˜å‚¨å¼€å§‹æ—¶é—´
        let mut extensions = span.extensions_mut();
        if extensions.get_mut::<SpanData>().is_none() {
            extensions.insert(SpanData {
                start_time: Instant::now(),
            });
        }

        let metadata = span.metadata();

        // ç¡®å®š parent_id
        let parent_id = span.parent().map(|p| format!("span_{}", p.id().into_u64()));

        // ç”Ÿæˆ trace_id
        let trace_id = {
            fn find_root_id<S: for<'a> tracing_subscriber::registry::LookupSpan<'a>>(span: &tracing_subscriber::registry::SpanRef<S>) -> Id {
                span.parent().map_or_else(|| span.id(), |p| find_root_id(&p))
            }
            format!("trace_{}", find_root_id(&span).into_u64())
        };

        // æ„å»º trace å¯è§†åŒ–æ—¥å¿— - æ·»åŠ æ—¥å¿—ç±»å‹æ ‡è¯†
        let span_event = serde_json::json!({
            "log_type": "trace", // ğŸ·ï¸ æ ‡è¯†è¿™æ˜¯ trace å¯è§†åŒ–æ—¥å¿—
            "timestamp": chrono::Utc::now().to_rfc3339(),
            "level": metadata.level().to_string(),
            "target": metadata.target(),
            "message": format!("Span started: {}", metadata.name()),
            "fields": {
                "event_type": "span_start",
                "trace_id": trace_id,
                "span_id": format!("span_{}", id.into_u64()),
                "parent_id": parent_id,
                "span_name": metadata.name(),
            }
        });

        if let Ok(log_line) = serde_json::to_string(&span_event) {
            let manager = self.manager.clone();
            if let Ok(handle) = tokio::runtime::Handle::try_current() {
                handle.spawn(async move {
                    manager.send_log(log_line).await;
                });
            }
        }
    }



    // on_close æ˜¯ç”Ÿæˆ span_end äº‹ä»¶çš„æœ€ä½³æ—¶æœº
    fn on_close(&self, id: Id, ctx: Context<'_, S>) {
        let span = if let Some(span) = ctx.span(&id) { span } else { return };

        let duration_ms = span.extensions()
            .get::<SpanData>()
            .map(|d| d.start_time.elapsed().as_secs_f64() * 1000.0)
            .unwrap_or(0.0);

        let metadata = span.metadata();

        let trace_id = {
            fn find_root_id<S: for<'a> tracing_subscriber::registry::LookupSpan<'a>>(span: &tracing_subscriber::registry::SpanRef<S>) -> Id {
                span.parent().map_or_else(|| span.id(), |p| find_root_id(&p))
            }
            format!("trace_{}", find_root_id(&span).into_u64())
        };

        let span_event = serde_json::json!({
            "log_type": "trace", // ğŸ·ï¸ æ ‡è¯†è¿™æ˜¯ trace å¯è§†åŒ–æ—¥å¿—
            "timestamp": chrono::Utc::now().to_rfc3339(),
            "level": metadata.level().to_string(),
            "target": metadata.target(),
            "message": format!("Span ended: {:.2}ms", duration_ms),
            "fields": {
                "event_type": "span_end",
                "trace_id": trace_id,
                "span_id": format!("span_{}", id.into_u64()),
                "span_name": metadata.name(),
                "duration_ms": duration_ms,
            }
        });

        if let Ok(log_line) = serde_json::to_string(&span_event) {
            let manager = self.manager.clone();
            if let Ok(handle) = tokio::runtime::Handle::try_current() {
                handle.spawn(async move {
                    manager.send_log(log_line).await;
                });
            }
        }
    }

    // on_event ç”¨äºæ•è·æ‰€æœ‰åœ¨ Span å†…éƒ¨çš„æ—¥å¿—äº‹ä»¶
    fn on_event(&self, event: &Event<'_>, ctx: Context<'_, S>) {
        // ç¡®ä¿äº‹ä»¶åœ¨ Span å†…éƒ¨
        if let Some(span) = ctx.lookup_current() {
            let metadata = event.metadata();
            let mut fields = serde_json::Map::new();
            let mut visitor = JsonVisitor::new(&mut fields);
            event.record(&mut visitor);

            let message = fields.remove("message")
                .and_then(|v| v.as_str().map(ToString::to_string))
                .unwrap_or_else(|| "Log event with no message".to_string());

            fn find_root_id<S: for<'a> tracing_subscriber::registry::LookupSpan<'a>>(span: &tracing_subscriber::registry::SpanRef<S>) -> Id {
                span.parent().map_or_else(|| span.id(), |p| find_root_id(&p))
            }
            let trace_id = Some(format!("trace_{}", find_root_id(&span).into_u64()));
            let span_id = Some(format!("span_{}", span.id().into_u64()));

            let log_event = serde_json::json!({
                "log_type": "trace", // ğŸ·ï¸ æ ‡è¯†è¿™æ˜¯ trace å¯è§†åŒ–æ—¥å¿—
                "timestamp": chrono::Utc::now().to_rfc3339(),
                "level": metadata.level().to_string(),
                "target": metadata.target(),
                "message": message,
                "fields": {
                    "event_type": "log",
                    "trace_id": trace_id,
                    "span_id": span_id,
                }
            });

            if let Ok(log_line) = serde_json::to_string(&log_event) {
                let manager = self.manager.clone();
                if let Ok(handle) = tokio::runtime::Handle::try_current() {
                    handle.spawn(async move {
                        manager.send_log(log_line).await;
                    });
                }
            }
        }
    }
}
