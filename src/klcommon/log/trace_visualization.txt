//! 函数执行路径可视化模块
//! 
//! 专门用于支持前端的函数调用链路追踪和可视化

use serde_json;
use std::time::Instant;
use tracing::{Event, Id, Subscriber};
use tracing_subscriber::{layer::Context, Layer};
use std::fmt;

// 重新导入需要的类型
use super::observability::NamedPipeLogManager;
use std::sync::Arc;

/// Trace可视化层 - 专门用于函数执行路径可视化
pub struct TraceVisualizationLayer {
    manager: Arc<NamedPipeLogManager>,
}

impl TraceVisualizationLayer {
    /// 创建一个新的 Trace 可视化层
    /// 它需要一个已经创建好的、可共享的 NamedPipeLogManager 实例
    pub fn new(manager: Arc<NamedPipeLogManager>) -> Self {
        Self { manager }
    }

    /// 创建命名管道trace可视化层（向后兼容）
    pub fn new_named_pipe(pipe_name: String) -> Self {
        let manager = Arc::new(NamedPipeLogManager::new(pipe_name));
        manager.start_connection_task();
        Self::new(manager)
    }
}

/// 帮助从 Span 属性中提取字段的访问器
pub struct JsonVisitor<'a> {
    fields: &'a mut serde_json::Map<String, serde_json::Value>,
}

impl<'a> JsonVisitor<'a> {
    pub fn new(fields: &'a mut serde_json::Map<String, serde_json::Value>) -> Self {
        Self { fields }
    }
}

impl<'a> tracing::field::Visit for JsonVisitor<'a> {
    fn record_f64(&mut self, field: &tracing::field::Field, value: f64) { 
        self.fields.insert(field.name().to_string(), serde_json::json!(value)); 
    }
    
    fn record_i64(&mut self, field: &tracing::field::Field, value: i64) { 
        self.fields.insert(field.name().to_string(), serde_json::json!(value)); 
    }
    
    fn record_u64(&mut self, field: &tracing::field::Field, value: u64) { 
        self.fields.insert(field.name().to_string(), serde_json::json!(value)); 
    }
    
    fn record_bool(&mut self, field: &tracing::field::Field, value: bool) { 
        self.fields.insert(field.name().to_string(), serde_json::json!(value)); 
    }
    
    fn record_str(&mut self, field: &tracing::field::Field, value: &str) { 
        self.fields.insert(field.name().to_string(), serde_json::json!(value)); 
    }
    
    fn record_debug(&mut self, field: &tracing::field::Field, value: &dyn fmt::Debug) {
        self.fields.insert(field.name().to_string(), serde_json::json!(format!("{:?}", value)));
    }
}

// Span生命周期中需要存储的临时数据
#[derive(Clone)]
struct SpanData {
    start_time: Instant,
}

impl<S> Layer<S> for TraceVisualizationLayer
where
    S: Subscriber + for<'lookup> tracing_subscriber::registry::LookupSpan<'lookup>,
{
    // on_new_span 是生成 span_start 事件的最佳时机
    fn on_new_span(&self, _attrs: &tracing::span::Attributes<'_>, id: &Id, ctx: Context<'_, S>) {
        let span = if let Some(span) = ctx.span(id) { span } else { return };

        // 存储开始时间
        let mut extensions = span.extensions_mut();
        if extensions.get_mut::<SpanData>().is_none() {
            extensions.insert(SpanData {
                start_time: Instant::now(),
            });
        }

        let metadata = span.metadata();

        // 确定 parent_id
        let parent_id = span.parent().map(|p| format!("span_{}", p.id().into_u64()));

        // 生成 trace_id
        let trace_id = {
            fn find_root_id<S: for<'a> tracing_subscriber::registry::LookupSpan<'a>>(span: &tracing_subscriber::registry::SpanRef<S>) -> Id {
                span.parent().map_or_else(|| span.id(), |p| find_root_id(&p))
            }
            format!("trace_{}", find_root_id(&span).into_u64())
        };

        // 构建 trace 可视化日志 - 添加日志类型标识
        let span_event = serde_json::json!({
            "log_type": "trace", // 🏷️ 标识这是 trace 可视化日志
            "timestamp": chrono::Utc::now().to_rfc3339(),
            "level": metadata.level().to_string(),
            "target": metadata.target(),
            "message": format!("Span started: {}", metadata.name()),
            "fields": {
                "event_type": "span_start",
                "trace_id": trace_id,
                "span_id": format!("span_{}", id.into_u64()),
                "parent_id": parent_id,
                "span_name": metadata.name(),
            }
        });

        if let Ok(log_line) = serde_json::to_string(&span_event) {
            let manager = self.manager.clone();
            if let Ok(handle) = tokio::runtime::Handle::try_current() {
                handle.spawn(async move {
                    manager.send_log(log_line).await;
                });
            }
        }
    }



    // on_close 是生成 span_end 事件的最佳时机
    fn on_close(&self, id: Id, ctx: Context<'_, S>) {
        let span = if let Some(span) = ctx.span(&id) { span } else { return };

        let duration_ms = span.extensions()
            .get::<SpanData>()
            .map(|d| d.start_time.elapsed().as_secs_f64() * 1000.0)
            .unwrap_or(0.0);

        let metadata = span.metadata();

        let trace_id = {
            fn find_root_id<S: for<'a> tracing_subscriber::registry::LookupSpan<'a>>(span: &tracing_subscriber::registry::SpanRef<S>) -> Id {
                span.parent().map_or_else(|| span.id(), |p| find_root_id(&p))
            }
            format!("trace_{}", find_root_id(&span).into_u64())
        };

        let span_event = serde_json::json!({
            "log_type": "trace", // 🏷️ 标识这是 trace 可视化日志
            "timestamp": chrono::Utc::now().to_rfc3339(),
            "level": metadata.level().to_string(),
            "target": metadata.target(),
            "message": format!("Span ended: {:.2}ms", duration_ms),
            "fields": {
                "event_type": "span_end",
                "trace_id": trace_id,
                "span_id": format!("span_{}", id.into_u64()),
                "span_name": metadata.name(),
                "duration_ms": duration_ms,
            }
        });

        if let Ok(log_line) = serde_json::to_string(&span_event) {
            let manager = self.manager.clone();
            if let Ok(handle) = tokio::runtime::Handle::try_current() {
                handle.spawn(async move {
                    manager.send_log(log_line).await;
                });
            }
        }
    }

    // on_event 用于捕获所有在 Span 内部的日志事件
    fn on_event(&self, event: &Event<'_>, ctx: Context<'_, S>) {
        // 确保事件在 Span 内部
        if let Some(span) = ctx.lookup_current() {
            let metadata = event.metadata();
            let mut fields = serde_json::Map::new();
            let mut visitor = JsonVisitor::new(&mut fields);
            event.record(&mut visitor);

            let message = fields.remove("message")
                .and_then(|v| v.as_str().map(ToString::to_string))
                .unwrap_or_else(|| "Log event with no message".to_string());

            fn find_root_id<S: for<'a> tracing_subscriber::registry::LookupSpan<'a>>(span: &tracing_subscriber::registry::SpanRef<S>) -> Id {
                span.parent().map_or_else(|| span.id(), |p| find_root_id(&p))
            }
            let trace_id = Some(format!("trace_{}", find_root_id(&span).into_u64()));
            let span_id = Some(format!("span_{}", span.id().into_u64()));

            let log_event = serde_json::json!({
                "log_type": "trace", // 🏷️ 标识这是 trace 可视化日志
                "timestamp": chrono::Utc::now().to_rfc3339(),
                "level": metadata.level().to_string(),
                "target": metadata.target(),
                "message": message,
                "fields": {
                    "event_type": "log",
                    "trace_id": trace_id,
                    "span_id": span_id,
                }
            });

            if let Ok(log_line) = serde_json::to_string(&log_event) {
                let manager = self.manager.clone();
                if let Ok(handle) = tokio::runtime::Handle::try_current() {
                    handle.spawn(async move {
                        manager.send_log(log_line).await;
                    });
                }
            }
        }
    }
}
