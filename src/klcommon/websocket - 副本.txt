// WebSocketæ¨¡å— - æä¾›é€šç”¨çš„WebSocketè¿æ¥ç®¡ç†åŠŸèƒ½ (ä½¿ç”¨ fastwebsockets å®ç°)
use crate::klcommon::{AppError, Result, PROXY_HOST, PROXY_PORT};
use tracing::{info, error, debug, warn, trace, instrument, Instrument};
use std::sync::Arc;
use std::collections::HashMap;
use std::time::{Duration, Instant};
use std::fs::create_dir_all;
use std::path::Path;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::future::Future;
use tokio::sync::Mutex as TokioMutex;
use tokio::sync::mpsc;
use tokio::net::TcpStream;
use tokio::time::sleep;
use tokio_socks::tcp::Socks5Stream;
use serde_json::json;
use serde::Deserialize;

use bytes::Bytes;
use fastwebsockets::{FragmentCollector, Frame, OpCode};
use hyper_util::rt::tokio::TokioIo;
use hyper::upgrade::Upgraded;
use http_body_util::Empty;
use hyper::header::{CONNECTION, UPGRADE};
use hyper::Request;
use tokio_rustls::rustls::{ClientConfig, OwnedTrustAnchor, ServerName};
use tokio_rustls::TlsConnector;


//=============================================================================
// å¸¸é‡å’Œé…ç½®
//=============================================================================

/// å¸å®‰WebSocket URL
pub const BINANCE_WS_URL: &str = "wss://fstream.binance.com/ws";

/// WebSocketè¿æ¥æ•°é‡
/// æ‰€æœ‰å“ç§å°†å¹³å‡åˆ†é…åˆ°è¿™äº›è¿æ¥ä¸­
pub const WEBSOCKET_CONNECTION_COUNT: usize = 1;

/// WebSocketè¿æ¥é‡è¯•é…ç½®
pub const MAX_RETRY_ATTEMPTS: usize = 5;
pub const INITIAL_RETRY_DELAY_MS: u64 = 1000; // 1ç§’
pub const MAX_RETRY_DELAY_MS: u64 = 30000; // 30ç§’

/// å½’é›†äº¤æ˜“æ—¥å¿—ç›®æ ‡
pub const AGG_TRADE_TARGET: &str = "å½’é›†äº¤æ˜“";

/// WebSocketè¿æ¥æ—¥å¿—ç›®æ ‡
pub const WEBSOCKET_CONNECTION_TARGET: &str = "websocketè¿æ¥";

/// å…¨å¸‚åœºç²¾ç®€Tickeræ—¥å¿—ç›®æ ‡
pub const MINI_TICKER_TARGET: &str = "å…¨å¸‚åœºç²¾ç®€Ticker";

//=============================================================================
// WebSocketé…ç½®
//=============================================================================

/// WebSocketé…ç½®æ¥å£
pub trait WebSocketConfig {
    /// è·å–ä»£ç†è®¾ç½®
    fn get_proxy_settings(&self) -> (bool, String, u16);
    /// è·å–æµåˆ—è¡¨
    fn get_streams(&self) -> Vec<String>;
}



/// å½’é›†äº¤æ˜“é…ç½®
#[derive(Clone)]
pub struct AggTradeConfig {
    /// æ˜¯å¦ä½¿ç”¨ä»£ç†
    pub use_proxy: bool,
    /// ä»£ç†åœ°å€
    pub proxy_addr: String,
    /// ä»£ç†ç«¯å£
    pub proxy_port: u16,
    /// äº¤æ˜“å¯¹åˆ—è¡¨
    pub symbols: Vec<String>,
}

impl Default for AggTradeConfig {
    fn default() -> Self {
        Self {
            use_proxy: true,
            proxy_addr: PROXY_HOST.to_string(),
            proxy_port: PROXY_PORT,
            symbols: Vec::new(),
        }
    }
}

impl WebSocketConfig for AggTradeConfig {
    // #[instrument] ç§»é™¤ï¼šç®€å•çš„é…ç½®è¯»å–å‡½æ•°ï¼Œè¿½è¸ªä¼šäº§ç”Ÿå™ªéŸ³
    fn get_proxy_settings(&self) -> (bool, String, u16) {
        (self.use_proxy, self.proxy_addr.clone(), self.proxy_port)
    }

    // #[instrument] ç§»é™¤ï¼šç®€å•çš„æµåç§°æ„å»ºå‡½æ•°ï¼Œè¿½è¸ªä¼šäº§ç”Ÿå™ªéŸ³
    fn get_streams(&self) -> Vec<String> {
        self.symbols.iter()
            .map(|symbol| format!("{}@aggTrade", symbol.to_lowercase()))
            .collect()
    }
}

/// å…¨å¸‚åœºç²¾ç®€Tickerçš„WebSocketé…ç½®
#[derive(Clone)]
pub struct MiniTickerConfig {
    /// æ˜¯å¦ä½¿ç”¨ä»£ç†
    pub use_proxy: bool,
    /// ä»£ç†åœ°å€
    pub proxy_addr: String,
    /// ä»£ç†ç«¯å£
    pub proxy_port: u16,
}

impl Default for MiniTickerConfig {
    fn default() -> Self {
        Self {
            use_proxy: true,
            proxy_addr: PROXY_HOST.to_string(),
            proxy_port: PROXY_PORT,
        }
    }
}

impl WebSocketConfig for MiniTickerConfig {
    fn get_proxy_settings(&self) -> (bool, String, u16) {
        (self.use_proxy, self.proxy_addr.clone(), self.proxy_port)
    }

    fn get_streams(&self) -> Vec<String> {
        // Note: è¿™ä¸ªæµæ˜¯å›ºå®šçš„ï¼Œä¸éœ€è¦ä»»ä½•å‚æ•°ã€‚
        vec!["!miniTicker@arr".to_string()]
    }
}

/// åˆ›å»ºè®¢é˜…æ¶ˆæ¯
#[instrument(skip_all)]
pub fn create_subscribe_message(streams: &[String]) -> String {
    json!({
        "method": "SUBSCRIBE",
        "params": streams,
        "id": 1
    })
    .to_string()
}

//=============================================================================
// WebSocketå®¢æˆ·ç«¯æ¥å£
//=============================================================================

/// WebSocketè¿æ¥çŠ¶æ€
#[derive(Debug, Clone)]
pub struct WebSocketConnection {
    pub id: usize,
    pub streams: Vec<String>,
    pub status: String,
    pub message_count: usize,
}

/// WebSocketå®¢æˆ·ç«¯æ¥å£
pub trait WebSocketClient {
    /// å¯åŠ¨WebSocketå®¢æˆ·ç«¯
    fn start(&mut self) -> impl std::future::Future<Output = Result<()>> + Send;

    /// è·å–è¿æ¥çŠ¶æ€
    fn get_connections(&self) -> impl std::future::Future<Output = Vec<WebSocketConnection>> + Send;
}

//=============================================================================
// æ•°æ®ç»“æ„
//=============================================================================

/// å…¨å¸‚åœºç²¾ç®€Tickeræ•°æ®
///
/// ä» `!miniTicker@arr` æµæ¥æ”¶ã€‚
#[derive(serde::Deserialize, Debug, Clone)]
pub struct MiniTickerData {
    #[serde(rename = "e")]
    pub event_type: String,
    #[serde(rename = "E")]
    pub event_time: u64,
    #[serde(rename = "s")]
    pub symbol: String,
    #[serde(rename = "c")]
    pub close_price: String,
    #[serde(rename = "o")]
    pub open_price: String,
    #[serde(rename = "h")]
    pub high_price: String,
    #[serde(rename = "l")]
    pub low_price: String,
    #[serde(rename = "v")]
    pub total_traded_volume: String,
    #[serde(rename = "q")]
    pub total_traded_quote_volume: String,
}

/// å¸å®‰åŸå§‹å½’é›†äº¤æ˜“æ•°æ®
#[derive(Debug, Clone)]
pub struct BinanceRawAggTrade {
    pub event_type: String,
    pub event_time: u64,
    pub symbol: String,
    pub aggregate_trade_id: u64,
    pub price: String,
    pub quantity: String,
    pub first_trade_id: u64,
    pub last_trade_id: u64,
    pub trade_time: u64,
    pub is_buyer_maker: bool,
}

/// å½’é›†äº¤æ˜“æ•°æ® - ä»WebSocketæ¥æ”¶çš„åŸå§‹æ•°æ®è§£æåçš„ç»“æ„
///
/// è¿™æ˜¯ç³»ç»Ÿä¸­AggTradeDataçš„æƒå¨å®šä¹‰ï¼ŒåŒ…å«å¸å®‰åŸå§‹æ•°æ®çš„æ‰€æœ‰å­—æ®µ
/// ä½¿ç”¨ #[repr(C)] ç¡®ä¿å†…å­˜å¸ƒå±€çš„å¯é¢„æµ‹æ€§ï¼Œæé«˜ç¼“å­˜æ•ˆç‡
#[repr(C)]
#[derive(Debug, Clone, Deserialize)]
pub struct AggTradeData {
    /// äº¤æ˜“å“ç§
    pub symbol: String,
    /// æˆäº¤ä»·æ ¼
    pub price: f64,
    /// æˆäº¤æ•°é‡
    pub quantity: f64,
    /// æˆäº¤æ—¶é—´æˆ³ï¼ˆæ¯«ç§’ï¼‰
    pub timestamp_ms: i64,
    /// ä¹°æ–¹æ˜¯å¦ä¸ºåšå¸‚å•†
    pub is_buyer_maker: bool,
    /// å½’é›†äº¤æ˜“ID
    pub agg_trade_id: i64,
    /// é¦–ä¸ªäº¤æ˜“ID
    pub first_trade_id: i64,
    /// æœ€åäº¤æ˜“ID
    pub last_trade_id: i64,
    /// äº‹ä»¶æ—¶é—´æˆ³ï¼ˆæ¯«ç§’ï¼‰
    pub event_time_ms: i64,
}

impl AggTradeData {
    /// ä»å¸å®‰åŸå§‹å½’é›†äº¤æ˜“æ•°æ®åˆ›å»º
    pub fn from_binance_raw(raw: &BinanceRawAggTrade) -> Self {
        Self {
            symbol: raw.symbol.clone(),
            price: raw.price.parse().unwrap_or(0.0),
            quantity: raw.quantity.parse().unwrap_or(0.0),
            timestamp_ms: raw.trade_time as i64,
            is_buyer_maker: raw.is_buyer_maker,
            agg_trade_id: raw.aggregate_trade_id as i64,
            first_trade_id: raw.first_trade_id as i64,
            last_trade_id: raw.last_trade_id as i64,
            event_time_ms: raw.event_time as i64,
        }
    }
}

//=============================================================================
// æ¶ˆæ¯å¤„ç†
//=============================================================================

/// æ¶ˆæ¯å¤„ç†æ¥å£
pub trait MessageHandler {
    /// å¤„ç†WebSocketæ¶ˆæ¯
    fn handle_message(&self, connection_id: usize, message: String) -> impl std::future::Future<Output = Result<()>> + Send;
}

/// å…¬å¼€çš„WebSocketå‘½ä»¤ï¼Œç”¨äºåŠ¨æ€æ§åˆ¶
#[derive(Debug, Clone)]
pub enum WsCommand {
    Subscribe(Vec<String>),
    // æœªæ¥å¯ä»¥æ‰©å±• Unsubscribe ç­‰
}

/// ç”¨äºå°è£…ä¸åŒç±»å‹é€šé“å‘é€ç«¯çš„æšä¸¾ï¼Œæä¾›äº†ç»Ÿä¸€çš„å‘é€æ¥å£ã€‚
enum TradeSender {
    Unbounded(tokio::sync::mpsc::UnboundedSender<AggTradeData>),
    Bounded(tokio::sync::mpsc::Sender<AggTradeData>),
}

impl TradeSender {
    /// ç»Ÿä¸€çš„å¼‚æ­¥å‘é€æ–¹æ³•ï¼Œèƒ½æ­£ç¡®å¤„ç†ä¸åŒé€šé“çš„èƒŒå‹ã€‚
    async fn send(&self, data: AggTradeData) -> std::result::Result<(), String> {
        match self {
            TradeSender::Unbounded(s) => s.send(data).map_err(|e| format!("Unbounded send error: {}", e)),
            // [å…³é”®ä¿®æ”¹] ä½¿ç”¨ .await æ¥å¼‚æ­¥å‘é€ï¼Œæ­£ç¡®å¤„ç†èƒŒå‹
            TradeSender::Bounded(s) => s.send(data).await.map_err(|e| format!("Bounded send error: {}", e)),
        }
    }
}

/// å½’é›†äº¤æ˜“æ¶ˆæ¯å¤„ç†å™¨ï¼Œç”¨äºKçº¿èšåˆç³»ç»Ÿ
pub struct AggTradeMessageHandler {
    pub message_count: Arc<std::sync::atomic::AtomicUsize>,
    pub error_count: Arc<std::sync::atomic::AtomicUsize>,
    // [ä¿®æ”¹] ä½¿ç”¨ä¸€ä¸ªæšä¸¾æ¥ç»Ÿä¸€è¡¨ç¤ºä¸åŒç±»å‹çš„å‘é€è€…ï¼Œä½¿ç»“æ„æ›´æ¸…æ™°
    sender: Option<TradeSender>,
}

impl AggTradeMessageHandler {
    #[instrument(skip_all)]
    pub fn new(
        message_count: Arc<std::sync::atomic::AtomicUsize>,
        error_count: Arc<std::sync::atomic::AtomicUsize>,
    ) -> Self {
        Self {
            message_count,
            error_count,
            sender: None,
        }
    }

    /// åˆ›å»ºå¸¦æœ‰æ— ç•Œäº¤æ˜“æ•°æ®å‘é€å™¨çš„æ¶ˆæ¯å¤„ç†å™¨
    #[instrument(skip_all)]
    pub fn with_unbounded_sender(
        message_count: Arc<std::sync::atomic::AtomicUsize>,
        error_count: Arc<std::sync::atomic::AtomicUsize>,
        trade_sender: tokio::sync::mpsc::UnboundedSender<AggTradeData>,
    ) -> Self {
        Self {
            message_count,
            error_count,
            sender: Some(TradeSender::Unbounded(trade_sender)),
        }
    }

    /// åˆ›å»ºå¸¦æœ‰æœ‰ç•Œäº¤æ˜“æ•°æ®å‘é€å™¨çš„æ¶ˆæ¯å¤„ç†å™¨
    #[instrument(skip_all)]
    pub fn with_bounded_sender(
        message_count: Arc<std::sync::atomic::AtomicUsize>,
        error_count: Arc<std::sync::atomic::AtomicUsize>,
        bounded_trade_sender: tokio::sync::mpsc::Sender<AggTradeData>,
    ) -> Self {
        Self {
            message_count,
            error_count,
            sender: Some(TradeSender::Bounded(bounded_trade_sender)),
        }
    }
}

/// å…¨å¸‚åœºç²¾ç®€Tickeræ¶ˆæ¯å¤„ç†å™¨
pub struct MiniTickerMessageHandler {
    /// ç”¨äºå°†è§£æåçš„æ•°æ®å‘å¤–å‘é€çš„é€šé“
    pub data_sender: tokio::sync::mpsc::UnboundedSender<Vec<MiniTickerData>>,
}

impl MiniTickerMessageHandler {
    /// åˆ›å»ºä¸€ä¸ªæ–°çš„ MiniTickerMessageHandler
    pub fn new(data_sender: tokio::sync::mpsc::UnboundedSender<Vec<MiniTickerData>>) -> Self {
        Self { data_sender }
    }
}

impl MessageHandler for MiniTickerMessageHandler {
    fn handle_message(&self, connection_id: usize, message: String) -> impl std::future::Future<Output = Result<()>> + Send {
        async move {
            // MiniTicker æµç›´æ¥æ˜¯ä¸€ä¸ªJSONæ•°ç»„
            match serde_json::from_str::<Vec<MiniTickerData>>(&message) {
                Ok(tickers) => {
                    debug!(target: MINI_TICKER_TARGET, "è¿æ¥ {} æ”¶åˆ° {} æ¡ MiniTicker æ›´æ–°", connection_id, tickers.len());
                    // å°†è§£æåçš„æ•°æ®å‘é€å‡ºå»
                    if let Err(e) = self.data_sender.send(tickers) {
                        error!(target: MINI_TICKER_TARGET, "å‘é€ MiniTicker æ•°æ®å¤±è´¥: {}", e);
                    }
                }
                Err(e) => {
                    // æ£€æŸ¥æ˜¯å¦æ˜¯è®¢é˜…æˆåŠŸç­‰éæ•°æ®æ¶ˆæ¯
                    if !message.contains("result") {
                         warn!(target: MINI_TICKER_TARGET, "è¿æ¥ {} è§£æ MiniTicker æ¶ˆæ¯å¤±è´¥: {}, åŸå§‹æ¶ˆæ¯: {}", connection_id, e, message);
                    }
                }
            }
            Ok(())
        }
    }
}

impl MessageHandler for AggTradeMessageHandler {
    fn handle_message(&self, connection_id: usize, message: String) -> impl std::future::Future<Output = Result<()>> + Send {
        async move {
            // å¢åŠ æ¶ˆæ¯è®¡æ•°
            self.message_count.fetch_add(1, std::sync::atomic::Ordering::Relaxed);

            // [æ–°å¢æ—¥å¿—] L1 - handle_message å¼€å§‹å¤„ç†
            trace!(target: AGG_TRADE_TARGET, connection_id, "L1 - handle_message å¼€å§‹å¤„ç†");

            // è§£æå½’é›†äº¤æ˜“æ¶ˆæ¯
            match self.parse_agg_trade_message(&message).await {
                Ok(Some(agg_trade)) => {
                    // [æ–°å¢æ—¥å¿—] L2 - è·¯å¾„A: parseæˆåŠŸ, æ˜¯aggTrade
                    trace!(target: AGG_TRADE_TARGET, connection_id, "L2 - è·¯å¾„A: parseæˆåŠŸ, æ˜¯aggTrade");

                    info!(target: AGG_TRADE_TARGET, "è¿æ¥ {} æ”¶åˆ°å½’é›†äº¤æ˜“: {} {} @ {}",
                        connection_id, agg_trade.symbol, agg_trade.quantity, agg_trade.price);

                    // å°†å½’é›†äº¤æ˜“æ•°æ®å‘é€ç»™TradeEventRouter
                    let trade_data = AggTradeData::from_binance_raw(&agg_trade);

                    // [ä¿®æ”¹] ä½¿ç”¨ç»Ÿä¸€çš„å¼‚æ­¥å‘é€é€»è¾‘
                    if let Some(ref sender) = self.sender {
                        if let Err(e) = sender.send(trade_data).await { // æ³¨æ„è¿™é‡Œçš„ .await
                            error!(target: AGG_TRADE_TARGET, "å‘é€å½’é›†äº¤æ˜“æ•°æ®å¤±è´¥: {}", e);
                            self.error_count.fetch_add(1, std::sync::atomic::Ordering::Relaxed);
                        }
                    } else {
                         warn!(target: AGG_TRADE_TARGET, "æ²¡æœ‰é…ç½®äº¤æ˜“æ•°æ®å‘é€å™¨ï¼Œè·³è¿‡æ•°æ®è·¯ç”±");
                    }

                    Ok(())
                }
                Ok(None) => {
                    // [æ–°å¢æ—¥å¿—] L2 - è·¯å¾„B: parseæˆåŠŸ, ä½†ä¸æ˜¯aggTrade
                    trace!(target: AGG_TRADE_TARGET, connection_id, "L2 - è·¯å¾„B: parseæˆåŠŸ, ä½†ä¸æ˜¯aggTrade");

                    // éå½’é›†äº¤æ˜“æ¶ˆæ¯ï¼Œå¯èƒ½æ˜¯è®¢é˜…ç¡®è®¤ç­‰
                    if let Ok(json) = serde_json::from_str::<serde_json::Value>(&message) {
                        // ç»Ÿä¸€å¤„ç†æ‰€æœ‰åŒ…å« "id" çš„å“åº”æ¶ˆæ¯ï¼Œæ— è®ºæˆåŠŸæˆ–å¤±è´¥
                        if json.get("id").is_some() {
                            // [æ–°å¢æ—¥å¿—] L3 - è·¯å¾„B.1: æ˜¯ä¸€ä¸ªå¸¦IDçš„å“åº”æ¶ˆæ¯
                            trace!(target: AGG_TRADE_TARGET, connection_id, "L3 - è·¯å¾„B.1: æ˜¯ä¸€ä¸ªå¸¦IDçš„å“åº”æ¶ˆæ¯");
                            if let Some(error) = json.get("error") {
                                // æ˜ç¡®åœ°æ•è·å¹¶è®°å½•é”™è¯¯å“åº”
                                tracing::error!(
                                    target: AGG_TRADE_TARGET,
                                    log_type = "subscription_error",
                                    connection_id = connection_id,
                                    error_details = %error,
                                    raw_message = %message,
                                    "âŒ WebSocketè®¢é˜…å¤±è´¥æˆ–å‘ç”Ÿé”™è¯¯ï¼"
                                );
                            } else if let Some(result) = json.get("result") {
                                // æ•è·æˆåŠŸçš„å“åº”
                                tracing::info!(
                                    target: AGG_TRADE_TARGET,
                                    log_type = "low_freq",
                                    connection_id = connection_id,
                                    message_type = "è®¢é˜…å“åº”",
                                    result = %result,
                                    raw_message = %message,
                                    "âœ… WebSocketæ”¶åˆ°è®¢é˜…å“åº”"
                                );

                                // [æ–°å¢] é¢å¤–çš„ç®€åŒ–æ—¥å¿—ï¼Œç¡®ä¿è®¢é˜…ç¡®è®¤å¯è§
                                info!(target: AGG_TRADE_TARGET, "ğŸ¯ è¿æ¥ {} è®¢é˜…ç¡®è®¤: result={}", connection_id, result);
                            } else {
                                // å…¶ä»–åŒ…å« "id" ä½†æ ¼å¼æœªçŸ¥çš„å“åº”
                                tracing::warn!(
                                    target: AGG_TRADE_TARGET,
                                    log_type = "low_freq",
                                    connection_id = connection_id,
                                    message_type = "æœªçŸ¥IDå“åº”",
                                    raw_message = %message,
                                    "æ”¶åˆ°ä¸€ä¸ªæœªçŸ¥çš„å¸¦IDçš„å“åº”æ¶ˆæ¯"
                                );
                            }
                        } else if let Some(event_type) = json.get("e").and_then(|e| e.as_str()) {
                            // [æ–°å¢æ—¥å¿—] L3 - è·¯å¾„B.2: æ˜¯å…¶ä»–ç±»å‹çš„äº‹ä»¶
                            trace!(target: AGG_TRADE_TARGET, connection_id, "L3 - è·¯å¾„B.2: æ˜¯å…¶ä»–ç±»å‹çš„äº‹ä»¶");

                            // ä¿ç•™å¯¹å…¶ä»–ç±»å‹äº‹ä»¶çš„æ—¥å¿—è®°å½•
                            tracing::info!(
                                target: AGG_TRADE_TARGET,
                                log_type = "low_freq",
                                connection_id = connection_id,
                                event_type = %event_type,
                                "è¿æ¥æ”¶åˆ°éè®¢é˜…å“åº”çš„äº‹ä»¶æ¶ˆæ¯"
                            );
                        } else {
                            // [æ–°å¢æ—¥å¿—] L3 - è·¯å¾„B.3: æ˜¯æœªçŸ¥æ ¼å¼çš„JSON
                            trace!(target: AGG_TRADE_TARGET, connection_id, "L3 - è·¯å¾„B.3: æ˜¯æœªçŸ¥æ ¼å¼çš„JSON");

                            // å…¶ä»–æœªçŸ¥JSONæ¶ˆæ¯
                            tracing::info!(
                                target: AGG_TRADE_TARGET,
                                log_type = "low_freq",
                                connection_id = connection_id,
                                message_type = "æœªçŸ¥JSONæ¶ˆæ¯",
                                raw_message = %message,
                                "è¿æ¥æ”¶åˆ°æœªçŸ¥æ ¼å¼çš„JSONæ¶ˆæ¯"
                            );
                        }
                    } else {
                        // [æ–°å¢æ—¥å¿—] L3 - è·¯å¾„B.4: éJSONæ¶ˆæ¯
                        trace!(target: AGG_TRADE_TARGET, connection_id, "L3 - è·¯å¾„B.4: éJSONæ¶ˆæ¯");

                        tracing::info!(
                            target: AGG_TRADE_TARGET,
                            log_type = "low_freq",
                            connection_id = connection_id,
                            message_type = "éJSONæ¶ˆæ¯",
                            raw_message = if message.len() > 200 {
                                format!("{}...(é•¿åº¦:{})", &message[..200], message.len())
                            } else {
                                message.clone()
                            },
                            "è¿æ¥æ”¶åˆ°éJSONæ¶ˆæ¯"
                        );
                    };
                    Ok(())
                }
                Err(e) => {
                    // [æ–°å¢æ—¥å¿—] L2 - è·¯å¾„C: parseå¤±è´¥
                    trace!(target: AGG_TRADE_TARGET, connection_id, "L2 - è·¯å¾„C: parseå¤±è´¥");

                    self.error_count.fetch_add(1, std::sync::atomic::Ordering::Relaxed);
                    error!(target: AGG_TRADE_TARGET, "è¿æ¥ {} è§£æå½’é›†äº¤æ˜“æ¶ˆæ¯å¤±è´¥: {}, åŸå§‹æ¶ˆæ¯: {}",
                        connection_id, e,
                        if message.len() > 100 {
                            format!("{}...", &message[..100])
                        } else {
                            message
                        });
                    Err(e)
                }
            }
        }
    }
}

impl AggTradeMessageHandler {
    /// è§£æå½’é›†äº¤æ˜“æ¶ˆæ¯
    #[instrument(skip_all, err)]
    async fn parse_agg_trade_message(&self, message: &str) -> Result<Option<BinanceRawAggTrade>> {
        // [æ–°å¢æ—¥å¿—] parse - å¼€å§‹è§£æJSONå¯¹è±¡
        trace!(target: AGG_TRADE_TARGET, "parse - å¼€å§‹è§£æJSONå¯¹è±¡");

        // è§£æJSON
        let json: serde_json::Value = serde_json::from_str(message)
            .map_err(|e| AppError::ParseError(format!("JSONè§£æå¤±è´¥: {}", e)))?;

        // é¦–å…ˆæ£€æŸ¥æ˜¯å¦æ˜¯åŒ…è£…åœ¨streamä¸­çš„æ¶ˆæ¯æ ¼å¼
        let data_json = if let Some(data) = json.get("data") {
            // [æ–°å¢æ—¥å¿—] parse - æ£€æµ‹åˆ°streamåŒ…è£¹å±‚, æå–dataéƒ¨åˆ†
            trace!(target: AGG_TRADE_TARGET, "parse - æ£€æµ‹åˆ°streamåŒ…è£¹å±‚, æå–dataéƒ¨åˆ†");
            data
        } else {
            // [æ–°å¢æ—¥å¿—] parse - æœªæ£€æµ‹åˆ°streamåŒ…è£¹å±‚, ç›´æ¥ä½¿ç”¨åŸå§‹JSON
            trace!(target: AGG_TRADE_TARGET, "parse - æœªæ£€æµ‹åˆ°streamåŒ…è£¹å±‚, ç›´æ¥ä½¿ç”¨åŸå§‹JSON");
            &json
        };

        // [æ–°å¢] è¯¦ç»†çš„JSONç»“æ„åˆ†æ
        trace!(target: AGG_TRADE_TARGET, "parse - JSONç»“æ„åˆ†æ: é¡¶çº§å­—æ®µ = {:?}",
            json.as_object().map(|obj| obj.keys().collect::<Vec<_>>()));
        trace!(target: AGG_TRADE_TARGET, "parse - data_jsonç»“æ„åˆ†æ: å­—æ®µ = {:?}",
            data_json.as_object().map(|obj| obj.keys().collect::<Vec<_>>()));

        // æ£€æŸ¥æ˜¯å¦æ˜¯å½’é›†äº¤æ˜“æ¶ˆæ¯
        if let Some(event_type) = data_json.get("e").and_then(|e| e.as_str()) {
            // [æ–°å¢] è¯¦ç»†çš„äº‹ä»¶ç±»å‹æ—¥å¿—
            trace!(target: AGG_TRADE_TARGET, "parse - å‘ç°äº‹ä»¶ç±»å‹å­—æ®µ: '{}'", event_type);

            if event_type == "aggTrade" {
                // [æ–°å¢æ—¥å¿—] parse - äº‹ä»¶ç±»å‹åŒ¹é…aggTrade, å¼€å§‹ååºåˆ—åŒ–
                trace!(target: AGG_TRADE_TARGET, "parse - äº‹ä»¶ç±»å‹åŒ¹é…aggTrade, å¼€å§‹ååºåˆ—åŒ–");

                // [æ–°å¢] ç®€åŒ–ç‰ˆæœ¬ï¼Œç¡®ä¿åœ¨infoçº§åˆ«å¯è§
                info!(target: AGG_TRADE_TARGET, "ğŸ¯ å‘ç°aggTradeäº‹ä»¶ï¼Œå¼€å§‹è§£æäº¤æ˜“æ•°æ®");

                // è§£æå½’é›†äº¤æ˜“æ•°æ®
                let agg_trade = BinanceRawAggTrade {
                    event_type: event_type.to_string(),
                    event_time: data_json.get("E").and_then(|e| e.as_u64()).unwrap_or(0),
                    symbol: data_json.get("s").and_then(|s| s.as_str()).unwrap_or("").to_string(),
                    aggregate_trade_id: data_json.get("a").and_then(|a| a.as_u64()).unwrap_or(0),
                    price: data_json.get("p").and_then(|p| p.as_str()).unwrap_or("0").to_string(),
                    quantity: data_json.get("q").and_then(|q| q.as_str()).unwrap_or("0").to_string(),
                    first_trade_id: data_json.get("f").and_then(|f| f.as_u64()).unwrap_or(0),
                    last_trade_id: data_json.get("l").and_then(|l| l.as_u64()).unwrap_or(0),
                    trade_time: data_json.get("T").and_then(|t| t.as_u64()).unwrap_or(0),
                    is_buyer_maker: data_json.get("m").and_then(|m| m.as_bool()).unwrap_or(false),
                };

                debug!(target: AGG_TRADE_TARGET, "å½’é›†äº¤æ˜“è§£ææˆåŠŸ: {} {} @ {}",
                    agg_trade.symbol, agg_trade.quantity, agg_trade.price);

                // å‘å‡ºéªŒè¯äº‹ä»¶
                tracing::info!(
                    target: AGG_TRADE_TARGET,
                    event_name = "trade_data_parsed",
                    symbol = %agg_trade.symbol,
                    price = agg_trade.price.parse::<f64>().unwrap_or(0.0),
                    quantity = agg_trade.quantity.parse::<f64>().unwrap_or(0.0),
                    timestamp_ms = agg_trade.trade_time as i64,
                    "äº¤æ˜“æ•°æ®è§£æå®Œæˆ"
                );

                return Ok(Some(agg_trade));
            } else {
                // [æ–°å¢æ—¥å¿—] parse - äº‹ä»¶ç±»å‹ä¸åŒ¹é…aggTrade
                trace!(target: AGG_TRADE_TARGET, "parse - äº‹ä»¶ç±»å‹ä¸åŒ¹é…aggTrade: {}", event_type);
            }
        } else {
            // [æ–°å¢æ—¥å¿—] parse - æ¶ˆæ¯ä¸­æ²¡æœ‰æ‰¾åˆ°äº‹ä»¶ç±»å‹'e'å­—æ®µ
            trace!(target: AGG_TRADE_TARGET, "parse - æ¶ˆæ¯ä¸­æ²¡æœ‰æ‰¾åˆ°äº‹ä»¶ç±»å‹'e'å­—æ®µ");
        }

        // [æ–°å¢æ—¥å¿—] parse - æœ€ç»ˆåˆ¤å®šä¸æ˜¯aggTradeæ¶ˆæ¯
        trace!(target: AGG_TRADE_TARGET, "parse - æœ€ç»ˆåˆ¤å®šä¸æ˜¯aggTradeæ¶ˆæ¯");
        Ok(None)
    }
}

/// å¤„ç†WebSocketæ¶ˆæ¯
#[instrument(skip_all)]
pub async fn process_messages<H: MessageHandler>(
    mut rx: mpsc::Receiver<(usize, String)>,
    handler: Arc<H>,
    connections: Arc<TokioMutex<HashMap<usize, WebSocketConnection>>>,
) {
    info!(target: WEBSOCKET_CONNECTION_TARGET,   log_type = "low_freq", "ğŸš€ å¯åŠ¨WebSocketæ¶ˆæ¯å¤„ç†å™¨");

    // ç»Ÿè®¡ä¿¡æ¯
    let mut _message_count = 0;
    let mut last_stats_time = Instant::now();
    let stats_interval = Duration::from_secs(30);

    // å¤„ç†æ¶ˆæ¯
    while let Some((connection_id, text)) = rx.recv().await {
        _message_count += 1;

        // æ¯30ç§’è¾“å‡ºä¸€æ¬¡ç»Ÿè®¡ä¿¡æ¯
        let now = Instant::now();
        if now.duration_since(last_stats_time) >= stats_interval {
            //info!("WebSocketç»Ÿè®¡: å·²å¤„ç† {} æ¡æ¶ˆæ¯", message_count);

            // è¾“å‡ºæ¯ä¸ªè¿æ¥çš„ç»Ÿè®¡ä¿¡æ¯
            let connections_guard = connections.lock().await;
            for (_id, _conn) in connections_guard.iter() {
               //info!("è¿æ¥ {}: {} æ¡æ¶ˆæ¯, çŠ¶æ€: {}", id, conn.message_count, conn.status);
            }

            last_stats_time = now;
        }

        // å¤„ç†æ¶ˆæ¯
        if let Err(e) = handler.handle_message(connection_id, text).await {
            error!(target: WEBSOCKET_CONNECTION_TARGET, "å¤„ç†æ¶ˆæ¯å¤±è´¥: {}", e);
        }
    }

    info!( target: WEBSOCKET_CONNECTION_TARGET,   log_type = "low_freq", "âœ… WebSocketæ¶ˆæ¯å¤„ç†å™¨å·²åœæ­¢");
}

//=============================================================================
// å®ç° hyper çš„ Executor trait
//=============================================================================

/// å®ç° hyper çš„ Executor traitï¼Œç”¨äº fastwebsockets æ¡æ‰‹
struct SpawnExecutor;

impl<Fut> hyper::rt::Executor<Fut> for SpawnExecutor
where
    Fut: Future + Send + 'static,
    Fut::Output: Send + 'static,
{
    fn execute(&self, fut: Fut) {
        tokio::task::spawn(fut);
    }
}

//=============================================================================
// è¿æ¥ç®¡ç†
//=============================================================================

/// WebSocketè¿æ¥ç®¡ç†å™¨
#[derive(Clone)]
pub struct ConnectionManager {
    /// æ˜¯å¦ä½¿ç”¨ä»£ç†
    use_proxy: bool,
    /// ä»£ç†åœ°å€
    proxy_addr: String,
    /// ä»£ç†ç«¯å£
    proxy_port: u16,
}

impl ConnectionManager {
    /// åˆ›å»ºæ–°çš„è¿æ¥ç®¡ç†å™¨
    // #[instrument] ç§»é™¤ï¼šç®€å•çš„æ„é€ å‡½æ•°ï¼Œè¿½è¸ªä¼šäº§ç”Ÿå™ªéŸ³
    pub fn new(use_proxy: bool, proxy_addr: String, proxy_port: u16) -> Self {
        Self {
            use_proxy,
            proxy_addr,
            proxy_port,
        }
    }

    /// è¿æ¥åˆ°WebSocketæœåŠ¡å™¨ï¼ˆå¸¦é‡è¯•æœºåˆ¶ï¼‰
    #[instrument(skip_all, err)]
    pub async fn connect(&self) -> Result<FragmentCollector<TokioIo<Upgraded>>> {
        let mut last_error = None;
        const CONNECT_TIMEOUT: Duration = Duration::from_secs(15); // æ–°å¢ï¼šä¸ºæ¯æ¬¡å°è¯•è®¾ç½®15ç§’è¶…æ—¶

        for attempt in 1..=MAX_RETRY_ATTEMPTS {
            info!(
                target: WEBSOCKET_CONNECTION_TARGET,
                log_type = "low_freq",
                "ğŸ”„ WebSocketè¿æ¥å°è¯• {}/{}",
                attempt,
                MAX_RETRY_ATTEMPTS
            );

            // [ä¿®æ”¹é€»è¾‘] ä½¿ç”¨ tokio::time::timeout ä¸ºå•æ¬¡è¿æ¥å°è¯•å¢åŠ è¶…æ—¶
            match tokio::time::timeout(CONNECT_TIMEOUT, self.connect_once()).await {
                Ok(Ok(ws)) => { // è¶…æ—¶å†…æˆåŠŸè¿æ¥
                    if attempt > 1 {
                        info!(
                            target: WEBSOCKET_CONNECTION_TARGET,
                            log_type = "low_freq",
                            "âœ… WebSocketè¿æ¥åœ¨ç¬¬{}æ¬¡å°è¯•åæˆåŠŸå»ºç«‹",
                            attempt
                        );
                    }
                    return Ok(ws);
                }
                Ok(Err(e)) => { // è¶…æ—¶å†…è¿æ¥å¤±è´¥
                    last_error = Some(e);
                }
                Err(_) => { // è¿æ¥è¶…æ—¶
                    last_error = Some(AppError::WebSocketError(format!("è¿æ¥å°è¯•è¶…è¿‡ {} ç§’æœªå“åº”ï¼Œå·²è¶…æ—¶", CONNECT_TIMEOUT.as_secs())));
                }
            }

            if attempt < MAX_RETRY_ATTEMPTS {
                let delay_ms = std::cmp::min(
                    INITIAL_RETRY_DELAY_MS * (2_u64.pow((attempt - 1) as u32)),
                    MAX_RETRY_DELAY_MS
                );

                // [ä¿®æ”¹é€»è¾‘] å°† warn! æå‡ä¸º error! ä»¥ç¡®ä¿æ—¥å¿—å¯è§æ€§
                error!(
                    target: WEBSOCKET_CONNECTION_TARGET,
                    log_type = "low_freq",
                    error_chain = format!("{:#}", last_error.as_ref().unwrap()),
                    "âŒ WebSocketè¿æ¥ç¬¬{}æ¬¡å°è¯•å¤±è´¥ï¼Œ{}msåé‡è¯•",
                    attempt,
                    delay_ms
                );

                sleep(Duration::from_millis(delay_ms)).await;
            } else {
                error!(
                    target: WEBSOCKET_CONNECTION_TARGET,
                    log_type = "low_freq",
                    error_chain = format!("{:#}", last_error.as_ref().unwrap()),
                    "ğŸ’¥ WebSocketè¿æ¥åœ¨{}æ¬¡å°è¯•åå…¨éƒ¨å¤±è´¥",
                    MAX_RETRY_ATTEMPTS
                );
            }
        }

        // è¿”å›æœ€åä¸€æ¬¡çš„é”™è¯¯
        Err(last_error.unwrap())
    }

    /// å•æ¬¡è¿æ¥å°è¯•ï¼ˆå†…éƒ¨æ–¹æ³•ï¼‰
    #[instrument(skip_all, err)]
    async fn connect_once(&self) -> Result<FragmentCollector<TokioIo<Upgraded>>> {
        // è®¾ç½®ä¸»æœºå’Œç«¯å£
        let host = "fstream.binance.com";
        let port = 443;
        let addr = format!("{}:{}", host, port);

        // [ä¿®æ”¹é€»è¾‘] ç»Ÿä¸€ä½¿ç”¨ /ws ç«¯ç‚¹ï¼Œä»¥æ”¯æŒåŠ¨æ€è®¢é˜…å’Œç»Ÿä¸€çš„è¿æ¥è¡Œä¸ºã€‚
        // ä¸å†æ ¹æ®æµçš„æ•°é‡æ¥å†³å®šæ˜¯ä½¿ç”¨ /streamè¿˜æ˜¯ /wsã€‚
        let path = "/ws".to_string();

        // [ä¿®æ”¹é€»è¾‘] å®Œæ•´URLçš„æ—¥å¿—ç°åœ¨åæ˜ äº†ç»Ÿä¸€çš„ç«¯ç‚¹
        let full_url = format!("wss://{}:{}{}", host, port, path);
        info!(
            target: WEBSOCKET_CONNECTION_TARGET,
            log_type = "low_freq",
            "ğŸ”— WebSocketè¿æ¥è¯¦æƒ… - ç»Ÿä¸€ç«¯ç‚¹URL: {}",
            full_url
        );
        info!(
            target: WEBSOCKET_CONNECTION_TARGET,
            log_type = "low_freq",
            "ğŸŒ ä»£ç†è®¾ç½®: å¯ç”¨={}, åœ°å€={}:{}",
            self.use_proxy,
            self.proxy_addr,
            self.proxy_port
        );

        // å»ºç«‹TCPè¿æ¥ï¼ˆé€šè¿‡ä»£ç†æˆ–ç›´æ¥ï¼‰
        let tcp_stream = if self.use_proxy {
            debug!(target: WEBSOCKET_CONNECTION_TARGET, log_type = "module", "ğŸŒ é€šè¿‡ä»£ç† {}:{} è¿æ¥", self.proxy_addr, self.proxy_port);

            // è¿æ¥åˆ°ä»£ç†
            let socks_stream = Socks5Stream::connect(
                (self.proxy_addr.as_str(), self.proxy_port),
                (host, port)
            )
            .await
            .map_err(|e| AppError::WebSocketError(format!("ä»£ç†è¿æ¥å¤±è´¥: {}", e)))?;

            // è·å–TCPæµ
            socks_stream.into_inner()
        } else {
            // ç›´æ¥è¿æ¥
            TcpStream::connect(addr).await?
        };

        debug!(target: WEBSOCKET_CONNECTION_TARGET, log_type = "module", "âœ… TCPè¿æ¥å·²å»ºç«‹");

        // åˆ›å»º TLS è¿æ¥
        let mut root_store = tokio_rustls::rustls::RootCertStore::empty();
        root_store.add_trust_anchors(webpki_roots::TLS_SERVER_ROOTS.0.iter().map(
            |ta| {
                OwnedTrustAnchor::from_subject_spki_name_constraints(
                    ta.subject,
                    ta.spki,
                    ta.name_constraints,
                )
            },
        ));

        let config = ClientConfig::builder()
            .with_safe_defaults()
            .with_root_certificates(root_store)
            .with_no_client_auth();

        let connector = TlsConnector::from(Arc::new(config));
        let server_name = ServerName::try_from(host)
            .map_err(|_| AppError::WebSocketError("æ— æ•ˆçš„åŸŸå".to_string()))?;

        debug!(target: WEBSOCKET_CONNECTION_TARGET, log_type = "module", "ğŸ” å»ºç«‹TLSè¿æ¥...");
        let tls_stream = connector.connect(server_name, tcp_stream).await?;
        debug!(target: WEBSOCKET_CONNECTION_TARGET, log_type = "module", "âœ… TLSè¿æ¥å·²å»ºç«‹");

        // åˆ›å»º HTTP è¯·æ±‚
        let req = Request::builder()
            .method("GET")
            .uri(format!("https://{}{}", host, path))
            .header("Host", host)
            .header(UPGRADE, "websocket")
            .header(CONNECTION, "upgrade")
            .header(
                "Sec-WebSocket-Key",
                fastwebsockets::handshake::generate_key(),
            )
            .header("Sec-WebSocket-Version", "13")
            .body(Empty::<Bytes>::new())
            .map_err(|e| AppError::WebSocketError(format!("åˆ›å»ºHTTPè¯·æ±‚å¤±è´¥: {}", e)))?;

        debug!(target: WEBSOCKET_CONNECTION_TARGET, "æ‰§è¡ŒWebSocketæ¡æ‰‹...");

        // æ‰§è¡Œ WebSocket æ¡æ‰‹
        let (ws, _) = fastwebsockets::handshake::client(&SpawnExecutor, req, tls_stream).await
            .map_err(|e| AppError::WebSocketError(format!("WebSocketæ¡æ‰‹å¤±è´¥: {}", e)))?;
        let ws_collector = FragmentCollector::new(ws);

        debug!(target: WEBSOCKET_CONNECTION_TARGET, "WebSocketæ¡æ‰‹æˆåŠŸ");

        // [ä¿®æ”¹é€»è¾‘] ç§»é™¤è¿™é‡Œçš„è®¢é˜…é€»è¾‘ã€‚æ­¤å‡½æ•°ç°åœ¨åªè´Ÿè´£è¿æ¥ã€‚
        // è°ƒç”¨è€…ï¼ˆå¦‚ run_io_loopï¼‰å°†è´Ÿè´£åœ¨è¿æ¥æˆåŠŸåå‘é€è®¢é˜…æ¶ˆæ¯ã€‚

        Ok(ws_collector)
    }

    /// å¤„ç†WebSocketæ¶ˆæ¯
    #[instrument(skip_all)]
    pub async fn handle_messages(
        &self,
        connection_id: usize,
        ws: &mut FragmentCollector<TokioIo<Upgraded>>,
        tx: mpsc::Sender<(usize, String)>,
        connections: Arc<TokioMutex<HashMap<usize, WebSocketConnection>>>,
    ) {
        info!(target: WEBSOCKET_CONNECTION_TARGET, "å¼€å§‹å¤„ç†è¿æ¥ {} çš„æ¶ˆæ¯", connection_id);

        // å¤„ç†æ¶ˆæ¯ï¼Œæ·»åŠ è¶…æ—¶å¤„ç†
        loop {
            // ä½¿ç”¨ tokio::time::timeout æ·»åŠ è¶…æ—¶å¤„ç†
            match tokio::time::timeout(Duration::from_secs(30), ws.read_frame()).await {
                Ok(result) => {
                    match result {
                        Ok(frame) => {
                            match frame.opcode {
                                OpCode::Text => {
                                    // å°†äºŒè¿›åˆ¶æ•°æ®è½¬æ¢ä¸ºå­—ç¬¦ä¸²
                                    let text = String::from_utf8(frame.payload.to_vec())
                                        .unwrap_or_else(|_| "æ— æ•ˆçš„UTF-8æ•°æ®".to_string());

                                    // æ›´æ–°æ¶ˆæ¯è®¡æ•°
                                    {
                                        let mut connections = connections.lock().await;
                                        if let Some(conn) = connections.get_mut(&connection_id) {
                                            conn.message_count += 1;
                                        }
                                    }

                                    // å‘é€æ¶ˆæ¯åˆ°å¤„ç†å™¨
                                    if let Err(e) = tx.send((connection_id, text)).await {
                                        error!(target: WEBSOCKET_CONNECTION_TARGET, "å‘é€æ¶ˆæ¯åˆ°å¤„ç†å™¨å¤±è´¥: {}", e);
                                        break;
                                    }
                                },
                                OpCode::Binary => {
                                    debug!(target: WEBSOCKET_CONNECTION_TARGET, "æ”¶åˆ°äºŒè¿›åˆ¶æ¶ˆæ¯ï¼Œé•¿åº¦: {}", frame.payload.len());
                                },
                                OpCode::Ping => {
                                    debug!(target: WEBSOCKET_CONNECTION_TARGET, "æ”¶åˆ°Pingï¼Œå‘é€Pong");
                                    if let Err(e) = ws.write_frame(Frame::new(true, OpCode::Pong, None, frame.payload)).await {
                                        error!(target: WEBSOCKET_CONNECTION_TARGET, "å‘é€Pongå¤±è´¥: {}", e);
                                        break;
                                    }
                                },
                                OpCode::Pong => {
                                    debug!(target: WEBSOCKET_CONNECTION_TARGET, "æ”¶åˆ°Pong");
                                },
                                OpCode::Close => {
                                    info!(target: WEBSOCKET_CONNECTION_TARGET, "æ”¶åˆ°å…³é—­æ¶ˆæ¯ï¼Œè¿æ¥å°†å…³é—­");
                                    break;
                                },
                                _ => {
                                    debug!(target: WEBSOCKET_CONNECTION_TARGET, "æ”¶åˆ°å…¶ä»–ç±»å‹çš„æ¶ˆæ¯");
                                }
                            }
                        },
                        Err(e) => {
                            error!(target: WEBSOCKET_CONNECTION_TARGET, "WebSocketé”™è¯¯: {}", e);
                            break;
                        }
                    }
                },
                Err(_) => {
                    // è¶…æ—¶ï¼Œå‘é€pingä»¥ä¿æŒè¿æ¥
                    debug!(target: WEBSOCKET_CONNECTION_TARGET, "WebSocketè¿æ¥è¶…æ—¶ï¼Œå‘é€Ping");
                    if let Err(e) = ws.write_frame(Frame::new(true, OpCode::Ping, None, vec![].into())).await {
                        error!(target: WEBSOCKET_CONNECTION_TARGET, "å‘é€Pingå¤±è´¥: {}", e);
                        break;
                    }
                }
            }
        }

        // æ›´æ–°è¿æ¥çŠ¶æ€
        {
            let mut connections = connections.lock().await;
            if let Some(conn) = connections.get_mut(&connection_id) {
                conn.status = "å·²æ–­å¼€".to_string();
            }
        }

        info!(target: WEBSOCKET_CONNECTION_TARGET, "è¿æ¥ {} å·²å…³é—­", connection_id);
    }
}













//=============================================================================
// å½’é›†äº¤æ˜“å®¢æˆ·ç«¯
//=============================================================================

/// å½’é›†äº¤æ˜“å®¢æˆ·ç«¯
pub struct AggTradeClient {
    config: AggTradeConfig,
    connection_id_counter: AtomicUsize,
    connections: Arc<TokioMutex<HashMap<usize, WebSocketConnection>>>,
    /// å¤–éƒ¨æ³¨å…¥çš„æ¶ˆæ¯å¤„ç†å™¨ï¼ˆå¯é€‰ï¼‰
    external_handler: Option<Arc<AggTradeMessageHandler>>,
    /// ç”¨äºä»å¤–éƒ¨æ¥æ”¶å‘½ä»¤çš„å‘é€ç«¯
    command_tx: Option<mpsc::Sender<WsCommand>>,
}

impl AggTradeClient {
    /// åˆ›å»ºæ–°çš„å½’é›†äº¤æ˜“å®¢æˆ·ç«¯
    #[instrument(skip_all)]
    pub fn new(config: AggTradeConfig) -> Self {
        Self {
            config,
            connection_id_counter: AtomicUsize::new(1),
            connections: Arc::new(TokioMutex::new(HashMap::new())),
            external_handler: None,
            command_tx: None,
        }
    }

    /// åˆ›å»ºå¸¦æœ‰å¤–éƒ¨æ¶ˆæ¯å¤„ç†å™¨çš„å½’é›†äº¤æ˜“å®¢æˆ·ç«¯
    #[instrument(skip_all)]
    pub fn new_with_handler(
        config: AggTradeConfig,
        handler: Arc<AggTradeMessageHandler>
    ) -> Self {
        let (command_tx, _command_rx) = mpsc::channel(16); // rx ä¼šåœ¨ start() æ—¶è¢« take
        Self {
            config,
            connection_id_counter: AtomicUsize::new(1),
            connections: Arc::new(TokioMutex::new(HashMap::new())),
            external_handler: Some(handler),
            command_tx: Some(command_tx),
        }
    }

    /// å…è®¸å¤–éƒ¨è·å–å‘½ä»¤å‘é€ç«¯
    pub fn get_command_sender(&self) -> Option<mpsc::Sender<WsCommand>> {
        self.command_tx.clone()
    }
}

impl WebSocketClient for AggTradeClient {
    /// å¯åŠ¨å®¢æˆ·ç«¯
    fn start(&mut self) -> impl std::future::Future<Output = Result<()>> + Send {
        async move {
            info!(target: AGG_TRADE_TARGET, "å¯åŠ¨å½’é›†äº¤æ˜“å®¢æˆ·ç«¯ (æ”¯æŒåŠ¨æ€è®¢é˜…)");
            info!(target: AGG_TRADE_TARGET, "ä½¿ç”¨ä»£ç†: {}", self.config.use_proxy);

            if self.config.use_proxy {
                info!(target: AGG_TRADE_TARGET, "ä»£ç†åœ°å€: {}:{}", self.config.proxy_addr, self.config.proxy_port);
            }

            // ç¡®ä¿æ—¥å¿—ç›®å½•å­˜åœ¨
            let log_dir = Path::new("logs");
            if !log_dir.exists() {
                create_dir_all(log_dir)?;
            }

            // take å‡º command_rx ä»¥ä¾¿ä¼ é€’ç»™è¿æ¥ä»»åŠ¡
            let mut command_rx = if let Some(_tx) = &self.command_tx {
                let (new_tx, rx) = mpsc::channel(16);
                // æ›¿æ¢åŸæœ‰çš„ txï¼Œä¿ç•™æ–°çš„ rx
                self.command_tx = Some(new_tx);
                rx
            } else {
                // å¦‚æœæ²¡æœ‰å‘½ä»¤é€šé“ï¼Œåˆ›å»ºä¸€ä¸ªæ°¸è¿œä¸ä¼šæ”¶åˆ°æ¶ˆæ¯çš„é€šé“
                let (_tx, rx) = mpsc::channel(1);
                rx
            };

            // åˆ›å»ºè¿æ¥ç®¡ç†å™¨
            let (use_proxy, proxy_addr, proxy_port) = self.config.get_proxy_settings();
            let connection_manager = ConnectionManager::new(
                use_proxy,
                proxy_addr,
                proxy_port,
            );

            // è·å–åˆå§‹æµ
            let initial_streams = self.config.get_streams();
            info!(target: AGG_TRADE_TARGET, "åˆå§‹è®¢é˜… {} ä¸ªæµ: {:?}", initial_streams.len(), initial_streams);

            // è·å–æ¶ˆæ¯å¤„ç†å™¨
            let handler = if let Some(external_handler) = &self.external_handler {
                external_handler.clone()
            } else {
                Arc::new(AggTradeMessageHandler::new(
                    Arc::new(AtomicUsize::new(0)),
                    Arc::new(AtomicUsize::new(0)),
                ))
            };

            // ä½¿ç”¨å•è¿æ¥æ¨¡å¼ï¼Œæ”¯æŒåŠ¨æ€è®¢é˜…
            let connection_id = self.connection_id_counter.fetch_add(1, Ordering::SeqCst);
            let connections_clone = self.connections.clone();

            // æ›´æ–°è¿æ¥çŠ¶æ€
            {
                let mut connections = connections_clone.lock().await;
                connections.insert(connection_id, WebSocketConnection {
                    id: connection_id,
                    streams: initial_streams.clone(),
                    status: "åˆå§‹åŒ–".to_string(),
                    message_count: 0,
                });
            }

            // å¯åŠ¨å•ä¸ªè¿æ¥ä»»åŠ¡ï¼Œæ”¯æŒåŠ¨æ€è®¢é˜…
            let connection_task = tokio::spawn(async move {
                let mut current_streams = initial_streams;

                'reconnect_loop: loop {
                    // æ›´æ–°çŠ¶æ€ä¸ºè¿æ¥ä¸­
                    {
                        let mut connections = connections_clone.lock().await;
                        if let Some(conn) = connections.get_mut(&connection_id) {
                            conn.status = "è¿æ¥ä¸­".to_string();
                        }
                    }

                    // å»ºç«‹è¿æ¥
                    match connection_manager.connect().await {
                        Ok(mut ws) => {
                            // æ›´æ–°çŠ¶æ€ä¸ºå·²è¿æ¥
                            {
                                let mut connections = connections_clone.lock().await;
                                if let Some(conn) = connections.get_mut(&connection_id) {
                                    conn.status = "å·²è¿æ¥".to_string();
                                    conn.streams = current_streams.clone();
                                }
                            }

                            info!(target: AGG_TRADE_TARGET, "è¿æ¥ {} å·²å»ºç«‹", connection_id);

                            // [æ–°å¢] æ‰“å°å®Œæ•´çš„è¿æ¥ä¿¡æ¯
                            info!(
                                target: AGG_TRADE_TARGET,
                                log_type = "low_freq",
                                connection_id = connection_id,
                                "ğŸ”— AggTradeClient å®Œæ•´è¿æ¥ä¿¡æ¯ - URL: wss://fstream.binance.com:443/ws"
                            );

                            // å‘é€åˆå§‹è®¢é˜…
                            if !current_streams.is_empty() {
                                let sub_msg = create_subscribe_message(&current_streams);

                                // [æ–°å¢] æ‰“å°å®Œæ•´çš„è®¢é˜…æ¶ˆæ¯å†…å®¹
                                info!(
                                    target: AGG_TRADE_TARGET,
                                    log_type = "low_freq",
                                    connection_id = connection_id,
                                    stream_count = current_streams.len(),
                                    streams = ?current_streams,
                                    subscription_message = %sub_msg,
                                    "ğŸ“¤ AggTradeClient å‘é€åˆå§‹è®¢é˜…æ¶ˆæ¯"
                                );

                                // [æ–°å¢] é¢å¤–çš„ç®€åŒ–æ—¥å¿—ï¼Œç¡®ä¿è®¢é˜…å†…å®¹å¯è§
                                info!(target: AGG_TRADE_TARGET, "ğŸ“‹ è®¢é˜…è¯¦æƒ…: {} ä¸ªå“ç§", current_streams.len());
                                info!(target: AGG_TRADE_TARGET, "ğŸ“‹ è®¢é˜…æ¶ˆæ¯: {}", sub_msg);
                                if current_streams.len() <= 10 {
                                    info!(target: AGG_TRADE_TARGET, "ğŸ“‹ å“ç§åˆ—è¡¨: {:?}", current_streams);
                                } else {
                                    info!(target: AGG_TRADE_TARGET, "ğŸ“‹ å‰10ä¸ªå“ç§: {:?}", &current_streams[..10]);
                                    info!(target: AGG_TRADE_TARGET, "ğŸ“‹ å10ä¸ªå“ç§: {:?}", &current_streams[current_streams.len()-10..]);
                                }

                                let frame = Frame::text(sub_msg.into_bytes().into());
                                if let Err(e) = ws.write_frame(frame).await {
                                    error!(target: AGG_TRADE_TARGET, "å‘é€åˆå§‹è®¢é˜…å¤±è´¥: {}", e);
                                    sleep(Duration::from_secs(5)).await;
                                    continue 'reconnect_loop;
                                }
                                info!(target: AGG_TRADE_TARGET, "å·²å‘é€åˆå§‹è®¢é˜…: {} ä¸ªæµ", current_streams.len());
                            }

                            // [æ–°å¢] æ·»åŠ å®šæœŸçŠ¶æ€æ£€æŸ¥
                            let mut status_interval = tokio::time::interval(Duration::from_secs(30));
                            let mut last_message_time = std::time::Instant::now();

                            // æ ¸å¿ƒæ¶ˆæ¯å¾ªç¯ï¼Œæ”¯æŒåŠ¨æ€è®¢é˜…
                            'message_loop: loop {
                                tokio::select! {
                                    // [æ–°å¢] åˆ†æ”¯0ï¼šå®šæœŸçŠ¶æ€æ£€æŸ¥
                                    _ = status_interval.tick() => {
                                        let elapsed = last_message_time.elapsed();
                                        let conn_count = {
                                            let connections = connections_clone.lock().await;
                                            if let Some(conn) = connections.get(&connection_id) {
                                                conn.message_count
                                            } else {
                                                0
                                            }
                                        };
                                        info!(
                                            target: WEBSOCKET_CONNECTION_TARGET,
                                            "ğŸ’“ è¿æ¥ {} çŠ¶æ€æ£€æŸ¥ - æ¶ˆæ¯æ€»æ•°: {}, è·ç¦»ä¸Šæ¬¡æ¶ˆæ¯: {:?}",
                                            connection_id, conn_count, elapsed
                                        );

                                        // å¦‚æœè¶…è¿‡2åˆ†é’Ÿæ²¡æœ‰æ”¶åˆ°æ¶ˆæ¯ï¼Œå¯èƒ½æœ‰é—®é¢˜
                                        if elapsed > Duration::from_secs(120) {
                                            warn!(target: WEBSOCKET_CONNECTION_TARGET,
                                                "âš ï¸ è¿æ¥ {} è¶…è¿‡2åˆ†é’Ÿæœªæ”¶åˆ°æ¶ˆæ¯ï¼Œå¯èƒ½è¿æ¥å¼‚å¸¸", connection_id);
                                        }
                                    },
                                    // åˆ†æ”¯1ï¼šå¤„ç†WebSocketæ¶ˆæ¯
                                    result = ws.read_frame() => {
                                        // [æ–°å¢æ—¥å¿—] å¸§è¯»å–ç»“æœè¯Šæ–­
                                        trace!(target: WEBSOCKET_CONNECTION_TARGET, connection_id, "ğŸ” WebSocket read_frame è°ƒç”¨å®Œæˆ");

                                        match result {
                                            Ok(frame) => {
                                                // [æ–°å¢æ—¥å¿—] å¸§ç±»å‹è¯Šæ–­
                                                trace!(target: WEBSOCKET_CONNECTION_TARGET, connection_id, opcode = ?frame.opcode, payload_len = frame.payload.len(), "ğŸ“¦ æ”¶åˆ°WebSocketå¸§");

                                                match frame.opcode {
                                                    OpCode::Text => {
                                                        let text = String::from_utf8_lossy(&frame.payload).to_string();

                                                        // [æ–°å¢æ—¥å¿—] L0 - æ•è·æœ€åŸå§‹çš„WebSocketæ–‡æœ¬å¸§
                                                        trace!(
                                                            target: WEBSOCKET_CONNECTION_TARGET,
                                                            connection_id,
                                                            raw_message = %text,
                                                            "L0 - æ”¶åˆ°åŸå§‹WebSocketæ–‡æœ¬å¸§"
                                                        );

                                                        // [æ–°å¢æ—¥å¿—] ç®€åŒ–ç‰ˆæœ¬ï¼Œç¡®ä¿åœ¨infoçº§åˆ«å¯è§
                                                        info!(target: WEBSOCKET_CONNECTION_TARGET, "ğŸ“¨ è¿æ¥ {} æ”¶åˆ°æ¶ˆæ¯ (é•¿åº¦: {}): {}",
                                                            connection_id,
                                                            text.len(),
                                                            if text.len() > 200 { format!("{}...", &text[..200]) } else { text.clone() }
                                                        );

                                                        // [æ–°å¢] æ›´æ–°æœ€åæ¶ˆæ¯æ—¶é—´
                                                        last_message_time = std::time::Instant::now();

                                                        // æ›´æ–°æ¶ˆæ¯è®¡æ•°
                                                        {
                                                            let mut connections = connections_clone.lock().await;
                                                            if let Some(conn) = connections.get_mut(&connection_id) {
                                                                conn.message_count += 1;
                                                                // [æ–°å¢æ—¥å¿—] æ¶ˆæ¯è®¡æ•°æ›´æ–°
                                                                if conn.message_count % 10 == 1 || conn.message_count <= 5 {
                                                                    info!(target: WEBSOCKET_CONNECTION_TARGET, "ğŸ“Š è¿æ¥ {} æ¶ˆæ¯è®¡æ•°: {}", connection_id, conn.message_count);
                                                                }
                                                            }
                                                        }

                                                        // [æ–°å¢æ—¥å¿—] æ¶ˆæ¯å¤„ç†å‰
                                                        trace!(target: AGG_TRADE_TARGET, connection_id, "ğŸ”„ å‡†å¤‡è°ƒç”¨ handle_message");

                                                        // å¤„ç†æ¶ˆæ¯
                                                        if let Err(e) = handler.handle_message(connection_id, text).await {
                                                            warn!(target: AGG_TRADE_TARGET, "æ¶ˆæ¯å¤„ç†å¤±è´¥: {}", e);
                                                        } else {
                                                            // [æ–°å¢æ—¥å¿—] æ¶ˆæ¯å¤„ç†æˆåŠŸ
                                                            trace!(target: AGG_TRADE_TARGET, connection_id, "âœ… handle_message å¤„ç†å®Œæˆ");
                                                        }
                                                    },
                                                    OpCode::Close => {
                                                        info!(target: AGG_TRADE_TARGET, "ğŸ”Œ æœåŠ¡å™¨å…³é—­è¿æ¥ï¼Œå‡†å¤‡é‡è¿...");
                                                        break 'message_loop;
                                                    }
                                                    OpCode::Ping => {
                                                        info!(target: AGG_TRADE_TARGET, "ğŸ“ æ”¶åˆ°Pingï¼Œå‘é€Pong");
                                                        if let Err(e) = ws.write_frame(Frame::new(true, OpCode::Pong, None, frame.payload)).await {
                                                            error!(target: AGG_TRADE_TARGET, "å‘é€Pongå¤±è´¥: {}", e);
                                                            break 'message_loop;
                                                        }
                                                    },
                                                    OpCode::Pong => {
                                                        info!(target: AGG_TRADE_TARGET, "ğŸ“ æ”¶åˆ°Pong");
                                                    },
                                                    OpCode::Binary => {
                                                        info!(target: AGG_TRADE_TARGET, "ğŸ“¦ æ”¶åˆ°äºŒè¿›åˆ¶å¸§ (é•¿åº¦: {})", frame.payload.len());
                                                    },
                                                    _ => {
                                                        info!(target: AGG_TRADE_TARGET, "ğŸ“¦ æ”¶åˆ°å…¶ä»–ç±»å‹å¸§: {:?} (é•¿åº¦: {})", frame.opcode, frame.payload.len());
                                                    }
                                                } // ç»“æŸ match frame.opcode
                                            }, // Ok(frame) åˆ†æ”¯åœ¨è¿™é‡Œæ­£ç¡®ç»“æŸ
                                            Err(e) => { // Err(e) åˆ†æ”¯ç°åœ¨æ˜¯ Ok(frame) çš„å…„å¼Ÿåˆ†æ”¯
                                                error!(target: AGG_TRADE_TARGET, "âŒ WebSocketè¯»å–é”™è¯¯: {}", e);
                                                error!(target: WEBSOCKET_CONNECTION_TARGET, "âŒ è¿æ¥ {} WebSocketè¯»å–å¤±è´¥ï¼Œå‡†å¤‡é‡è¿", connection_id);
                                                break 'message_loop;
                                            }
                                        } // ç»“æŸ match result
                                    }, // ç»“æŸåˆ†æ”¯1ï¼šå¤„ç†WebSocketæ¶ˆæ¯
                                    // åˆ†æ”¯2ï¼šå¤„ç†å¤–éƒ¨å‘½ä»¤
                                    Some(command) = command_rx.recv() => {
                                        match command {
                                            WsCommand::Subscribe(new_symbols) => {
                                                info!(target: AGG_TRADE_TARGET, "è¿æ¥ {} æ”¶åˆ°åŠ¨æ€è®¢é˜…: {:?}", connection_id, new_symbols);
                                                let new_streams: Vec<String> = new_symbols.iter()
                                                    .map(|s| format!("{}@aggTrade", s.to_lowercase()))
                                                    .collect();

                                                let sub_msg = serde_json::json!({
                                                    "method": "SUBSCRIBE",
                                                    "params": &new_streams,
                                                    "id": chrono::Utc::now().timestamp_millis()
                                                }).to_string();

                                                // [æ–°å¢] æ‰“å°å®Œæ•´çš„åŠ¨æ€è®¢é˜…ä¿¡æ¯
                                                info!(
                                                    target: AGG_TRADE_TARGET,
                                                    log_type = "low_freq",
                                                    connection_id = connection_id,
                                                    original_symbols = ?new_symbols,
                                                    formatted_streams = ?new_streams,
                                                    subscription_message = %sub_msg,
                                                    "ğŸ“¤ AggTradeClient å‘é€åŠ¨æ€è®¢é˜…æ¶ˆæ¯"
                                                );

                                                // [æ–°å¢] é¢å¤–çš„ç®€åŒ–æ—¥å¿—ï¼Œç¡®ä¿åŠ¨æ€è®¢é˜…å†…å®¹å¯è§
                                                info!(target: AGG_TRADE_TARGET, "ğŸ”„ åŠ¨æ€è®¢é˜…: {} ä¸ªæ–°å“ç§", new_symbols.len());
                                                info!(target: AGG_TRADE_TARGET, "ğŸ”„ åŠ¨æ€è®¢é˜…æ¶ˆæ¯: {}", sub_msg);
                                                info!(target: AGG_TRADE_TARGET, "ğŸ”„ æ–°å“ç§: {:?}", new_symbols);

                                                if let Err(e) = ws.write_frame(Frame::text(sub_msg.into_bytes().into())).await {
                                                    error!(target: AGG_TRADE_TARGET, "å‘é€åŠ¨æ€è®¢é˜…å¤±è´¥: {}", e);
                                                    break 'message_loop; // å‘é€å¤±è´¥ï¼Œé€€å‡ºé‡è¿
                                                }

                                                current_streams.extend(new_streams); // æ›´æ–°å½“å‰è¿æ¥ç®¡ç†çš„æµ

                                                // æ›´æ–°è¿æ¥çŠ¶æ€ä¸­çš„æµåˆ—è¡¨
                                                {
                                                    let mut connections = connections_clone.lock().await;
                                                    if let Some(conn) = connections.get_mut(&connection_id) {
                                                        conn.streams = current_streams.clone();
                                                    }
                                                }

                                                info!(target: AGG_TRADE_TARGET, "åŠ¨æ€è®¢é˜…æˆåŠŸï¼Œå½“å‰ç®¡ç† {} ä¸ªæµ", current_streams.len());
                                            }
                                        }
                                    }
                                }
                            } // ç»“æŸ tokio::select!
                        } // ç»“æŸ 'message_loop: loop
                        }, // ç»“æŸ Ok(mut ws) => { ... } åˆ†æ”¯
                        Err(e) => {
                            // æ›´æ–°çŠ¶æ€
                            {
                                let mut connections = connections_clone.lock().await;
                                if let Some(conn) = connections.get_mut(&connection_id) {
                                    conn.status = format!("è¿æ¥å¤±è´¥: {}", e);
                                }
                            }

                            error!(target: AGG_TRADE_TARGET, "è¿æ¥ {} å¤±è´¥: {}", connection_id, e);
                        }
                    }

                    // é‡è¿å»¶è¿Ÿ
                    sleep(Duration::from_secs(5)).await;
                } // ç»“æŸ 'reconnect_loop: loop
            } // ç»“æŸ async move å—
            .instrument(tracing::info_span!("websocket_connection", connection_id = connection_id))); // ç»“æŸ tokio::spawn

            // ç­‰å¾…è¿æ¥ä»»åŠ¡å®Œæˆ
            if let Err(e) = connection_task.await {
                error!(target: AGG_TRADE_TARGET, "è¿æ¥ä»»åŠ¡é”™è¯¯: {}", e);
            }

            info!(target: AGG_TRADE_TARGET, "å½’é›†äº¤æ˜“å®¢æˆ·ç«¯å·²åœæ­¢");
            Ok(())
        }
    }

    /// è·å–è¿æ¥çŠ¶æ€
    fn get_connections(&self) -> impl std::future::Future<Output = Vec<WebSocketConnection>> + Send {
        async move {
            let connections = self.connections.lock().await;
            connections.values().cloned().collect()
        }
    }
}

//=============================================================================
// å…¨å¸‚åœºç²¾ç®€Tickerå®¢æˆ·ç«¯
//=============================================================================

/// å…¨å¸‚åœºç²¾ç®€Tickerå®¢æˆ·ç«¯
pub struct MiniTickerClient {
    config: MiniTickerConfig,
    connection_id_counter: AtomicUsize,
    connections: Arc<TokioMutex<HashMap<usize, WebSocketConnection>>>,
    /// å¤–éƒ¨æ³¨å…¥çš„æ¶ˆæ¯å¤„ç†å™¨
    external_handler: Arc<MiniTickerMessageHandler>,
}

impl MiniTickerClient {
    /// åˆ›å»ºä¸€ä¸ªæ–°çš„ MiniTickerClient
    #[instrument(skip_all)]
    pub fn new(config: MiniTickerConfig, handler: Arc<MiniTickerMessageHandler>) -> Self {
        Self {
            config,
            connection_id_counter: AtomicUsize::new(1),
            connections: Arc::new(TokioMutex::new(HashMap::new())),
            external_handler: handler,
        }
    }
}

impl WebSocketClient for MiniTickerClient {
    /// å¯åŠ¨å®¢æˆ·ç«¯ï¼Œå†…ç½®å¥å£®çš„é‡è¿å¾ªç¯
    fn start(&mut self) -> impl std::future::Future<Output = Result<()>> + Send {
        async move {
            info!(target: MINI_TICKER_TARGET, "å¯åŠ¨å…¨å¸‚åœºç²¾ç®€Tickerå®¢æˆ·ç«¯ (ä»£ç†: {})", self.config.use_proxy);

            // 1. åˆå§‹åŒ–æ‰€éœ€èµ„æº
            let (use_proxy, proxy_addr, proxy_port) = self.config.get_proxy_settings();
            let connection_manager = ConnectionManager::new(use_proxy, proxy_addr, proxy_port);
            let handler = self.external_handler.clone();
            let connections = self.connections.clone();
            let streams = self.config.get_streams();
            let connection_id = self.connection_id_counter.fetch_add(1, Ordering::SeqCst);

            // é¢„å…ˆæ’å…¥è¿æ¥çŠ¶æ€è®°å½•
            connections.lock().await.insert(connection_id, WebSocketConnection {
                id: connection_id,
                streams: streams.clone(),
                status: "åˆå§‹åŒ–".to_string(),
                message_count: 0,
            });

            // 2. å¯åŠ¨å•ä¸ªåå°ä»»åŠ¡ï¼Œè¯¥ä»»åŠ¡åŒ…å«å®Œæ•´çš„é‡è¿å’Œæ¶ˆæ¯å¤„ç†é€»è¾‘
            tokio::spawn(async move {
                // è¿™æ˜¯ä¸»é‡è¿å¾ªç¯
                'reconnect_loop: loop {
                    // æ›´æ–°çŠ¶æ€ä¸º"è¿æ¥ä¸­"
                    connections.lock().await.get_mut(&connection_id).map(|c| c.status = "è¿æ¥ä¸­".to_string());

                    // å°è¯•è¿æ¥
                    match connection_manager.connect().await {
                        Ok(mut ws) => {
                            connections.lock().await.get_mut(&connection_id).map(|c| c.status = "å·²è¿æ¥".to_string());
                            info!(target: MINI_TICKER_TARGET, "MiniTicker è¿æ¥ {} å·²å»ºç«‹ï¼Œå‡†å¤‡å‘é€è®¢é˜…", connection_id);

                            // å‘é€è®¢é˜…æ¶ˆæ¯
                            let sub_msg = create_subscribe_message(&streams);
                            if let Err(e) = ws.write_frame(Frame::text(sub_msg.into_bytes().into())).await {
                                error!(target: MINI_TICKER_TARGET, "å‘é€è®¢é˜…æ¶ˆæ¯å¤±è´¥: {}ï¼Œå‡†å¤‡é‡è¿", e);
                                sleep(Duration::from_secs(5)).await;
                                continue 'reconnect_loop;
                            }
                            info!(target: MINI_TICKER_TARGET, "MiniTicker è®¢é˜…å‘é€æˆåŠŸ");

                            // è¿›å…¥æ¶ˆæ¯å¤„ç†å¾ªç¯
                            loop {
                                match ws.read_frame().await {
                                    Ok(frame) => {
                                        match frame.opcode {
                                            OpCode::Text => {
                                                let text = String::from_utf8_lossy(&frame.payload).to_string();
                                                connections.lock().await.get_mut(&connection_id).map(|c| c.message_count += 1);
                                                if let Err(e) = handler.handle_message(connection_id, text).await {
                                                    warn!(target: MINI_TICKER_TARGET, "æ¶ˆæ¯å¤„ç†å¤±è´¥: {}", e);
                                                }
                                            },
                                            OpCode::Close => {
                                                info!(target: MINI_TICKER_TARGET, "æœåŠ¡å™¨å…³é—­è¿æ¥ï¼Œå‡†å¤‡é‡è¿...");
                                                break; // é€€å‡ºæ¶ˆæ¯å¾ªç¯ï¼Œè¿›å…¥é‡è¿é€»è¾‘
                                            },
                                            OpCode::Ping => {
                                                let pong = Frame::pong(frame.payload);
                                                if let Err(e) = ws.write_frame(pong).await {
                                                    error!(target: MINI_TICKER_TARGET, "å‘é€Pongå¤±è´¥: {}", e);
                                                    break;
                                                }
                                            },
                                            _ => {}
                                        }
                                    },
                                    Err(e) => {
                                        error!(target: MINI_TICKER_TARGET, "WebSocketè¯»å–é”™è¯¯: {}ï¼Œå‡†å¤‡é‡è¿", e);
                                        break; // é€€å‡ºæ¶ˆæ¯å¾ªç¯ï¼Œè¿›å…¥é‡è¿é€»è¾‘
                                    }
                                }
                            }
                        }
                        Err(e) => {
                            connections.lock().await.get_mut(&connection_id).map(|c| c.status = format!("è¿æ¥å¤±è´¥: {}", e));
                            error!(target: MINI_TICKER_TARGET, "MiniTicker è¿æ¥ {} å¤±è´¥: {}ï¼Œå‡†å¤‡é‡è¯•", connection_id, e);
                        }
                    }

                    // ä»»ä½•æ–­å¼€æˆ–å¤±è´¥åï¼Œéƒ½ç­‰å¾…5ç§’å†é‡è¯•
                    sleep(Duration::from_secs(5)).await;
                }
            }.instrument(tracing::info_span!("mini_ticker_connection", id = connection_id)));

            Ok(())
        }
    }

    /// è·å–è¿æ¥çŠ¶æ€
    fn get_connections(&self) -> impl std::future::Future<Output = Vec<WebSocketConnection>> + Send {
        async move {
            self.connections.lock().await.values().cloned().collect()
        }
    }
}
