<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K线聚合系统 - 模块监控 v3.11</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            background-color: #1a1a1a;
            color: #00ff00;
            padding: 10px;
            font-size: 16px;
            line-height: 1.5;
        }

        .header {
            text-align: center;
            padding: 10px;
            border-bottom: 2px solid #333;
            margin-bottom: 15px;
        }

        .header h1 {
            color: #00ffff;
            font-size: 24px;
            margin-bottom: 8px;
        }

        .system-status {
            color: #ffff00;
            font-size: 14px;
        }

        .modules-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 15px;
            height: calc(100vh - 120px);
        }

        .module {
            border: 1px solid #333;
            border-radius: 5px;
            background-color: #0a0a0a;
            display: flex;
            flex-direction: column;
        }

        .module-header {
            padding: 8px 12px;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .module-title {
            font-weight: bold;
            font-size: 16px;
        }

        .module-status {
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }

        .status-running { background-color: #006600; color: #00ff00; }
        .status-waiting { background-color: #666600; color: #ffff00; }
        .status-error { background-color: #660000; color: #ff0000; }
        .status-disconnected { background-color: #663300; color: #ff9900; }

        .module-stats {
            padding: 10px 15px;
            border-bottom: 1px solid #333;
            font-size: 13px;
            color: #cccccc;
        }

        .stat-line {
            display: flex;
            justify-content: space-between;
            margin-bottom: 2px;
        }

        .module-logs {
            flex: 1;
            padding: 10px 15px;
            overflow-y: auto;
            overflow-x: hidden;
            font-size: 13px;
            line-height: 1.4;
            /* 确保滚动容器能够捕获鼠标事件 */
            position: relative;
            /* 防止滚动事件冒泡到父元素 */
            overscroll-behavior: contain;
            /* 设置最小高度确保滚动区域足够大 */
            min-height: 200px;
            /* 确保容器有明确的边界 */
            border: 1px solid transparent;
            /* 确保容器可以滚动 - 设置固定高度强制产生滚动条 */
            max-height: 400px;
            /* 焦点时的视觉反馈 */
            outline: none;
        }

        /* 鼠标悬停时的视觉反馈 */
        .module-logs:hover {
            border-color: #333;
            background-color: rgba(255, 255, 255, 0.02);
        }

        /* 获得焦点时的视觉反馈 */
        .module-logs:focus {
            border-color: #00ffff;
            background-color: rgba(0, 255, 255, 0.05);
            box-shadow: 0 0 0 2px rgba(0, 255, 255, 0.2);
        }

        /* 滚动提示样式 */
        .scroll-hint {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(0, 255, 255, 0.8);
            color: #000;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            z-index: 10;
        }

        .module-logs:focus .scroll-hint {
            opacity: 1;
        }

        .log-entry {
            margin-bottom: 3px;
            word-wrap: break-word;
            cursor: pointer;
            padding: 6px 8px;
            border-radius: 4px;
            transition: all 0.2s ease;
            border-left: 4px solid transparent;
        }

        .log-entry:hover {
            background-color: #2a2a2a;
            transform: translateX(2px);
        }

        .log-entry.active {
            background-color: #333;
            box-shadow: 0 2px 4px rgba(0,255,0,0.3);
        }

        /* 日志级别颜色 - 只用边框颜色区分 */
        .log-level-INFO { border-left-color: #00ff00; }
        .log-level-WARN { border-left-color: #ffff00; }
        .log-level-ERROR { border-left-color: #ff0000; }
        .log-level-DEBUG { border-left-color: #00ffff; }

        /* 聚合日志样式 */
        .aggregated-log {
            border-left: 3px solid #4dabf7 !important;
            background: rgba(77, 171, 247, 0.1);
        }

        .aggregated-log .log-message {
            font-weight: 500;
        }

        .aggregated-log:hover {
            background: rgba(77, 171, 247, 0.2);
        }

        .log-message {
            color: #cccccc;
            font-size: 13px;
            /* 限制最多显示1行 */
            display: -webkit-box;
            -webkit-line-clamp: 1;
            line-clamp: 1; /* 标准属性 */
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.4;
            max-height: calc(1.4em * 1); /* 1行的高度 */
            word-wrap: break-word;
            word-break: break-word;
        }

        /* 聚合日志样式 */
        .aggregated-log {
            background-color: #1a1a2e !important;
            border-left-width: 6px !important;
        }

        .aggregated-log:hover {
            background-color: #2a2a3e !important;
        }

        .aggregated-log .log-message {
            font-weight: bold;
            color: #ffffff;
            /* 聚合日志也限制1行显示 */
            display: -webkit-box;
            -webkit-line-clamp: 1;
            line-clamp: 1;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.4;
            max-height: calc(1.4em * 1);
            word-wrap: break-word;
            word-break: break-word;
        }

        /* 日志移动动画 */

        .log-updated {
            background-color: #2a4a2a !important;
            animation: logUpdate 0.5s ease-out;
        }

        @keyframes logUpdate {
            0% {
                background-color: #4a6a4a;
                transform: scale(1.02);
            }
            100% {
                background-color: #2a4a2a;
                transform: scale(1);
            }
        }

        /* 原始JSON展开样式 */
        .raw-json {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-in-out;
            margin-bottom: 6px;
        }

        .raw-json.expanded {
            max-height: 300px;
        }

        .json-container {
            background-color: #000;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 8px;
            margin-top: 4px;
        }

        .json-header {
            display: flex;
            justify-content: between;
            align-items: center;
            margin-bottom: 6px;
            color: #00ff00;
            font-size: 12px;
        }

        .json-close {
            color: #666;
            cursor: pointer;
            font-size: 14px;
            margin-left: auto;
        }

        .json-close:hover {
            color: #fff;
        }

        .json-content {
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            line-height: 1.4;
            white-space: pre-wrap;
            overflow-x: auto;
        }

        /* 动态模块样式 */
        .module-title { color: #00ffff; }

        /* 滚动条样式 */
        .module-logs::-webkit-scrollbar {
            width: 6px;
        }

        .module-logs::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        .module-logs::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 3px;
        }

        .connection-status {
            position: fixed;
            top: 15px;
            right: 15px;
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 14px;
            font-weight: bold;
        }

        .connected { background-color: #006600; color: #00ff00; }
        .disconnected { background-color: #660000; color: #ff0000; }

        /* 模块名称显示区域样式 */
        .module-names-section {
            margin-top: 15px;
            padding: 10px;
            border: 1px solid #333;
            border-radius: 5px;
            background-color: #0a0a0a;
        }

        .module-names-header {
            color: #00ffff;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 15px;
        }





        /* 顶部复制按钮 */
        .header-copy-button {
            background-color: #ff6600;
            color: #ffffff;
            border: 2px solid #ff8833;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 14px;
            font-family: 'Consolas', monospace;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 6px rgba(255, 102, 0, 0.4);
            margin-left: 15px;
        }

        .header-copy-button:hover {
            background-color: #ff8833;
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(255, 102, 0, 0.6);
        }

        .header-copy-button.copied {
            background-color: #44ff44;
            color: #000000;
            border-color: #66ff66;
        }

        /* 顶部切换按钮 */
        .header-toggle-button {
            background-color: #0066ff;
            color: #ffffff;
            border: 2px solid #3388ff;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 14px;
            font-family: 'Consolas', monospace;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 6px rgba(0, 102, 255, 0.4);
            margin-left: 10px;
        }

        .header-toggle-button:hover {
            background-color: #3388ff;
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0, 102, 255, 0.6);
        }

        .header-toggle-button.active {
            background-color: #44ff44;
            color: #000000;
            border-color: #66ff66;
            box-shadow: 0 2px 6px rgba(68, 255, 68, 0.4);
        }



        .module-names-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            min-height: 30px;
            align-items: center;
        }

        .module-name-tag {
            background-color: #1a4a1a;
            color: #00ff00;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-family: 'Consolas', monospace;
            cursor: pointer;
            border: 1px solid #006600;
            transition: all 0.2s ease;
        }

        .module-name-tag:hover {
            background-color: #2a5a2a;
            border-color: #00ff00;
            transform: scale(1.05);
        }

        .module-name-tag.copied {
            background-color: #4a4a1a;
            color: #ffff00;
            border-color: #ffff00;
        }

        .no-modules {
            color: #666;
            font-style: italic;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="connection-status" id="connection-status">连接中...</div>
    
    <div class="header">
        <h1>K线聚合系统 - 模块监控 v3.11</h1>
            <button class="header-copy-button" id="header-copy-modules" title="复制所有模块名称">🔥 复制全部模块</button>
            <button class="header-toggle-button" id="toggle-realtime-logs" title="显示/隐藏实时原始日志">📊 显示实时原始日志</button>
        </h1>
        <div class="system-status">
            运行时间: <span id="uptime">--:--:--</span> |
            健康分数: <span id="health-score">--%</span> |
            验证事件: <span id="validation-events">--</span> |
            性能监控: <span id="performance-spans">--</span>
        </div>

        <!-- 模块名称显示区域 -->
        <div class="module-names-section">
            <div class="module-names-header">
                <span>📋 检测到的模块名称 (点击单个复制):</span>
            </div>
            <div class="module-names-list" id="module-names-list">
                <span class="no-modules">暂无模块数据</span>
            </div>
        </div>
    </div>

    <div class="modules-container">
        <!-- 实时原始日志模块 (默认隐藏) -->
        <div class="module" id="realtime-logs-module" style="display: none;">
            <div class="module-header">
                <div class="module-title">实时原始日志 (RealtimeLogs)</div>
                <div class="module-status status-waiting" id="realtime-logs-status">等待日志</div>
            </div>
            <div class="module-stats">
                <div class="stat-line">
                    <span>实时日志数:</span>
                    <span id="realtime-log-count">0</span>
                </div>
                <div class="stat-line">
                    <span>最后更新:</span>
                    <span id="last-log-time">--:--:--</span>
                </div>
                <div class="stat-line">
                    <span>日志频率:</span>
                    <span id="log-frequency">-- 条/秒</span>
                </div>
            </div>
            <div class="module-logs" id="realtime-logs-display" tabindex="0" title="点击获得焦点，然后滚动查看历史日志">
                <div class="scroll-hint">可滚动</div>
                <div class="log-entry">等待实时日志数据...</div>
            </div>
        </div>

        <!-- 原始日志低频快照模块 -->
        <div class="module" id="raw-logs-module">
            <div class="module-header">
                <div class="module-title">原始日志高频折叠 (RawLogSnapshot)</div>
                <div class="module-status status-waiting" id="raw-logs-status">等待折叠</div>
            </div>
            <div class="module-stats">
                <div class="stat-line">
                    <span>折叠时间:</span>
                    <span id="snapshot-timestamp">--:--:--</span>
                </div>
                <div class="stat-line">
                    <span>原始日志数:</span>
                    <span id="total-log-count">--</span>
                </div>
                <div class="stat-line">
                    <span>折叠后条数:</span>
                    <span id="displayed-log-count">--</span>
                </div>
            </div>
            <div class="module-logs" id="raw-logs-display" tabindex="0" title="点击获得焦点，然后滚动查看历史日志">
                <div class="scroll-hint">可滚动</div>
                <button onclick="diagnoseContainer('raw-logs-display')" style="position: absolute; top: 25px; right: 5px; z-index: 20; padding: 2px 6px; font-size: 10px; background: #ff00ff; color: white; border: none; border-radius: 3px;">诊断容器</button>
                <div class="log-entry">等待日志快照数据...</div>
            </div>
        </div>

        <!-- 动态模块将在这里创建 -->
    </div>





    <script>
        // WebSocket连接
        let ws = null;
        let reconnectInterval = null;

        // 简化的前端状态管理（移除复杂聚合逻辑）
        let createdModules = new Set();
        let moduleHistoryPages = {}; // 记录每个模块的历史数据页码
        let moduleLoadingHistory = {}; // 记录每个模块是否正在加载历史数据
        let moduleHasMoreHistory = {}; // 记录每个模块是否还有更多历史数据

        // 焦点状态管理
        let moduleFocusStates = {}; // 记录每个模块的焦点状态
        let moduleAutoScrollStates = {}; // 记录每个模块是否应该自动滚动



        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws`;
            
            ws = new WebSocket(wsUrl);
            
            ws.onopen = function() {
                console.log('🔗 WebSocket已连接');
                updateConnectionStatus(true);
                if (reconnectInterval) {
                    clearInterval(reconnectInterval);
                    reconnectInterval = null;
                }
            };
            
            ws.onmessage = function(event) {
                try {
                    const message = JSON.parse(event.data);

                    // 处理不同类型的消息
                    if (message.type === 'DashboardUpdate') {
                        // 处理聚合仪表板数据（统一格式）
                        updateDashboardWithAggregatedData(message.data);
                    } else if (message.type === 'LogEntry') {
                        // 处理单个日志条目（仅用于实时日志显示）
                        const logEntry = message.data;
                        addLogEntryToRealtimeDisplay(logEntry);
                    } else {
                        console.log('未知消息类型:', message.type);
                    }
                } catch (e) {
                    console.error('解析WebSocket消息失败:', e);
                }
            };
            
            ws.onclose = function() {
                console.log('WebSocket连接已关闭');
                updateConnectionStatus(false);
                if (!reconnectInterval) {
                    reconnectInterval = setInterval(connectWebSocket, 5000);
                }
            };
            
            ws.onerror = function(error) {
                console.error('WebSocket错误:', error);
                updateConnectionStatus(false);
            };
        }

        function updateConnectionStatus(connected) {
            const statusEl = document.getElementById('connection-status');

            if (connected) {
                statusEl.textContent = '已连接';
                statusEl.className = 'connection-status connected';
            } else {
                statusEl.textContent = '连接断开';
                statusEl.className = 'connection-status disconnected';
            }
        }

        // 旧版本的 addLogEntryToRealtimeDisplay 函数已移除，使用文件末尾的新版本（包含焦点逻辑）







        // 处理聚合仪表板数据
        function updateDashboardWithAggregatedData(data) {

            // 更新系统状态
            updateSystemStatusFromAggregatedData(data);

            // 更新实时日志
            updateRealtimeLogsFromAggregatedData(data.realtime_log_data);

            // 更新原始日志快照
            updateRawLogSnapshotFromAggregatedData(data.raw_log_snapshot);

            // 更新模块日志（使用后端聚合数据）
            if (data.module_logs) {
                updateModuleLogsFromAggregatedData(data.module_logs);
            }
        }

        // 移除旧的updateDashboard函数，统一使用updateDashboardWithAggregatedData









        // 从日志行中提取消息
        function extractMessageFromLogLine(logLine) {
            try {
                // 首先尝试解析为JSON
                const jsonLog = JSON.parse(logLine);
                if (jsonLog.message) {
                    return jsonLog.message;
                }
            } catch (e) {
                // 如果不是JSON，尝试从文本格式中提取
                // 格式通常是: [时间戳] LEVEL target: message
                const parts = logLine.split(': ');
                if (parts.length > 1) {
                    return parts.slice(1).join(': ').trim();
                }

                // 如果没有冒号，尝试其他分隔符
                const bracketParts = logLine.split('] ');
                if (bracketParts.length > 1) {
                    return bracketParts.slice(1).join('] ').trim();
                }
            }

            // 如果都失败了，返回整行（但这不应该发生）
            return logLine.trim();
        }

        // 从日志行中提取级别
        function extractLevelFromLogLine(logLine) {
            try {
                // 首先尝试解析为JSON
                const jsonLog = JSON.parse(logLine);
                if (jsonLog.level) {
                    return jsonLog.level.toUpperCase();
                }
            } catch (e) {
                // 如果不是JSON，从文本中查找级别
                if (logLine.includes('ERROR')) return 'ERROR';
                if (logLine.includes('WARN')) return 'WARN';
                if (logLine.includes('INFO')) return 'INFO';
                if (logLine.includes('DEBUG')) return 'DEBUG';
                if (logLine.includes('TRACE')) return 'TRACE';
            }
            return 'INFO';
        }

        // 跟踪已创建的模块（已在上面声明）

        function getModuleContainerId(moduleName) {
            // 将模块名转换为有效的HTML ID
            return 'module-' + moduleName.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase();
        }

        function ensureModuleContainer(moduleName) {
            if (createdModules.has(moduleName)) {
                return; // 模块已存在
            }

            console.log('🆕 创建模块:', moduleName);
            const containerId = getModuleContainerId(moduleName);
            const logsId = containerId + '-logs';

            // 创建模块容器
            const moduleDiv = document.createElement('div');
            moduleDiv.className = 'module';
            moduleDiv.innerHTML = `
                <div class="module-header">
                    <div class="module-title">${moduleName}</div>
                    <div class="module-status status-running" id="${containerId}-status">运行中</div>
                </div>
                <div class="module-stats">
                    <div class="stat-line">
                        <span>总日志数:</span>
                        <span id="${containerId}-total">0</span>
                    </div>
                    <div class="stat-line">
                        <span>错误数:</span>
                        <span id="${containerId}-errors">0</span>
                    </div>
                    <div class="stat-line">
                        <span>最后更新:</span>
                        <span id="${containerId}-last-update">--:--:--</span>
                    </div>
                </div>
                <div class="module-logs" id="${logsId}" tabindex="0" title="点击获得焦点，然后滚动查看历史日志">
                    <div class="scroll-hint">可滚动</div>
                    <button onclick="testScroll('${logsId}')" style="position: absolute; top: 25px; right: 5px; z-index: 20; padding: 2px 6px; font-size: 10px; background: #ff6600; color: white; border: none; border-radius: 3px;">测试滚动</button>
                    <button onclick="addTestContent('${logsId}')" style="position: absolute; top: 45px; right: 5px; z-index: 20; padding: 2px 6px; font-size: 10px; background: #00ff00; color: black; border: none; border-radius: 3px;">添加测试内容</button>
                    <button onclick="diagnoseContainer('${logsId}')" style="position: absolute; top: 65px; right: 5px; z-index: 20; padding: 2px 6px; font-size: 10px; background: #ff00ff; color: white; border: none; border-radius: 3px;">诊断容器</button>
                    <div class="log-entry">等待日志数据...</div>
                </div>
            `;

            // 添加到模块容器中
            const modulesContainer = document.querySelector('.modules-container');
            modulesContainer.appendChild(moduleDiv);

            // 为新创建的日志容器绑定滚动事件
            const logsContainer = moduleDiv.querySelector('.module-logs');
            if (logsContainer) {
                // 初始化模块焦点状态
                moduleFocusStates[moduleName] = false;
                moduleAutoScrollStates[moduleName] = true; // 默认启用自动滚动

                // 点击获得焦点，使鼠标滚轮能够正常工作
                logsContainer.addEventListener('click', function(event) {
                    // 如果点击的不是日志条目，则获得焦点
                    if (!event.target.closest('.log-entry')) {
                        logsContainer.focus();
                        console.log(`🎯 模块 [${moduleName}] 点击获得焦点`, {
                            hasFocus: document.activeElement === logsContainer,
                            tabIndex: logsContainer.tabIndex,
                            canScroll: logsContainer.scrollHeight > logsContainer.clientHeight
                        });
                    }
                });

                // 鼠标进入时自动获得焦点（更好的用户体验）
                logsContainer.addEventListener('mouseenter', function(event) {
                    logsContainer.focus();
                    console.log(`🖱️ 模块 [${moduleName}] 鼠标进入获得焦点`, {
                        hasFocus: document.activeElement === logsContainer,
                        tabIndex: logsContainer.tabIndex,
                        canScroll: logsContainer.scrollHeight > logsContainer.clientHeight
                    });
                });

                // 焦点获得事件
                logsContainer.addEventListener('focus', function(event) {
                    moduleFocusStates[moduleName] = true;
                    moduleAutoScrollStates[moduleName] = false; // 有焦点时禁用自动滚动
                    console.log(`🎯 模块 [${moduleName}] 获得焦点 - 禁用自动滚动`);
                });

                // 焦点失去事件
                logsContainer.addEventListener('blur', function(event) {
                    moduleFocusStates[moduleName] = false;
                    moduleAutoScrollStates[moduleName] = true; // 失去焦点时启用自动滚动
                    console.log(`🎯 模块 [${moduleName}] 失去焦点 - 启用自动滚动`);
                });

                // 添加详细的滚动事件日志
                logsContainer.addEventListener('wheel', function(event) {
                    const canScroll = logsContainer.scrollHeight > logsContainer.clientHeight;
                    console.log(`🖱️ 模块 [${moduleName}] 鼠标滚轮事件:`, {
                        deltaY: event.deltaY,
                        deltaX: event.deltaX,
                        target: event.target.tagName,
                        scrollTop: logsContainer.scrollTop,
                        scrollHeight: logsContainer.scrollHeight,
                        clientHeight: logsContainer.clientHeight,
                        canScroll: canScroll
                    });

                    // 手动处理滚动，确保滚动事件被触发
                    if (canScroll) {
                        const currentScrollTop = logsContainer.scrollTop;
                        const scrollAmount = event.deltaY * 0.5; // 调整滚动速度
                        const newScrollTop = Math.max(0, Math.min(
                            logsContainer.scrollHeight - logsContainer.clientHeight,
                            currentScrollTop + scrollAmount
                        ));

                        console.log(`🔄 模块 [${moduleName}] 手动滚动: ${currentScrollTop} -> ${newScrollTop}`);
                        logsContainer.scrollTop = newScrollTop;

                        // 手动触发滚动事件
                        const scrollEvent = new Event('scroll', { bubbles: true });
                        logsContainer.dispatchEvent(scrollEvent);
                    }

                    // 阻止默认滚动和事件冒泡
                    event.preventDefault();
                    event.stopPropagation();
                });

                // 阻止触摸滚动事件冒泡（移动设备支持）
                logsContainer.addEventListener('touchmove', function(event) {
                    console.log(`👆 模块 [${moduleName}] 触摸滚动事件`);
                    event.stopPropagation();
                });

                // 添加滚动事件监听器，用于加载历史数据
                logsContainer.addEventListener('scroll', function(event) {
                    console.log(`📜 模块 [${moduleName}] 滚动事件:`, {
                        scrollTop: logsContainer.scrollTop,
                        scrollHeight: logsContainer.scrollHeight,
                        clientHeight: logsContainer.clientHeight,
                        canScrollMore: logsContainer.scrollHeight > logsContainer.clientHeight
                    });
                    handleModuleScroll(event, moduleName, logsContainer);
                });
            }

            createdModules.add(moduleName);
        }

        // 更新模块名称列表（从聚合数据中提取）
        function updateModuleNamesFromAggregatedData(moduleLogs) {
            const moduleNames = Object.keys(moduleLogs || {});
            updateModuleNamesList(moduleNames);
        }





        // 跟踪当前展开的日志
        let activeLogId = null;

        // 测试滚动函数
        function testScroll(containerId) {
            const container = document.getElementById(containerId);
            if (container) {
                console.log(`🧪 测试滚动 [${containerId}]:`, {
                    scrollTop: container.scrollTop,
                    scrollHeight: container.scrollHeight,
                    clientHeight: container.clientHeight,
                    canScroll: container.scrollHeight > container.clientHeight,
                    hasFocus: document.activeElement === container,
                    tabIndex: container.tabIndex
                });

                // 手动触发滚动到顶部
                container.scrollTop = 0;
                console.log(`🧪 手动滚动到顶部后:`, {
                    scrollTop: container.scrollTop
                });

                // 手动触发滚动事件
                const scrollEvent = new Event('scroll', { bubbles: true });
                container.dispatchEvent(scrollEvent);
                console.log(`🧪 手动触发滚动事件完成`);
            } else {
                console.error(`🧪 找不到容器: ${containerId}`);
            }
        }

        // 添加测试内容函数
        function addTestContent(containerId) {
            const container = document.getElementById(containerId);
            if (container) {
                console.log(`🧪 为容器 [${containerId}] 添加测试内容`);

                // 清空现有内容
                container.innerHTML = `
                    <div class="scroll-hint">可滚动</div>
                    <button onclick="testScroll('${containerId}')" style="position: absolute; top: 25px; right: 5px; z-index: 20; padding: 2px 6px; font-size: 10px; background: #ff6600; color: white; border: none; border-radius: 3px;">测试滚动</button>
                    <button onclick="addTestContent('${containerId}')" style="position: absolute; top: 45px; right: 5px; z-index: 20; padding: 2px 6px; font-size: 10px; background: #00ff00; color: black; border: none; border-radius: 3px;">添加测试内容</button>
                    <button onclick="diagnoseContainer('${containerId}')" style="position: absolute; top: 65px; right: 5px; z-index: 20; padding: 2px 6px; font-size: 10px; background: #ff00ff; color: white; border: none; border-radius: 3px;">诊断容器</button>
                `;

                // 添加50条测试日志
                for (let i = 1; i <= 50; i++) {
                    const logEntry = document.createElement('div');
                    logEntry.className = 'log-entry log-level-INFO';
                    logEntry.innerHTML = `<div class="log-message">测试日志条目 ${i} - 这是一条用于测试滚动功能的日志</div>`;
                    container.appendChild(logEntry);
                }

                // 存储测试数据到容器属性
                const testLogs = [];
                for (let i = 1; i <= 100; i++) {
                    testLogs.push({
                        message: `历史测试日志 ${i} - 这是历史数据`,
                        level: 'INFO',
                        timestamp: new Date().toISOString(),
                        is_aggregated: false
                    });
                }
                container.setAttribute('data-all-logs', JSON.stringify(testLogs));
                container.setAttribute('data-current-display-count', '50');

                console.log(`🧪 添加完成，容器现在可以滚动:`, {
                    scrollHeight: container.scrollHeight,
                    clientHeight: container.clientHeight,
                    canScroll: container.scrollHeight > container.clientHeight,
                    totalTestLogs: testLogs.length
                });
            } else {
                console.error(`🧪 找不到容器: ${containerId}`);
            }
        }

        // 诊断容器函数
        function diagnoseContainer(containerId) {
            const container = document.getElementById(containerId);
            if (container) {
                const computedStyle = window.getComputedStyle(container);
                const children = Array.from(container.children);

                console.log(`🔍 容器 [${containerId}] 诊断报告:`);
                console.log(`📏 尺寸信息:`, {
                    scrollHeight: container.scrollHeight,
                    clientHeight: container.clientHeight,
                    offsetHeight: container.offsetHeight,
                    scrollWidth: container.scrollWidth,
                    clientWidth: container.clientWidth,
                    offsetWidth: container.offsetWidth
                });
                console.log(`🎨 CSS样式:`, {
                    height: computedStyle.height,
                    maxHeight: computedStyle.maxHeight,
                    minHeight: computedStyle.minHeight,
                    overflowY: computedStyle.overflowY,
                    overflowX: computedStyle.overflowX,
                    display: computedStyle.display,
                    position: computedStyle.position,
                    boxSizing: computedStyle.boxSizing
                });
                console.log(`👶 子元素信息:`, {
                    childCount: children.length,
                    childTypes: children.map(child => child.tagName + '.' + child.className),
                    totalChildHeight: children.reduce((sum, child) => sum + child.offsetHeight, 0)
                });
                console.log(`🔄 滚动状态:`, {
                    canScroll: container.scrollHeight > container.clientHeight,
                    scrollTop: container.scrollTop,
                    maxScrollTop: container.scrollHeight - container.clientHeight,
                    hasScrollbar: container.scrollHeight > container.clientHeight
                });
            } else {
                console.error(`🔍 找不到容器: ${containerId}`);
            }
        }

        // 处理模块滚动事件，加载更多显示数据
        function handleModuleScroll(event, moduleName, container) {
            // 检查是否滚动到顶部（允许5px误差）
            if (container.scrollTop <= 5) {
                console.log(`🔄 模块 [${moduleName}] 滚动到顶部，scrollTop: ${container.scrollTop}`);
                loadMoreDisplayLogsForModule(moduleName, container);
            }
        }

        // 为指定模块加载更多显示数据（从本地数据）
        function loadMoreDisplayLogsForModule(moduleName, container) {
            // 防止重复加载
            if (moduleLoadingHistory[moduleName]) {
                return;
            }

            // 获取存储的完整数据
            const allLogsJson = container.getAttribute('data-all-logs');
            if (!allLogsJson) {
                console.log(`ℹ️ 模块 [${moduleName}] 没有更多数据`);
                return;
            }

            const allLogs = JSON.parse(allLogsJson);
            const currentDisplayCount = parseInt(container.getAttribute('data-current-display-count') || '20');

            // 检查是否还有更多数据
            if (currentDisplayCount >= allLogs.length) {
                console.log(`ℹ️ 模块 [${moduleName}] 已显示所有数据`);
                return;
            }

            moduleLoadingHistory[moduleName] = true;

            try {
                console.log(`📜 加载模块 [${moduleName}] 的更多显示数据，当前: ${currentDisplayCount}/${allLogs.length}`);

                // 显示加载指示器
                showLoadingIndicator(container);

                // 模拟异步加载（给用户反馈）
                setTimeout(() => {
                    const nextBatchSize = 20;
                    const nextDisplayCount = Math.min(currentDisplayCount + nextBatchSize, allLogs.length);
                    const newLogs = allLogs.slice(currentDisplayCount, nextDisplayCount);

                    if (newLogs.length > 0) {
                        prependDisplayLogsToContainer(container, newLogs, moduleName, currentDisplayCount);
                        container.setAttribute('data-current-display-count', nextDisplayCount.toString());
                        console.log(`✅ 成功加载 ${newLogs.length} 条显示日志`);

                        // 更新"加载更多"提示
                        updateLoadMoreIndicator(container, allLogs.length, nextDisplayCount);
                    }

                    moduleLoadingHistory[moduleName] = false;
                    hideLoadingIndicator(container);
                }, 100); // 100ms延迟，给用户反馈

            } catch (error) {
                console.error(`❌ 加载模块 [${moduleName}] 显示数据失败:`, error);
                moduleLoadingHistory[moduleName] = false;
                hideLoadingIndicator(container);
            }
        }

        // 在容器顶部添加显示日志
        function prependDisplayLogsToContainer(container, newLogs, moduleName, startIndex) {
            const containerId = getModuleContainerId(moduleName);
            const fragment = document.createDocumentFragment();

            // 记录当前滚动位置
            const currentScrollTop = container.scrollTop;
            const currentScrollHeight = container.scrollHeight;

            // 为每个新日志创建元素
            newLogs.forEach((logEntry, index) => {
                const logElement = createAggregatedLogElement(logEntry, containerId, startIndex + index);
                fragment.appendChild(logElement);
            });

            // 找到加载更多指示器的位置，在它之前插入
            const loadMoreIndicator = container.querySelector('.load-more-indicator');
            if (loadMoreIndicator) {
                container.insertBefore(fragment, loadMoreIndicator);
            } else {
                // 如果没有指示器，插入到容器顶部
                container.insertBefore(fragment, container.firstChild);
            }

            // 调整滚动位置，保持用户当前的视图
            const newScrollHeight = container.scrollHeight;
            const heightDifference = newScrollHeight - currentScrollHeight;
            container.scrollTop = currentScrollTop + heightDifference;
        }

        // 更新"加载更多"指示器
        function updateLoadMoreIndicator(container, totalLogs, currentDisplayCount) {
            const indicator = container.querySelector('.load-more-indicator');
            if (indicator) {
                if (currentDisplayCount >= totalLogs) {
                    indicator.textContent = '已显示所有日志';
                    indicator.style.cursor = 'default';
                } else {
                    indicator.textContent = `还有 ${totalLogs - currentDisplayCount} 条日志，滚动到顶部加载更多`;
                }
            }
        }

        // 显示加载指示器
        function showLoadingIndicator(container) {
            // 检查是否已经有加载指示器
            let indicator = container.querySelector('.loading-indicator');
            if (!indicator) {
                indicator = document.createElement('div');
                indicator.className = 'loading-indicator';
                indicator.style.cssText = `
                    padding: 10px;
                    text-align: center;
                    color: #888;
                    font-size: 12px;
                    border-bottom: 1px solid #333;
                `;
                indicator.textContent = '⏳ 加载历史数据...';
                container.insertBefore(indicator, container.firstChild);
            }
        }

        // 隐藏加载指示器
        function hideLoadingIndicator(container) {
            const indicator = container.querySelector('.loading-indicator');
            if (indicator) {
                indicator.remove();
            }
        }

        // 为原始日志快照模块加载更多数据（专用函数）
        function loadMoreDisplayLogsForRawSnapshot(container) {
            const moduleName = 'RawLogSnapshot';

            if (moduleLoadingHistory[moduleName]) {
                console.log(`⏳ 原始日志快照模块正在加载历史数据，跳过重复请求`);
                return;
            }

            const allLogsJson = container.getAttribute('data-all-logs');
            if (!allLogsJson) {
                console.log(`⚠️ 原始日志快照模块没有存储的完整数据`);
                return;
            }

            const allLogs = JSON.parse(allLogsJson);
            const currentDisplayCount = parseInt(container.getAttribute('data-current-display-count') || '0');

            if (currentDisplayCount >= allLogs.length) {
                console.log(`✅ 原始日志快照模块已显示所有数据 (${currentDisplayCount}/${allLogs.length})`);
                return;
            }

            console.log(`🔄 原始日志快照模块开始加载更多数据: 当前显示 ${currentDisplayCount}/${allLogs.length}`);

            // 设置加载状态
            moduleLoadingHistory[moduleName] = true;
            showLoadingIndicator(container);

            // 模拟异步加载（给用户反馈）
            setTimeout(() => {
                const nextBatchSize = 20;
                const nextDisplayCount = Math.min(currentDisplayCount + nextBatchSize, allLogs.length);
                const newLogs = allLogs.slice(currentDisplayCount, nextDisplayCount);

                if (newLogs.length > 0) {
                    // 为原始日志快照模块添加新的日志元素
                    prependDisplayLogsToRawSnapshotContainer(container, newLogs, currentDisplayCount);
                    container.setAttribute('data-current-display-count', nextDisplayCount.toString());
                    console.log(`✅ 原始日志快照模块成功加载 ${newLogs.length} 条显示日志`);

                    // 更新"加载更多"提示
                    updateLoadMoreIndicator(container, allLogs.length, nextDisplayCount);
                }

                moduleLoadingHistory[moduleName] = false;
                hideLoadingIndicator(container);
            }, 100); // 100ms延迟，给用户反馈
        }

        // 在原始日志快照容器顶部添加显示日志（专用函数）
        function prependDisplayLogsToRawSnapshotContainer(container, newLogs, startIndex) {
            const fragment = document.createDocumentFragment();

            // 记录当前滚动位置
            const currentScrollTop = container.scrollTop;
            const currentScrollHeight = container.scrollHeight;

            // 为每个新日志创建元素
            newLogs.forEach((logEntry, index) => {
                const logElement = createAggregatedLogElement(logEntry, 'raw-logs', startIndex + index);
                fragment.appendChild(logElement);
            });

            // 找到加载更多指示器的位置，在它之前插入
            const loadMoreIndicator = container.querySelector('.load-more-indicator');
            if (loadMoreIndicator) {
                container.insertBefore(fragment, loadMoreIndicator);
            } else {
                // 如果没有指示器，找到第一个日志条目，在它之前插入
                const firstLogEntry = container.querySelector('.log-entry');
                if (firstLogEntry) {
                    container.insertBefore(fragment, firstLogEntry);
                } else {
                    // 如果没有日志条目，直接添加到容器末尾
                    container.appendChild(fragment);
                }
            }

            // 调整滚动位置，保持用户当前的视图
            const newScrollHeight = container.scrollHeight;
            const heightDifference = newScrollHeight - currentScrollHeight;
            container.scrollTop = currentScrollTop + heightDifference;
        }



        // 切换JSON显示
        function toggleJson(logId) {
            // 隐藏其他已展开的JSON
            if (activeLogId && activeLogId !== logId) {
                hideJson(activeLogId);
            }

            const jsonDiv = document.getElementById(`json-${logId}`);
            const logEntry = document.querySelector(`[data-log-id="${logId}"]`);

            if (jsonDiv.classList.contains('expanded')) {
                hideJson(logId);
            } else {
                showJson(logId);
            }
        }

        // 显示JSON
        function showJson(logId) {
            const jsonDiv = document.getElementById(`json-${logId}`);
            const logEntry = document.querySelector(`[data-log-id="${logId}"]`);

            if (jsonDiv && logEntry) {
                jsonDiv.classList.add('expanded');
                logEntry.classList.add('active');
                activeLogId = logId;
            }
        }

        // 隐藏JSON
        function hideJson(logId) {
            const jsonDiv = document.getElementById(`json-${logId}`);
            const logEntry = document.querySelector(`[data-log-id="${logId}"]`);

            if (jsonDiv && logEntry) {
                jsonDiv.classList.remove('expanded');
                logEntry.classList.remove('active');
                if (activeLogId === logId) {
                    activeLogId = null;
                }
            }
        }

        // HTML转义函数
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // 获取当前时间的格式化字符串
        function getCurrentTimeString() {
            return new Date().toLocaleTimeString('zh-CN', {
                hour12: false,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
        }

        // 存储每个模块的最后更新时间和日志计数
        let moduleLastUpdateTimes = {};
        let moduleLogCounts = {};

        // 获取日志级别优先级（用于旧代码兼容）
        function getLogLevelPriority(level) {
            const priorities = {
                'TRACE': 1,
                'DEBUG': 2,
                'INFO': 3,
                'WARN': 4,
                'ERROR': 5
            };
            return priorities[level] || 3;
        }

        // 存储当前的模块名称列表
        let currentModuleNames = [];

        // 更新模块名称列表
        function updateModuleNamesList(moduleNames) {
            const container = document.getElementById('module-names-list');

            // 更新全局模块名称列表
            currentModuleNames = moduleNames || [];

            if (!moduleNames || moduleNames.length === 0) {
                container.innerHTML = '<span class="no-modules">暂无模块数据</span>';
                return;
            }

            // 清空容器
            container.innerHTML = '';

            // 为每个模块名创建可点击的标签
            moduleNames.forEach(moduleName => {
                const tag = document.createElement('span');
                tag.className = 'module-name-tag';
                tag.textContent = moduleName;
                tag.title = '点击复制模块名称';

                // 添加点击复制功能
                tag.addEventListener('click', function() {
                    copyToClipboard(moduleName, tag);
                });

                container.appendChild(tag);
            });
        }

        // 复制到剪贴板功能
        function copyToClipboard(text, element) {
            navigator.clipboard.writeText(text).then(function() {
                // 显示复制成功的视觉反馈
                element.classList.add('copied');
                const originalText = element.textContent;
                element.textContent = '已复制!';

                setTimeout(function() {
                    element.classList.remove('copied');
                    element.textContent = originalText;
                }, 1000);
            }).catch(function(err) {
                console.error('复制失败:', err);
                // 降级方案：使用旧的复制方法
                const textArea = document.createElement('textarea');
                textArea.value = text;
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    element.classList.add('copied');
                    const originalText = element.textContent;
                    element.textContent = '已复制!';

                    setTimeout(function() {
                        element.classList.remove('copied');
                        element.textContent = originalText;
                    }, 1000);
                } catch (err) {
                    console.error('降级复制方法也失败:', err);
                }
                document.body.removeChild(textArea);
            });
        }

        // 复制所有模块名称的函数
        function copyAllModuleNames(buttonElement) {
            if (currentModuleNames.length === 0) {
                alert('暂无模块数据可复制');
                return;
            }

            // 将所有模块名称用换行符连接
            const allModuleNames = currentModuleNames.join('\n');
            const button = buttonElement;

            navigator.clipboard.writeText(allModuleNames).then(function() {
                // 显示复制成功的视觉反馈
                button.classList.add('copied');
                const originalText = button.textContent;
                button.textContent = '✅ 已复制!';

                setTimeout(function() {
                    button.classList.remove('copied');
                    button.textContent = originalText;
                }, 2000);
            }).catch(function(err) {
                console.error('复制失败:', err);
                // 降级方案：使用旧的复制方法
                const textArea = document.createElement('textarea');
                textArea.value = allModuleNames;
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    button.classList.add('copied');
                    const originalText = button.textContent;
                    button.textContent = '✅ 已复制!';

                    setTimeout(function() {
                        button.classList.remove('copied');
                        button.textContent = originalText;
                    }, 2000);
                } catch (err) {
                    console.error('降级复制方法也失败:', err);
                    alert('复制失败，请手动复制模块名称');
                }
                document.body.removeChild(textArea);
            });
        }

        // 切换实时原始日志显示/隐藏
        function toggleRealtimeLogs(buttonElement) {
            const realtimeModule = document.getElementById('realtime-logs-module');
            const button = buttonElement;

            if (!realtimeModule) {
                console.error('找不到实时原始日志模块');
                return;
            }

            const isCurrentlyHidden = realtimeModule.style.display === 'none';

            if (isCurrentlyHidden) {
                // 显示模块
                realtimeModule.style.display = '';
                button.classList.add('active');
                button.textContent = '📊 隐藏实时原始日志';
                button.title = '隐藏实时原始日志';
            } else {
                // 隐藏模块
                realtimeModule.style.display = 'none';
                button.classList.remove('active');
                button.textContent = '📊 显示实时原始日志';
                button.title = '显示实时原始日志';
            }
        }

        // 定期清理过期状态
        function startCleanup() {
            setInterval(() => {
                // 清理过期的展开JSON状态
                if (activeLogId) {
                    const jsonDiv = document.getElementById(`json-${activeLogId}`);
                    if (!jsonDiv) {
                        activeLogId = null;
                    }
                }
            }, 10000); // 每10秒清理一次
        }



        // 页面加载时连接WebSocket并绑定事件
        document.addEventListener('DOMContentLoaded', function() {
            console.log('页面加载完成');
            connectWebSocket();
            startCleanup();

            // 绑定顶部复制按钮的点击事件
            const headerCopyButton = document.getElementById('header-copy-modules');
            if (headerCopyButton) {
                headerCopyButton.addEventListener('click', function() {
                    copyAllModuleNames(this);
                });
            }

            // 绑定实时原始日志切换按钮的点击事件
            const toggleRealtimeButton = document.getElementById('toggle-realtime-logs');
            if (toggleRealtimeButton) {
                toggleRealtimeButton.addEventListener('click', function() {
                    toggleRealtimeLogs(this);
                });
            }

            // 为原始日志快照模块绑定滚动事件处理
            const rawLogsDisplay = document.getElementById('raw-logs-display');
            if (rawLogsDisplay) {
                // 初始化原始日志快照模块焦点状态
                const rawModuleName = 'RawLogSnapshot';
                moduleFocusStates[rawModuleName] = false;
                moduleAutoScrollStates[rawModuleName] = true; // 默认启用自动滚动

                // 点击获得焦点，使鼠标滚轮能够正常工作
                rawLogsDisplay.addEventListener('click', function(event) {
                    if (!event.target.closest('.log-entry')) {
                        rawLogsDisplay.focus();
                        console.log('🎯 原始日志快照模块获得焦点');
                    }
                });

                // 鼠标进入时自动获得焦点
                rawLogsDisplay.addEventListener('mouseenter', function(event) {
                    rawLogsDisplay.focus();
                });

                // 焦点获得事件
                rawLogsDisplay.addEventListener('focus', function(event) {
                    moduleFocusStates[rawModuleName] = true;
                    moduleAutoScrollStates[rawModuleName] = false; // 有焦点时禁用自动滚动
                    console.log(`🎯 原始日志快照模块获得焦点 - 禁用自动滚动`);
                });

                // 焦点失去事件
                rawLogsDisplay.addEventListener('blur', function(event) {
                    moduleFocusStates[rawModuleName] = false;
                    moduleAutoScrollStates[rawModuleName] = true; // 失去焦点时启用自动滚动
                    console.log(`🎯 原始日志快照模块失去焦点 - 启用自动滚动`);
                });

                // 添加详细的滚动事件日志
                rawLogsDisplay.addEventListener('wheel', function(event) {
                    const canScroll = rawLogsDisplay.scrollHeight > rawLogsDisplay.clientHeight;
                    console.log(`🖱️ 原始日志快照模块 鼠标滚轮事件:`, {
                        deltaY: event.deltaY,
                        deltaX: event.deltaX,
                        target: event.target.tagName,
                        scrollTop: rawLogsDisplay.scrollTop,
                        scrollHeight: rawLogsDisplay.scrollHeight,
                        clientHeight: rawLogsDisplay.clientHeight,
                        canScroll: canScroll,
                        计算: `${rawLogsDisplay.scrollHeight} > ${rawLogsDisplay.clientHeight} = ${canScroll}`
                    });

                    // 手动处理滚动，确保滚动事件被触发
                    if (canScroll) {
                        console.log(`✅ 开始手动滚动处理`);
                        const currentScrollTop = rawLogsDisplay.scrollTop;
                        const scrollAmount = event.deltaY * 0.5; // 调整滚动速度
                        const newScrollTop = Math.max(0, Math.min(
                            rawLogsDisplay.scrollHeight - rawLogsDisplay.clientHeight,
                            currentScrollTop + scrollAmount
                        ));

                        console.log(`🔄 手动滚动: ${currentScrollTop} -> ${newScrollTop} (scrollAmount: ${scrollAmount})`);
                        rawLogsDisplay.scrollTop = newScrollTop;

                        // 手动触发滚动事件
                        const scrollEvent = new Event('scroll', { bubbles: true });
                        rawLogsDisplay.dispatchEvent(scrollEvent);
                        console.log(`📤 已手动触发滚动事件`);
                    } else {
                        console.log(`❌ 无法滚动: scrollHeight=${rawLogsDisplay.scrollHeight}, clientHeight=${rawLogsDisplay.clientHeight}`);
                    }

                    // 阻止默认滚动和事件冒泡
                    event.preventDefault();
                    event.stopPropagation();
                });

                // 阻止触摸滚动事件冒泡（移动设备支持）
                rawLogsDisplay.addEventListener('touchmove', function(event) {
                    console.log(`👆 原始日志快照模块 触摸滚动事件`);
                    event.stopPropagation();
                });

                // 添加滚动事件监听器，用于加载历史数据
                rawLogsDisplay.addEventListener('scroll', function(event) {
                    console.log(`📜 原始日志快照模块 滚动事件:`, {
                        scrollTop: rawLogsDisplay.scrollTop,
                        scrollHeight: rawLogsDisplay.scrollHeight,
                        clientHeight: rawLogsDisplay.clientHeight,
                        canScrollMore: rawLogsDisplay.scrollHeight > rawLogsDisplay.clientHeight
                    });
                    // 启用原始日志快照模块的历史加载功能
                    if (rawLogsDisplay.scrollTop <= 5) {
                        console.log(`🔄 原始日志快照模块滚动到顶部，scrollTop: ${rawLogsDisplay.scrollTop}`);
                        loadMoreDisplayLogsForRawSnapshot(rawLogsDisplay);
                    }
                });
            }

            // 为实时原始日志模块绑定完整的滚动事件处理
            const realtimeLogsDisplay = document.getElementById('realtime-logs-display');
            if (realtimeLogsDisplay) {
                // 初始化实时日志模块焦点状态
                const realtimeModuleName = 'RealtimeLogs';
                moduleFocusStates[realtimeModuleName] = false;
                moduleAutoScrollStates[realtimeModuleName] = true; // 默认启用自动滚动

                // 点击获得焦点，使鼠标滚轮能够正常工作
                realtimeLogsDisplay.addEventListener('click', function(event) {
                    if (!event.target.closest('.log-entry')) {
                        realtimeLogsDisplay.focus();
                        console.log('🎯 实时原始日志模块获得焦点');
                    }
                });

                // 鼠标进入时自动获得焦点
                realtimeLogsDisplay.addEventListener('mouseenter', function(event) {
                    realtimeLogsDisplay.focus();
                });

                // 焦点获得事件
                realtimeLogsDisplay.addEventListener('focus', function(event) {
                    moduleFocusStates[realtimeModuleName] = true;
                    moduleAutoScrollStates[realtimeModuleName] = false; // 有焦点时禁用自动滚动
                    console.log(`🎯 实时原始日志模块获得焦点 - 禁用自动滚动`);
                });

                // 焦点失去事件
                realtimeLogsDisplay.addEventListener('blur', function(event) {
                    moduleFocusStates[realtimeModuleName] = false;
                    moduleAutoScrollStates[realtimeModuleName] = true; // 失去焦点时启用自动滚动
                    console.log(`🎯 实时原始日志模块失去焦点 - 启用自动滚动`);
                });

                // 添加详细的滚动事件日志
                realtimeLogsDisplay.addEventListener('wheel', function(event) {
                    const canScroll = realtimeLogsDisplay.scrollHeight > realtimeLogsDisplay.clientHeight;
                    console.log(`🖱️ 实时原始日志模块 鼠标滚轮事件:`, {
                        deltaY: event.deltaY,
                        deltaX: event.deltaX,
                        target: event.target.tagName,
                        scrollTop: realtimeLogsDisplay.scrollTop,
                        scrollHeight: realtimeLogsDisplay.scrollHeight,
                        clientHeight: realtimeLogsDisplay.clientHeight,
                        canScroll: canScroll
                    });

                    // 手动处理滚动，确保滚动事件被触发
                    if (canScroll) {
                        const currentScrollTop = realtimeLogsDisplay.scrollTop;
                        const scrollAmount = event.deltaY * 0.5; // 调整滚动速度
                        const newScrollTop = Math.max(0, Math.min(
                            realtimeLogsDisplay.scrollHeight - realtimeLogsDisplay.clientHeight,
                            currentScrollTop + scrollAmount
                        ));

                        console.log(`🔄 实时日志模块 手动滚动: ${currentScrollTop} -> ${newScrollTop}`);
                        realtimeLogsDisplay.scrollTop = newScrollTop;

                        // 手动触发滚动事件
                        const scrollEvent = new Event('scroll', { bubbles: true });
                        realtimeLogsDisplay.dispatchEvent(scrollEvent);
                    }

                    // 阻止默认滚动和事件冒泡
                    event.preventDefault();
                    event.stopPropagation();
                });

                // 阻止触摸滚动事件冒泡（移动设备支持）
                realtimeLogsDisplay.addEventListener('touchmove', function(event) {
                    console.log(`👆 实时原始日志模块 触摸滚动事件`);
                    event.stopPropagation();
                });
            }

            // 键盘事件 - ESC键关闭展开的JSON
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && activeLogId) {
                    hideJson(activeLogId);
                }
            });
        });

        // ===== 新的聚合数据处理函数 =====

        // 更新系统状态（从聚合数据）
        function updateSystemStatusFromAggregatedData(data) {
            const uptimeEl = document.getElementById('uptime');
            const healthScoreEl = document.getElementById('health-score');

            if (uptimeEl) {
                const hours = Math.floor(data.uptime_seconds / 3600);
                const minutes = Math.floor((data.uptime_seconds % 3600) / 60);
                const seconds = data.uptime_seconds % 60;
                uptimeEl.textContent = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }

            if (healthScoreEl) {
                healthScoreEl.textContent = `${data.health_score}%`;
            }
        }

        // 更新模块日志（从聚合数据）
        function updateModuleLogsFromAggregatedData(moduleLogs) {
            console.log('updateModuleLogsFromAggregatedData 被调用，模块数量:', Object.keys(moduleLogs).length);

            // 更新模块名称列表
            updateModuleNamesList(Object.keys(moduleLogs));

            for (const [moduleName, moduleData] of Object.entries(moduleLogs)) {
                console.log('处理模块:', moduleName, '数据:', moduleData);

                // 确保模块容器存在
                ensureModuleContainer(moduleName);

                // 初始化模块历史数据状态
                if (!(moduleName in moduleHistoryPages)) {
                    moduleHistoryPages[moduleName] = 0;
                    moduleLoadingHistory[moduleName] = false;
                    moduleHasMoreHistory[moduleName] = moduleData.has_more_history !== false; // 默认假设有更多数据
                }

                // 更新模块统计
                updateModuleStatsFromAggregatedData(moduleName, moduleData);

                // 智能数据选择：优先使用数据量更多的源
                const displayedCount = moduleData.displayed_logs ? moduleData.displayed_logs.length : 0;
                const recentCount = moduleData.recent_logs ? moduleData.recent_logs.length : 0;

                console.log(`📊 模块 [${moduleName}] 数据统计: displayed_logs=${displayedCount}, recent_logs=${recentCount}`);

                if (displayedCount >= 20 || (displayedCount > 0 && recentCount === 0)) {
                    // 如果聚合日志足够多，或者只有聚合日志，使用聚合日志
                    console.log(`📦 渲染模块 [${moduleName}] 的 ${displayedCount} 条聚合日志`);
                    renderAggregatedDisplayLogs(moduleName, moduleData.displayed_logs);
                } else if (recentCount > 0) {
                    // 如果原始日志更多，使用原始日志（转换为显示格式）
                    console.log(`📦 渲染模块 [${moduleName}] 的 ${recentCount} 条原始日志（转换为滚动格式）`);
                    renderRecentLogsWithScrollSupport(moduleName, moduleData.recent_logs);
                } else {
                    console.log(`⚠️ 模块 [${moduleName}] 没有日志数据`);
                    const containerId = getModuleContainerId(moduleName) + '-logs';
                    const container = document.getElementById(containerId);
                    if (container) {
                        container.innerHTML = '<div class="log-entry">等待日志数据...</div>';
                    }
                }
            }
        }

        // 更新模块统计（从聚合数据）
        function updateModuleStatsFromAggregatedData(moduleName, moduleData) {
            const containerId = getModuleContainerId(moduleName);

            const totalEl = document.getElementById(containerId + '-total');
            const errorsEl = document.getElementById(containerId + '-errors');
            const lastUpdateEl = document.getElementById(containerId + '-last-update');

            const currentLogCount = moduleData.total_logs || 0;
            const previousLogCount = moduleLogCounts[moduleName] || 0;

            if (totalEl) totalEl.textContent = currentLogCount;
            if (errorsEl) errorsEl.textContent = moduleData.error_count || 0;

            if (lastUpdateEl) {
                // 只有当日志数量增加时才更新时间
                if (currentLogCount > previousLogCount) {
                    const currentTime = getCurrentTimeString();
                    moduleLastUpdateTimes[moduleName] = currentTime;
                    lastUpdateEl.textContent = currentTime;
                    console.log(`模块 ${moduleName} 有新日志: ${previousLogCount} -> ${currentLogCount}, 更新时间: ${currentTime}`);
                } else {
                    // 日志数量没有变化，显示之前记录的时间
                    lastUpdateEl.textContent = moduleLastUpdateTimes[moduleName] || '--:--:--';
                }
            }

            // 更新记录的日志数量
            moduleLogCounts[moduleName] = currentLogCount;
        }

        // 渲染聚合的显示日志
        function renderAggregatedDisplayLogs(moduleName, displayedLogs) {
            const containerId = getModuleContainerId(moduleName);
            const container = document.getElementById(containerId + '-logs');

            if (!container) return;

            // 检查模块是否有焦点
            const hasFocus = moduleFocusStates[moduleName] || false;
            const shouldAutoScroll = moduleAutoScrollStates[moduleName] !== false; // 默认为true

            console.log(`📦 渲染模块 [${moduleName}] 聚合日志 - 焦点状态: ${hasFocus}, 自动滚动: ${shouldAutoScroll}`);

            // 如果模块有焦点，保存当前滚动位置
            let savedScrollTop = 0;
            let savedScrollHeight = 0;
            if (hasFocus) {
                savedScrollTop = container.scrollTop;
                savedScrollHeight = container.scrollHeight;
                console.log(`💾 模块 [${moduleName}] 有焦点，保存滚动位置: ${savedScrollTop}/${savedScrollHeight}`);
            }

            // 清空容器
            container.innerHTML = '';

            if (!displayedLogs || displayedLogs.length === 0) {
                container.innerHTML = '<div class="log-entry">等待日志数据...</div>';
                return;
            }

            // 存储完整数据到容器的数据属性中，供滚动加载使用
            container.setAttribute('data-all-logs', JSON.stringify(displayedLogs));
            container.setAttribute('data-current-display-count', '20');
            console.log(`📊 模块 [${moduleName}] 存储了 ${displayedLogs.length} 条完整数据，当前显示 20 条`);

            // 只渲染前20条到DOM（UI层面的限制）
            const logsToRender = displayedLogs.slice(0, 20);
            logsToRender.forEach((logEntry, index) => {
                const logElement = createAggregatedLogElement(logEntry, containerId, index);
                container.appendChild(logElement);
            });

            // 如果有更多数据，添加"加载更多"提示
            if (displayedLogs.length > 20) {
                const loadMoreIndicator = document.createElement('div');
                loadMoreIndicator.className = 'load-more-indicator';
                loadMoreIndicator.style.cssText = `
                    padding: 10px;
                    text-align: center;
                    color: #888;
                    font-size: 12px;
                    border-top: 1px solid #333;
                    cursor: pointer;
                `;
                loadMoreIndicator.textContent = `还有 ${displayedLogs.length - 20} 条日志，滚动到顶部加载更多`;
                container.appendChild(loadMoreIndicator);
            }

            // 根据焦点状态决定是否自动滚动
            setTimeout(() => {
                if (hasFocus && !shouldAutoScroll) {
                    // 有焦点时，尝试恢复之前的滚动位置
                    const newScrollHeight = container.scrollHeight;
                    const maxScrollTop = Math.max(0, newScrollHeight - container.clientHeight);

                    // 如果之前在顶部附近（前10%），保持在顶部
                    if (savedScrollTop <= savedScrollHeight * 0.1) {
                        container.scrollTop = 0;
                        console.log(`🔄 模块 [${moduleName}] 保持在顶部位置`);
                    } else {
                        // 否则尝试保持相对位置
                        const relativePosition = savedScrollHeight > 0 ? savedScrollTop / savedScrollHeight : 0;
                        const newScrollTop = Math.min(maxScrollTop, relativePosition * newScrollHeight);
                        container.scrollTop = newScrollTop;
                        console.log(`🔄 模块 [${moduleName}] 恢复相对滚动位置: ${savedScrollTop}/${savedScrollHeight} -> ${newScrollTop}/${newScrollHeight} (相对位置: ${(relativePosition * 100).toFixed(1)}%)`);
                    }
                } else {
                    // 无焦点时，强制滚动到最新位置（顶部）
                    container.scrollTop = 0;
                    console.log(`📜 模块 [${moduleName}] 自动滚动到最新位置（顶部）`);
                }
            }, 50); // 增加延迟确保DOM完全渲染
        }

        // 创建聚合日志元素
        function createAggregatedLogElement(logEntry, containerId, index) {
            const logWrapper = document.createElement('div');
            const logId = `${containerId}-log-${Date.now()}-${index}`;

            // 构建显示消息
            const displayMessage = logEntry.is_aggregated && logEntry.count > 1
                ? `${logEntry.message} (×${logEntry.count})`
                : logEntry.message;

            // 构建JSON内容
            const jsonContent = logEntry.is_aggregated
                ? {
                    message: logEntry.message,
                    level: logEntry.level,
                    count: logEntry.count,
                    timestamp: logEntry.timestamp,
                    variations: logEntry.variations || [],
                    all_logs: logEntry.all_logs || []
                  }
                : logEntry.all_logs[0] || logEntry;

            logWrapper.innerHTML = `
                <!-- JSON详情 (默认隐藏) -->
                <div id="json-${logId}" class="raw-json">
                    <div class="json-container">
                        <div class="json-header">
                            <span>📄 ${logEntry.is_aggregated ? `聚合日志详情 (${logEntry.count}条)` : '原始JSON'}</span>
                            <span class="json-close" onclick="hideJson('${logId}')">✕</span>
                        </div>
                        <div class="json-content">${JSON.stringify(jsonContent, null, 2)}</div>
                    </div>
                </div>

                <!-- 日志条目 -->
                <div class="log-entry log-level-${logEntry.level} ${logEntry.is_aggregated ? 'aggregated-log' : ''}"
                     onclick="toggleJson('${logId}')" data-log-id="${logId}"
                     title="${logEntry.is_aggregated ? `聚合日志: ${logEntry.variations?.length || 1}种变体` : logEntry.message}">
                    <div class="log-message">${escapeHtml(displayMessage)}</div>
                </div>
            `;

            return logWrapper;
        }

        // 将原始日志渲染为支持滚动的显示格式
        function renderRecentLogsWithScrollSupport(moduleName, recentLogs) {
            const containerId = getModuleContainerId(moduleName);
            const container = document.getElementById(containerId + '-logs');

            if (!container) {
                console.error('找不到模块容器:', containerId + '-logs');
                return;
            }

            // 检查模块是否有焦点
            const hasFocus = moduleFocusStates[moduleName] || false;
            const shouldAutoScroll = moduleAutoScrollStates[moduleName] !== false; // 默认为true

            console.log(`📦 渲染模块 [${moduleName}] 原始日志 - 焦点状态: ${hasFocus}, 自动滚动: ${shouldAutoScroll}`);

            // 如果模块有焦点，保存当前滚动位置
            let savedScrollTop = 0;
            let savedScrollHeight = 0;
            if (hasFocus) {
                savedScrollTop = container.scrollTop;
                savedScrollHeight = container.scrollHeight;
                console.log(`💾 模块 [${moduleName}] 有焦点，保存滚动位置: ${savedScrollTop}/${savedScrollHeight}`);
            }

            // 清空容器
            container.innerHTML = '';

            if (!recentLogs || recentLogs.length === 0) {
                container.innerHTML = '<div class="log-entry">等待日志数据...</div>';
                return;
            }

            // 将原始日志转换为DisplayLogEntry格式以支持滚动
            const displayLogs = recentLogs.map(logEntry => ({
                message: logEntry.message,
                level: logEntry.level,
                timestamp: logEntry.timestamp,
                count: 1,
                is_aggregated: false,
                variations: [logEntry.message],
                all_logs: [logEntry]
            }));

            // 存储完整数据到容器的数据属性中，供滚动加载使用
            container.setAttribute('data-all-logs', JSON.stringify(displayLogs));
            container.setAttribute('data-current-display-count', '20');
            console.log(`📊 模块 [${moduleName}] 存储了 ${displayLogs.length} 条完整数据（从原始日志转换），当前显示 20 条`);

            // 只渲染前20条到DOM（UI层面的限制）
            const logsToRender = displayLogs.slice(0, 20);
            logsToRender.forEach((logEntry, index) => {
                const logElement = createAggregatedLogElement(logEntry, containerId, index);
                container.appendChild(logElement);
            });

            // 如果有更多数据，添加"加载更多"提示
            if (displayLogs.length > 20) {
                const loadMoreIndicator = document.createElement('div');
                loadMoreIndicator.className = 'load-more-indicator';
                loadMoreIndicator.style.cssText = `
                    padding: 10px;
                    text-align: center;
                    color: #888;
                    font-size: 12px;
                    border-top: 1px solid #333;
                    cursor: pointer;
                `;
                loadMoreIndicator.textContent = `还有 ${displayLogs.length - 20} 条日志，滚动到顶部加载更多`;
                container.appendChild(loadMoreIndicator);
            }

            // 根据焦点状态决定是否自动滚动
            setTimeout(() => {
                if (hasFocus && !shouldAutoScroll) {
                    // 有焦点时，尝试恢复之前的滚动位置
                    const newScrollHeight = container.scrollHeight;
                    const maxScrollTop = Math.max(0, newScrollHeight - container.clientHeight);

                    // 如果之前在顶部附近（前10%），保持在顶部
                    if (savedScrollTop <= savedScrollHeight * 0.1) {
                        container.scrollTop = 0;
                        console.log(`🔄 模块 [${moduleName}] 保持在顶部位置`);
                    } else {
                        // 否则尝试保持相对位置
                        const relativePosition = savedScrollHeight > 0 ? savedScrollTop / savedScrollHeight : 0;
                        const newScrollTop = Math.min(maxScrollTop, relativePosition * newScrollHeight);
                        container.scrollTop = newScrollTop;
                        console.log(`🔄 模块 [${moduleName}] 恢复相对滚动位置: ${savedScrollTop}/${savedScrollHeight} -> ${newScrollTop}/${newScrollHeight} (相对位置: ${(relativePosition * 100).toFixed(1)}%)`);
                    }
                } else {
                    // 无焦点时，强制滚动到最新位置（顶部）
                    container.scrollTop = 0;
                    console.log(`📜 模块 [${moduleName}] 自动滚动到最新位置（顶部）`);
                }
            }, 50); // 增加延迟确保DOM完全渲染
        }

        // 将原始日志渲染为显示格式（兼容recent_logs，旧版本）
        function renderRecentLogsAsDisplay(moduleName, recentLogs) {
            const containerId = getModuleContainerId(moduleName);
            const container = document.getElementById(containerId + '-logs');

            if (!container) {
                console.error('找不到模块容器:', containerId + '-logs');
                return;
            }

            // 清空容器
            container.innerHTML = '';

            if (!recentLogs || recentLogs.length === 0) {
                container.innerHTML = '<div class="log-entry">等待日志数据...</div>';
                return;
            }

            // 显示最新的20条日志
            const logsToShow = recentLogs.slice(0, 20);
            logsToShow.forEach((logEntry, index) => {
                const logElement = createRecentLogElement(logEntry, containerId, index);
                container.appendChild(logElement);
            });
        }

        // 创建原始日志元素
        function createRecentLogElement(logEntry, containerId, index) {
            const logWrapper = document.createElement('div');
            const logId = `${containerId}-recent-${Date.now()}-${index}`;

            // 构建完整的JSON对象用于详情显示
            const fullLogJson = {
                timestamp: logEntry.timestamp,
                level: logEntry.level,
                target: logEntry.target,
                message: logEntry.message,
                module_path: logEntry.module_path,
                file: logEntry.file,
                line: logEntry.line,
                fields: logEntry.fields,
                span: logEntry.span
            };

            logWrapper.innerHTML = `
                <!-- 原始JSON (默认隐藏) -->
                <div id="json-${logId}" class="raw-json">
                    <div class="json-container">
                        <div class="json-header">
                            <span>📄 原始日志详情</span>
                            <span class="json-close" onclick="hideJson('${logId}')">✕</span>
                        </div>
                        <div class="json-content">${JSON.stringify(fullLogJson, null, 2)}</div>
                    </div>
                </div>

                <!-- 日志条目 -->
                <div class="log-entry log-level-${logEntry.level}"
                     onclick="toggleJson('${logId}')" data-log-id="${logId}"
                     title="${logEntry.message}">
                    <div class="log-message">${escapeHtml(logEntry.message)}</div>
                </div>
            `;

            return logWrapper;
        }

        // 更新实时日志（从聚合数据）
        function updateRealtimeLogsFromAggregatedData(realtimeData) {
            if (!realtimeData || !realtimeData.recent_logs) return;

            const container = document.getElementById('realtime-logs-display');
            if (!container) return;

            // 检查实时日志模块是否有焦点
            const moduleName = 'RealtimeLogs';
            const hasFocus = moduleFocusStates[moduleName] || false;
            const shouldAutoScroll = moduleAutoScrollStates[moduleName] !== false; // 默认为true

            console.log(`📦 更新实时日志模块 - 焦点状态: ${hasFocus}, 自动滚动: ${shouldAutoScroll}`);

            // 如果模块有焦点，保存当前滚动位置
            let savedScrollTop = 0;
            let savedScrollHeight = 0;
            if (hasFocus) {
                savedScrollTop = container.scrollTop;
                savedScrollHeight = container.scrollHeight;
                console.log(`💾 实时日志模块有焦点，保存滚动位置: ${savedScrollTop}/${savedScrollHeight}`);
            }

            // 更新状态信息
            const statusEl = document.getElementById('realtime-logs-status');
            const logCountEl = document.getElementById('realtime-log-count');
            const lastLogTimeEl = document.getElementById('last-log-time');
            const logFrequencyEl = document.getElementById('log-frequency');

            if (statusEl) {
                if (realtimeData.recent_logs.length > 0) {
                    statusEl.textContent = '实时接收';
                    statusEl.className = 'module-status status-running';
                } else {
                    statusEl.textContent = '等待日志';
                    statusEl.className = 'module-status status-waiting';
                }
            }

            if (logCountEl) logCountEl.textContent = realtimeData.total_count || realtimeData.recent_logs.length;
            if (lastLogTimeEl) lastLogTimeEl.textContent = realtimeData.last_update_time || getCurrentTimeString();
            if (logFrequencyEl) logFrequencyEl.textContent = `${realtimeData.logs_per_second || 0} 条/秒`;

            // 清空容器
            container.innerHTML = '';

            if (realtimeData.recent_logs.length === 0) {
                container.innerHTML = '<div class="log-entry">暂无实时日志</div>';
                return;
            }

            // 只显示最新的20条实时日志
            const logsToShow = realtimeData.recent_logs.slice(0, 20);

            logsToShow.forEach(logLine => {
                const logEl = document.createElement('div');
                logEl.className = 'log-entry';
                logEl.style.fontSize = '12px';
                logEl.style.lineHeight = '1.3';
                logEl.style.marginBottom = '2px';
                logEl.style.wordBreak = 'break-all';

                // 简单的日志着色
                if (logLine.includes('ERROR')) {
                    logEl.style.color = '#ff0000';
                } else if (logLine.includes('WARN')) {
                    logEl.style.color = '#ffff00';
                } else if (logLine.includes('INFO')) {
                    logEl.style.color = '#00ff00';
                } else {
                    logEl.style.color = '#cccccc';
                }

                logEl.textContent = logLine;
                container.appendChild(logEl);
            });

            // 根据焦点状态决定是否自动滚动
            setTimeout(() => {
                if (hasFocus && !shouldAutoScroll) {
                    // 有焦点时，尝试恢复之前的滚动位置
                    const newScrollHeight = container.scrollHeight;
                    const maxScrollTop = Math.max(0, newScrollHeight - container.clientHeight);

                    // 如果之前在顶部附近（前10%），保持在顶部
                    if (savedScrollTop <= savedScrollHeight * 0.1) {
                        container.scrollTop = 0;
                        console.log(`🔄 实时日志模块保持在顶部位置`);
                    } else {
                        // 否则尝试保持相对位置
                        const relativePosition = savedScrollHeight > 0 ? savedScrollTop / savedScrollHeight : 0;
                        const newScrollTop = Math.min(maxScrollTop, relativePosition * newScrollHeight);
                        container.scrollTop = newScrollTop;
                        console.log(`🔄 实时日志模块恢复相对滚动位置: ${savedScrollTop}/${savedScrollHeight} -> ${newScrollTop}/${newScrollHeight} (相对位置: ${(relativePosition * 100).toFixed(1)}%)`);
                    }
                } else {
                    // 无焦点时，强制滚动到最新位置（顶部）
                    container.scrollTop = 0;
                    console.log(`📜 实时日志模块自动滚动到最新位置（顶部）`);
                }
            }, 50); // 增加延迟确保DOM完全渲染
        }

        // 更新原始日志快照（从聚合数据）
        function updateRawLogSnapshotFromAggregatedData(snapshot) {
            if (!snapshot) {
                return;
            }

            // 检查原始日志快照模块是否有焦点
            const moduleName = 'RawLogSnapshot';
            const hasFocus = moduleFocusStates[moduleName] || false;
            const shouldAutoScroll = moduleAutoScrollStates[moduleName] !== false; // 默认为true

            console.log(`📦 更新原始日志快照模块 - 焦点状态: ${hasFocus}, 自动滚动: ${shouldAutoScroll}`);

            // 更新状态信息
            const statusEl = document.getElementById('raw-logs-status');
            if (statusEl) {
                statusEl.textContent = '折叠已更新';
                statusEl.className = 'module-status status-running';
            }

            // 更新统计信息
            const timestampEl = document.getElementById('snapshot-timestamp');
            const totalCountEl = document.getElementById('total-log-count');
            const displayedCountEl = document.getElementById('displayed-log-count');

            if (timestampEl) timestampEl.textContent = getCurrentTimeString();
            if (totalCountEl) totalCountEl.textContent = snapshot.total_count;
            if (displayedCountEl) displayedCountEl.textContent = snapshot.displayed_logs?.length || 0;

            // 直接渲染后端提供的聚合日志
            const container = document.getElementById('raw-logs-display');
            if (!container) return;

            // 如果模块有焦点，保存当前滚动位置
            let savedScrollTop = 0;
            let savedScrollHeight = 0;
            if (hasFocus) {
                savedScrollTop = container.scrollTop;
                savedScrollHeight = container.scrollHeight;
                console.log(`💾 原始日志快照模块有焦点，保存滚动位置: ${savedScrollTop}/${savedScrollHeight}`);
            }

            // 保存固定的UI元素（滚动提示和诊断按钮）
            const scrollHint = container.querySelector('.scroll-hint');
            const diagnoseButton = container.querySelector('button[onclick*="diagnoseContainer"]');

            // 清空容器但保留固定UI元素
            container.innerHTML = '';

            // 重新添加固定UI元素
            if (scrollHint) container.appendChild(scrollHint);
            if (diagnoseButton) container.appendChild(diagnoseButton);

            if (!snapshot.displayed_logs || snapshot.displayed_logs.length === 0) {
                const noDataEntry = document.createElement('div');
                noDataEntry.className = 'log-entry';
                noDataEntry.textContent = '暂无日志数据';
                container.appendChild(noDataEntry);
                return;
            }

            // 存储完整数据到容器的数据属性中，供滚动加载使用
            container.setAttribute('data-all-logs', JSON.stringify(snapshot.displayed_logs));
            container.setAttribute('data-current-display-count', '20');
            console.log(`📊 原始日志快照模块存储了 ${snapshot.displayed_logs.length} 条完整数据，当前显示 20 条`);

            // 只渲染前20条到DOM（UI层面的限制）
            const logsToRender = snapshot.displayed_logs.slice(0, 20);
            logsToRender.forEach((logEntry, index) => {
                const logElement = createAggregatedLogElement(logEntry, 'raw-logs', index);
                container.appendChild(logElement);
            });

            // 如果有更多数据，添加"加载更多"提示
            if (snapshot.displayed_logs.length > 20) {
                const loadMoreIndicator = document.createElement('div');
                loadMoreIndicator.className = 'load-more-indicator';
                loadMoreIndicator.style.cssText = `
                    padding: 10px;
                    text-align: center;
                    color: #888;
                    font-size: 12px;
                    border-top: 1px solid #333;
                    cursor: pointer;
                `;
                loadMoreIndicator.textContent = `还有 ${snapshot.displayed_logs.length - 20} 条日志，滚动到顶部加载更多`;
                container.appendChild(loadMoreIndicator);
            }

            // 根据焦点状态决定是否自动滚动
            setTimeout(() => {
                if (hasFocus && !shouldAutoScroll) {
                    // 有焦点时，尝试恢复之前的滚动位置
                    const newScrollHeight = container.scrollHeight;
                    const maxScrollTop = Math.max(0, newScrollHeight - container.clientHeight);

                    // 如果之前在顶部附近（前10%），保持在顶部
                    if (savedScrollTop <= savedScrollHeight * 0.1) {
                        container.scrollTop = 0;
                        console.log(`🔄 原始日志快照模块保持在顶部位置`);
                    } else {
                        // 否则尝试保持相对位置
                        const relativePosition = savedScrollHeight > 0 ? savedScrollTop / savedScrollHeight : 0;
                        const newScrollTop = Math.min(maxScrollTop, relativePosition * newScrollHeight);
                        container.scrollTop = newScrollTop;
                        console.log(`🔄 原始日志快照模块恢复相对滚动位置: ${savedScrollTop}/${savedScrollHeight} -> ${newScrollTop}/${newScrollHeight} (相对位置: ${(relativePosition * 100).toFixed(1)}%)`);
                    }
                } else {
                    // 无焦点时，强制滚动到最新位置（顶部）
                    container.scrollTop = 0;
                    console.log(`📜 原始日志快照模块自动滚动到最新位置（顶部）`);
                }
            }, 50); // 增加延迟确保DOM完全渲染
        }



        // 简化的实时日志条目添加（仅用于实时显示）
        function addLogEntryToRealtimeDisplay(logEntry) {
            const container = document.getElementById('realtime-logs-display');
            if (!container) return;

            // 检查实时日志模块是否有焦点
            const moduleName = 'RealtimeLogs';
            const hasFocus = moduleFocusStates[moduleName] || false;
            const shouldAutoScroll = moduleAutoScrollStates[moduleName] !== false; // 默认为true

            // 如果模块有焦点，保存当前滚动位置
            let savedScrollTop = 0;
            let savedScrollHeight = 0;
            if (hasFocus) {
                savedScrollTop = container.scrollTop;
                savedScrollHeight = container.scrollHeight;
            }

            const logEl = document.createElement('div');
            logEl.className = 'log-entry';
            logEl.style.fontSize = '12px';
            logEl.style.lineHeight = '1.3';
            logEl.style.marginBottom = '2px';
            logEl.style.wordBreak = 'break-all';

            // 根据日志级别着色
            if (logEntry.level === 'ERROR') {
                logEl.style.color = '#ff0000';
            } else if (logEntry.level === 'WARN') {
                logEl.style.color = '#ffff00';
            } else if (logEntry.level === 'INFO') {
                logEl.style.color = '#00ff00';
            } else {
                logEl.style.color = '#cccccc';
            }

            // 格式化日志内容（使用当前时间）
            const timestamp = getCurrentTimeString();
            logEl.textContent = `[${timestamp}] ${logEntry.level} ${logEntry.target}: ${logEntry.message}`;

            // 添加到容器顶部（最新的在上面）
            container.insertBefore(logEl, container.firstChild);

            // 限制实时日志显示数量为20条
            const children = Array.from(container.children);
            if (children.length > 20) {
                for (let i = 20; i < children.length; i++) {
                    container.removeChild(children[i]);
                }
            }

            // 根据焦点状态决定是否自动滚动
            setTimeout(() => {
                if (hasFocus && !shouldAutoScroll) {
                    // 有焦点时，尝试恢复之前的滚动位置
                    const newScrollHeight = container.scrollHeight;
                    const maxScrollTop = Math.max(0, newScrollHeight - container.clientHeight);

                    // 如果之前在顶部附近（前10%），保持在顶部
                    if (savedScrollTop <= savedScrollHeight * 0.1) {
                        container.scrollTop = 0;
                        console.log(`🔄 实时日志模块单条添加后保持在顶部位置`);
                    } else {
                        // 否则尝试保持相对位置
                        const relativePosition = savedScrollHeight > 0 ? savedScrollTop / savedScrollHeight : 0;
                        const newScrollTop = Math.min(maxScrollTop, relativePosition * newScrollHeight);
                        container.scrollTop = newScrollTop;
                        console.log(`🔄 实时日志模块单条添加后恢复相对滚动位置: ${savedScrollTop}/${savedScrollHeight} -> ${newScrollTop}/${newScrollHeight}`);
                    }
                } else {
                    // 无焦点时，强制滚动到最新位置（顶部）
                    container.scrollTop = 0;
                    console.log(`📜 实时日志模块单条添加后自动滚动到最新位置（顶部）`);
                }
            }, 50); // 增加延迟确保DOM完全渲染
        }
    </script>
</body>
</html>
