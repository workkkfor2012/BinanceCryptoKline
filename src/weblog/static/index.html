<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebLog - 前端聚合版本</title>

    <!-- Xterm.js CSS -->
    <link rel="stylesheet" href="https://unpkg.com/@xterm/xterm@5.5.0/css/xterm.css" />

    <!-- Xterm.js JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/@xterm/xterm@5.5.0/lib/xterm.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@xterm/addon-fit@0.10.0/lib/addon-fit.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@xterm/addon-web-links@0.11.0/lib/addon-web-links.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            background-color: #1a1a1a;
            color: #00ff00;
            padding: 10px;
            font-size: 16px;
            line-height: 1.5;
        }

        .header {
            padding: 5px 10px;
            border-bottom: 2px solid #333;
            margin-bottom: 10px;
        }

        .header-top-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 15px;
            flex-wrap: wrap;
        }

        .header h1 {
            color: #00ffff;
            font-size: 18px;
            margin: 0;
            flex-shrink: 0;
        }

        .header-buttons {
            display: flex;
            gap: 10px;
            flex-shrink: 0;
        }

        .main-content {
            display: flex;
            gap: 15px;
            height: calc(100vh - 120px);
        }

        .static-modules-area {
            flex: 0 0 820px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            height: 100%;
            border: 2px solid #444;
            border-radius: 8px;
            padding: 10px;
            background-color: #0f0f0f;
        }

        .static-modules-title {
            color: #00ffff;
            font-size: 14px;
            font-weight: bold;
            text-align: center;
            padding: 5px 0;
            border-bottom: 1px solid #444;
            margin-bottom: 5px;
            flex-shrink: 0;
        }

        .static-modules-content {
            flex: 1;
            display: flex;
            gap: 15px;
            min-height: 0;
        }

        .dynamic-modules-area {
            flex: 1;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 15px;
            overflow-y: auto;
            height: 100%;
        }

        .module {
            border: 1px solid #333;
            border-radius: 5px;
            background-color: #0a0a0a;
            display: flex;
            flex-direction: column;
        }

        .static-module {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .static-modules-area .module-header {
            background-color: #1a1a2e;
            border-bottom: 2px solid #16213e;
            flex-shrink: 0;
        }

        .static-modules-area .module-title {
            color: #0ff;
            font-weight: bold;
        }

        .static-modules-area .module-stats {
            flex-shrink: 0;
        }

        .static-modules-area .module-terminal {
            flex: 1;
        }

        .module-header {
            padding: 8px 12px;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .module-title {
            font-weight: bold;
            font-size: 16px;
            color: #00ffff;
        }

        .module-status {
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }

        .status-running { background-color: #006600; color: #00ff00; }
        .status-waiting { background-color: #666600; color: #ffff00; }
        .status-error { background-color: #660000; color: #ff0000; }
        .status-disconnected { background-color: #663300; color: #ff9900; }

        .module-stats {
            padding: 10px 15px;
            border-bottom: 1px solid #333;
            font-size: 13px;
            color: #cccccc;
        }

        .stat-line {
            display: flex;
            justify-content: space-between;
            margin-bottom: 2px;
        }

        .module-terminal {
            flex: 1;
            padding: 5px;
            background-color: #000000;
            overflow: hidden;
            min-height: 100px;
        }

        .xterm {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace !important;
            font-size: 13px !important;
        }

        .xterm .xterm-viewport {
            background-color: #000000 !important;
        }

        .xterm .xterm-screen {
            background-color: #000000 !important;
        }

        /* 让xterm.js终端实例和它的视口100%填充其父容器(.module-terminal) */
        .module-terminal .xterm,
        .module-terminal .xterm-viewport,
        .module-terminal .xterm-screen {
            height: 100% !important;
        }

        .connection-status {
            position: fixed;
            top: 15px;
            right: 15px;
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 14px;
            font-weight: bold;
        }

        .connected { background-color: #006600; color: #00ff00; }
        .disconnected { background-color: #660000; color: #ff0000; }

        .header-copy-button {
            background-color: #ff6600;
            color: #ffffff;
            border: 2px solid #ff8833;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-family: 'Consolas', monospace;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 6px rgba(255, 102, 0, 0.4);
        }

        .header-copy-button:hover {
            background-color: #ff8833;
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(255, 102, 0, 0.6);
        }

        .header-copy-button.copied {
            background-color: #44ff44;
            color: #000000;
            border-color: #66ff66;
        }

        .header-toggle-button {
            background-color: #0066ff;
            color: #ffffff;
            border: 2px solid #3388ff;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-family: 'Consolas', monospace;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 6px rgba(0, 102, 255, 0.4);
        }

        .header-toggle-button:hover {
            background-color: #3388ff;
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0, 102, 255, 0.6);
        }

        .header-toggle-button.active {
            background-color: #44ff44;
            color: #000000;
            border-color: #66ff66;
            box-shadow: 0 2px 6px rgba(68, 255, 68, 0.4);
        }

        .module-names-section {
            flex: 1;
            min-width: 300px;
        }

        .module-names-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            align-items: center;
        }

        .module-name-tag {
            background-color: #1a4a1a;
            color: #00ff00;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
            font-family: 'Consolas', monospace;
            cursor: pointer;
            border: 1px solid #006600;
            transition: all 0.2s ease;
        }

        .module-name-tag:hover {
            background-color: #2a5a2a;
            border-color: #00ff00;
            transform: scale(1.05);
        }

        .module-name-tag.copied {
            background-color: #4a4a1a;
            color: #ffff00;
            border-color: #ffff00;
        }

        .no-modules {
            color: #666;
            font-style: italic;
            font-size: 12px;
        }

        html, body {
            height: 100%;
            overflow-x: hidden;
        }

        .dynamic-modules-area .module {
            min-height: 400px;
        }

        @media (max-width: 1200px) {
            .static-modules-area {
                flex: 0 0 600px;
            }

            .static-modules-area .module-terminal {
                min-height: 200px;
            }
        }
    </style>
</head>
<body>
    <div class="connection-status" id="connection-status">连接中...</div>

    <div class="header">
        <div class="header-top-row">
            <h1>WebLog - 前端聚合版本</h1>

            <div class="module-names-section">
                <div class="module-names-list" id="module-names-list">
                    <span class="no-modules">暂无模块数据</span>
                </div>
            </div>

            <div class="header-buttons">
                <button class="header-copy-button" id="header-copy-modules" title="复制所有模块名称">🔥 复制全部模块</button>
                <button class="header-toggle-button" id="toggle-realtime-logs" title="显示/隐藏实时原始日志">📊 显示实时原始日志</button>
            </div>
        </div>
    </div>

    <div class="main-content">
        <!-- 左侧静态模块区域 -->
        <div class="static-modules-area">
            <div class="static-modules-title">📊 静态模块区域 - 日志监控</div>
            <div class="static-modules-content">
                <!-- 实时原始日志模块 (默认隐藏) -->
                <div class="module static-module" id="realtime-logs-module" style="display: none;">
                    <div class="module-header">
                        <div class="module-title">实时原始日志 (RealtimeLogs)</div>
                        <div class="module-status status-waiting" id="realtime-logs-status">等待日志</div>
                    </div>
                    <div class="module-stats">
                        <div class="stat-line">
                            <span>实时日志数:</span>
                            <span id="realtime-log-count">0</span>
                        </div>
                        <div class="stat-line">
                            <span>最后更新:</span>
                            <span id="last-log-time">--:--:--</span>
                        </div>
                        <div class="stat-line">
                            <span>日志频率:</span>
                            <span id="log-frequency">-- 条/秒</span>
                        </div>
                    </div>
                    <div class="module-terminal" id="realtime-logs-terminal"></div>
                </div>

                <!-- 原始日志高频折叠模块 -->
                <div class="module static-module" id="raw-logs-module">
                    <div class="module-header">
                        <div class="module-title">原始日志高频折叠 (HighFreqCollapsed)</div>
                        <div class="module-status status-waiting" id="raw-logs-status">等待折叠</div>
                    </div>
                    <div class="module-stats">
                        <div class="stat-line">
                            <span>处理时间:</span>
                            <span id="collapse-timestamp">--:--:--</span>
                        </div>
                        <div class="stat-line">
                            <span>原始日志数:</span>
                            <span id="total-log-count">--</span>
                        </div>
                        <div class="stat-line">
                            <span>折叠后条数:</span>
                            <span id="displayed-log-count">--</span>
                        </div>
                    </div>
                    <div class="module-terminal" id="raw-logs-terminal"></div>
                </div>

            </div>
        </div>

        <!-- 右侧动态模块区域 -->
        <div class="dynamic-modules-area" id="dynamic-modules-container">
            <!-- 动态模块将在这里创建 -->
        </div>
    </div>

    <script>
        // 前端聚合版本的WebLog系统
        console.log('🚀 WebLog前端聚合版本启动');

        // 全局状态管理
        class WebLogState {
            constructor() {
                this.allLogs = [];           // 所有原始日志
                this.moduleData = new Map(); // 按模块分类的数据
                this.highFreqAggregator = new HighFreqAggregator(); // 高频聚合器
                this.isHistoryLoaded = false; // 历史数据是否加载完成
                this.logCount = 0;           // 日志计数
                this.lastLogTime = null;     // 最后日志时间
                this.startTime = Date.now(); // 启动时间

                // 节流控制 - 解决页面闪烁问题
                this.isUiUpdateScheduled = false; // 是否已有更新计划
                this.uiUpdateInterval = 200; // 更新间隔，单位毫秒
                this.pendingUpdates = {
                    moduleNames: false,
                    realtimeLogs: false,
                    highFreqCollapsed: false,
                    dynamicModules: new Set() // 需要更新的模块名称
                };
            }

            // 处理新的日志条目
            processLogEntry(logEntry) {
                this.allLogs.push(logEntry);
                this.logCount++;
                this.lastLogTime = new Date();

                // 按模块分类
                const moduleName = logEntry.target;
                if (!this.moduleData.has(moduleName)) {
                    this.moduleData.set(moduleName, {
                        name: moduleName,
                        logs: [],
                        errorCount: 0,
                        warnCount: 0,
                        infoCount: 0,
                        totalLogs: 0
                    });
                }

                const moduleInfo = this.moduleData.get(moduleName);
                moduleInfo.logs.push(logEntry);
                moduleInfo.totalLogs++;

                // 统计日志级别
                switch (logEntry.level.toUpperCase()) {
                    case 'ERROR':
                        moduleInfo.errorCount++;
                        break;
                    case 'WARN':
                        moduleInfo.warnCount++;
                        break;
                    case 'INFO':
                        moduleInfo.infoCount++;
                        break;
                }

                // 保持最近1000条日志
                if (moduleInfo.logs.length > 10000000) {
                    moduleInfo.logs.shift();
                }

                // 高频聚合处理
                this.highFreqAggregator.processLog(logEntry);

                // 立即增量更新 - 无需节流，直接追加到终端
                if (this.isHistoryLoaded && terminalManager) {
                    // 立即追加到对应模块终端
                    terminalManager.appendLogToTerminal(moduleName, logEntry);

                    // 立即更新实时日志（如果显示）
                    terminalManager.appendToRealtimeLogs(logEntry);

                    // 更新模块统计
                    this.updateModuleStatsIncremental(moduleName, moduleInfo);
                }

                // 注意：高频折叠终端的更新已经在 highFreqAggregator.processLog() 中自动处理

                // 只有模块名称需要延迟更新（避免频繁DOM操作）
                this.pendingUpdates.moduleNames = true;
                this.scheduleUIUpdate();
            }

            // 节流调度UI更新 - 防止高频闪烁
            scheduleUIUpdate() {
                if (!this.isUiUpdateScheduled) {
                    this.isUiUpdateScheduled = true;
                    setTimeout(() => {
                        this.performScheduledUpdates();
                        this.isUiUpdateScheduled = false;
                    }, this.uiUpdateInterval);
                }
            }

            // 执行计划中的更新 - 只更新模块名称列表（其他都是实时增量更新）
            performScheduledUpdates() {
                if (this.pendingUpdates.moduleNames) {
                    this.updateModuleNames();
                    this.pendingUpdates.moduleNames = false;
                }
            }

            // 增量更新模块统计信息
            updateModuleStatsIncremental(moduleName, moduleInfo) {
                if (!terminalManager.moduleExists(moduleName)) {
                    terminalManager.createDynamicModule(moduleName, moduleInfo);
                }
                terminalManager.updateModuleStats(moduleName, moduleInfo);
            }

            // 更新界面 - 保留用于历史数据加载时的全量更新
            updateUI() {
                this.updateModuleNames();
                this.updateRealtimeLogs();
                this.updateHighFreqCollapsed();
                this.updateDynamicModules();
            }

            // 更新模块名称列表
            updateModuleNames() {
                const container = document.getElementById('module-names-list');
                if (this.moduleData.size === 0) {
                    container.innerHTML = '<span class="no-modules">暂无模块数据</span>';
                    return;
                }

                const moduleNames = Array.from(this.moduleData.keys()).sort();
                container.innerHTML = moduleNames.map(name =>
                    `<span class="module-name-tag" onclick="copyModuleName('${name}')">${name}</span>`
                ).join('');
            }

            // 更新实时日志显示
            updateRealtimeLogs() {
                const countEl = document.getElementById('realtime-log-count');
                const timeEl = document.getElementById('last-log-time');
                const freqEl = document.getElementById('log-frequency');

                if (countEl) countEl.textContent = this.logCount;
                if (timeEl && this.lastLogTime) {
                    timeEl.textContent = this.lastLogTime.toLocaleTimeString();
                }
                if (freqEl) {
                    const elapsed = (Date.now() - this.startTime) / 1000;
                    const frequency = elapsed > 0 ? (this.logCount / elapsed).toFixed(2) : '0.00';
                    freqEl.textContent = `${frequency} 条/秒`;
                }

                // 更新实时日志终端
                if (terminalManager && this.isHistoryLoaded) {
                    const recentLogs = this.allLogs.slice(-20); // 最近20条
                    terminalManager.updateRealtimeLogs(recentLogs);
                }
            }

            // 更新高频折叠日志 - 仅用于历史数据加载
            updateHighFreqCollapsed() {
                // 获取高频聚合后的日志
                const aggregatedLogs = this.highFreqAggregator.getAggregatedLogs();

                // 更新高频折叠日志终端（仅用于历史数据加载）
                if (terminalManager && this.isHistoryLoaded) {
                    terminalManager.updateHighFreqCollapsed(aggregatedLogs);
                }
            }

            // 更新动态模块 - 全量更新（用于历史数据加载）
            updateDynamicModules() {
                if (terminalManager && this.isHistoryLoaded) {
                    for (const [moduleName, moduleInfo] of this.moduleData) {
                        terminalManager.updateModuleTerminal(moduleName, moduleInfo);
                    }
                }
            }

            // 更新单个动态模块 - 增量更新（用于实时日志）
            updateDynamicModule(moduleName, moduleInfo) {
                if (terminalManager && this.isHistoryLoaded) {
                    terminalManager.updateModuleTerminal(moduleName, moduleInfo);
                }
            }
        }

        // 高频日志聚合器 - 采用 is_high_freq 和 event_type 精确控制
        class HighFreqAggregator {
            constructor() {
                this.aggregatedLogs = []; // 持久化的日志列表，是终端显示的最终数据源
                // 追踪活跃的、可被折叠的日志分组
                // Key: messageKey (由 target:event_type 构成), Value: { index, count, ... }
                this.activeGroups = new Map();
                this.timeWindow = 5000; // 5秒时间窗口
            }

            // 核心处理逻辑 - 已重构为精确分发
            processLog(logEntry) {
                const isHighFreq = logEntry.fields && logEntry.fields.is_high_freq === true;

                // **关键分发逻辑**
                if (isHighFreq && logEntry.fields.event_type) {
                    // **路径1：高频日志处理**
                    // 只有标记为高频且拥有event_type的日志才进入聚合流程
                    this.processHighFrequencyLog(logEntry);
                } else {
                    // **路径2：普通日志处理**
                    // 所有其他日志（非高频或缺少event_type）都直接追加，不参与聚合
                    this.appendAsNormalLog(logEntry);
                }

                // 更新统计数据
                this.updateStats();
            }

            // 处理高频日志（聚合逻辑）
            processHighFrequencyLog(logEntry) {
                const messageKey = this.getMessageKey(logEntry);
                const now = Date.now();

                if (this.activeGroups.has(messageKey)) {
                    const group = this.activeGroups.get(messageKey);

                    // 检查分组是否仍在时间窗口内
                    if (now - group.lastTime < this.timeWindow) {
                        // 聚合：更新现有分组
                        group.count++;
                        group.lastTime = now;
                        group.lastEntry = logEntry;

                        const aggregatedEntry = {
                            ...group.lastEntry,
                            message: `[${group.count}x] ${group.firstEntry.message}`,
                            isAggregated: true,
                            count: group.count,
                        };

                        this.aggregatedLogs[group.index] = aggregatedEntry;
                        terminalManager.updateHighFreqLogInPlace(group.index, aggregatedEntry, this.aggregatedLogs);
                    } else {
                        // 超时：结束旧分组，将此日志作为新分组的开始
                        this.activeGroups.delete(messageKey);
                        this.addNewHighFreqGroup(logEntry, messageKey, now);
                    }
                } else {
                    // 全新：为此 event_type 创建一个新的聚合分组
                    this.addNewHighFreqGroup(logEntry, messageKey, now);
                }
            }

            // 将日志作为普通、非聚合条目直接追加
            appendAsNormalLog(logEntry) {
                // 直接添加到数据源
                this.aggregatedLogs.push(logEntry);
                // 直接通知终端管理器追加显示
                terminalManager.appendHighFreqLog(logEntry, this.aggregatedLogs);
            }

            // 获取高频日志的分组键
            getMessageKey(logEntry) {
                // 此方法现在只被高频日志路径调用，因此可以确信 event_type 存在
                return `${logEntry.target}:${logEntry.fields.event_type}`;
            }

            // 辅助函数：为高频日志创建一个新的聚合分组
            addNewHighFreqGroup(logEntry, messageKey, now) {
                this.aggregatedLogs.push(logEntry);
                const newIndex = this.aggregatedLogs.length - 1;

                // 创建一个新的活跃分组，以便后续的日志可以匹配并折叠
                this.activeGroups.set(messageKey, {
                    index: newIndex,
                    count: 1,
                    lastTime: now,
                    firstEntry: logEntry,
                    lastEntry: logEntry
                });

                // 通知终端管理器追加显示这个新分组的初始日志
                terminalManager.appendHighFreqLog(logEntry, this.aggregatedLogs);
            }

            // 只更新统计部分的UI
            updateStats() {
                const timestampEl = document.getElementById('collapse-timestamp');
                const totalCountEl = document.getElementById('total-log-count');
                const displayedCountEl = document.getElementById('displayed-log-count');

                if (timestampEl) timestampEl.textContent = new Date().toLocaleTimeString();
                if (totalCountEl) totalCountEl.textContent = webLogState.allLogs.length;
                if (displayedCountEl) displayedCountEl.textContent = this.aggregatedLogs.length;
            }

            // 获取聚合后的日志（用于历史加载）
            getAggregatedLogs() {
                return this.aggregatedLogs;
            }

            // 完整重绘终端（仅用于初始化或特殊情况）
            updateHighFreqCollapsed(logs) {
                const terminal = terminalManager.terminals.get('raw-logs');
                if (!terminal) return;

                const displayLogs = logs ? logs.slice(-100) : this.aggregatedLogs.slice(-100);

                terminal.clear();
                const logBuffer = [];
                displayLogs.forEach(log => {
                    const formattedLog = terminalManager.formatLogEntry(log);
                    logBuffer.push(formattedLog);
                    terminal.write(formattedLog + '\r\n');
                });
                terminalManager.logBuffers.set('raw-logs', logBuffer);
                this.updateStats();
            }
        }

        // 全局状态实例
        const webLogState = new WebLogState();

        // 终端管理器
        class TerminalManager {
            constructor() {
                this.terminals = new Map();
                this.fitAddons = new Map();
                this.logBuffers = new Map(); // 日志缓冲区，用于管理每个终端的日志
                this.maxLines = 100000000; // 每个终端最大行数

                this.terminalTheme = {
                    background: '#000000',
                    foreground: '#00ff00',
                    cursor: '#00ff00',
                    cursorAccent: '#000000',
                    selection: 'rgba(255, 255, 255, 0.3)',
                    black: '#000000',
                    red: '#ff0000',
                    green: '#00ff00',
                    yellow: '#ffff00',
                    blue: '#0066ff',
                    magenta: '#ff00ff',
                    cyan: '#00ffff',
                    white: '#ffffff',
                    brightBlack: '#666666',
                    brightRed: '#ff6666',
                    brightGreen: '#66ff66',
                    brightYellow: '#ffff66',
                    brightBlue: '#6666ff',
                    brightMagenta: '#ff66ff',
                    brightCyan: '#66ffff',
                    brightWhite: '#ffffff'
                };
            }

            // 创建终端
            createTerminal(containerId, moduleName) {
                const container = document.getElementById(containerId);
                if (!container) {
                    console.error(`找不到容器: ${containerId}`);
                    return null;
                }

                const terminal = new Terminal({
                    theme: this.terminalTheme,
                    fontFamily: 'Consolas, Monaco, "Courier New", monospace',
                    fontSize: 13,
                    lineHeight: 1.2,
                    cursorBlink: false,
                    scrollback: this.maxLines,
                    convertEol: true,
                    disableStdin: true,
                    allowTransparency: true
                });

                const fitAddon = new FitAddon.FitAddon();
                const webLinksAddon = new WebLinksAddon.WebLinksAddon();

                terminal.loadAddon(fitAddon);
                terminal.loadAddon(webLinksAddon);

                terminal.open(container);
                setTimeout(() => fitAddon.fit(), 0);

                this.terminals.set(moduleName, terminal);
                this.fitAddons.set(moduleName, fitAddon);
                this.logBuffers.set(moduleName, []); // 初始化日志缓冲区

                return terminal;
            }

            // 追加一行到高频折叠终端，无闪烁
            appendHighFreqLog(logEntry, allAggregatedLogs) {
                const terminal = this.terminals.get('raw-logs');
                if (!terminal) return;

                const buffer = this.logBuffers.get('raw-logs');
                if (!buffer) return;

                // 如果缓冲区超过最大行数，需要进行一次完整的重绘以同步视图
                // 这是为了处理滚动后顶部日志被丢弃的情况，避免索引错乱
                // 这种情况发生频率较低，可以接受偶尔的重绘
                if (buffer.length >= this.maxLines) {
                    this.updateHighFreqCollapsed(allAggregatedLogs);
                    return;
                }

                // 正常追加
                const formattedLog = this.formatLogEntry(logEntry);
                buffer.push(formattedLog);
                terminal.write(formattedLog + '\r\n');
            }

            // 原地更新高频折叠终端的某一行，无闪烁
            updateHighFreqLogInPlace(globalIndex, logEntry, allAggregatedLogs) {
                const terminal = this.terminals.get('raw-logs');
                if (!terminal) return;

                // 计算该日志在当前显示的100条中的位置
                const displaySize = Math.min(allAggregatedLogs.length, 100);
                const startIndex = allAggregatedLogs.length - displaySize;
                const lineOnScreen = globalIndex - startIndex;

                // 如果日志不在当前屏幕显示的范围内，则无需更新
                if (lineOnScreen < 0 || lineOnScreen >= displaySize) {
                    return;
                }

                const formattedLog = this.formatLogEntry(logEntry);

                // 使用ANSI转义序列实现原地更新
                // \x1b[s       : 保存当前光标位置
                // \x1b[${N};1H : 移动光标到第 N 行, 第 1 列 (行号是1-based)
                // \x1b[2K      : 清除整行
                // ... write ...: 写入新内容
                // \x1b[u       : 恢复之前保存的光标位置
                const command = `\x1b[s\x1b[${lineOnScreen + 1};1H\x1b[2K${formattedLog}\x1b[u`;

                terminal.write(command);
            }

            // 格式化日志条目
            formatLogEntry(logEntry) {
                const timestamp = new Date(logEntry.timestamp).toLocaleTimeString();
                const level = logEntry.level.padEnd(5);
                const target = logEntry.target.padEnd(20);

                let color = '';
                switch (logEntry.level.toUpperCase()) {
                    case 'ERROR': color = '\x1b[31m'; break; // 红色
                    case 'WARN': color = '\x1b[33m'; break;  // 黄色
                    case 'INFO': color = '\x1b[32m'; break;  // 绿色
                    case 'DEBUG': color = '\x1b[36m'; break; // 青色
                    default: color = '\x1b[37m'; break;      // 白色
                }

                const reset = '\x1b[0m';
                const aggregatedPrefix = logEntry.isAggregated ? '\x1b[35m[聚合]\x1b[0m ' : '';

                return `${color}[${timestamp}] ${level} ${target}${reset} ${aggregatedPrefix}${logEntry.message}`;
            }

            // 增量追加日志到指定模块终端 - 关键方法，无闪烁
            appendLogToTerminal(moduleName, logEntry) {
                let terminal = this.terminals.get(moduleName);
                if (!terminal) {
                    // 如果模块不存在，创建它
                    const moduleInfo = webLogState.moduleData.get(moduleName);
                    if (moduleInfo) {
                        this.createDynamicModule(moduleName, moduleInfo);
                        terminal = this.terminals.get(moduleName);
                    }
                }

                if (terminal) {
                    const formattedLog = this.formatLogEntry(logEntry);

                    // 获取日志缓冲区
                    let logBuffer = this.logBuffers.get(moduleName);
                    if (!logBuffer) {
                        logBuffer = [];
                        this.logBuffers.set(moduleName, logBuffer);
                    }

                    // 添加到缓冲区
                    logBuffer.push(formattedLog);

                    // 限制缓冲区大小
                    if (logBuffer.length > this.maxLines) {
                        logBuffer.shift(); // 移除最老的日志
                    }

                    // 关键：直接追加到终端，不清空！
                    terminal.write(formattedLog + '\r\n');
                }
            }

            // 追加到实时日志终端
            appendToRealtimeLogs(logEntry) {
                const terminal = this.terminals.get('realtime-logs');
                if (terminal) {
                    const formattedLog = this.formatLogEntry(logEntry);

                    // 获取实时日志缓冲区
                    let logBuffer = this.logBuffers.get('realtime-logs');
                    if (!logBuffer) {
                        logBuffer = [];
                        this.logBuffers.set('realtime-logs', logBuffer);
                    }

                    // 添加到缓冲区
                    logBuffer.push(formattedLog);

                    // 实时日志只保留最近50条
                    if (logBuffer.length > 50000000) {
                        logBuffer.shift();
                    }

                    // 直接追加到终端
                    terminal.write(formattedLog + '\r\n');
                }
            }

            // 检查模块是否存在
            moduleExists(moduleName) {
                return this.terminals.has(moduleName);
            }

            // 更新实时日志 - 仅用于历史数据加载
            updateRealtimeLogs(logs) {
                const terminal = this.terminals.get('realtime-logs');
                if (!terminal) return;

                // 清空终端和缓冲区
                terminal.clear();
                this.logBuffers.set('realtime-logs', []);

                // 重新加载所有历史日志
                const logBuffer = [];
                logs.forEach(log => {
                    const formattedLog = this.formatLogEntry(log);
                    logBuffer.push(formattedLog);
                    terminal.write(formattedLog + '\r\n');
                });

                this.logBuffers.set('realtime-logs', logBuffer);
            }

            // 更新高频折叠日志 - 仅用于历史数据加载，实时更新通过高频聚合器处理
            updateHighFreqCollapsed(aggregatedLogs) {
                const terminal = this.terminals.get('raw-logs');
                if (!terminal) return;

                // 清空终端和缓冲区
                terminal.clear();
                this.logBuffers.set('raw-logs', []);

                // 重新加载所有聚合日志
                const displayLogs = aggregatedLogs.slice(-100); // 显示最近100条
                const logBuffer = [];
                displayLogs.forEach(log => {
                    const formattedLog = this.formatLogEntry(log);
                    logBuffer.push(formattedLog);
                    terminal.write(formattedLog + '\r\n');
                });

                this.logBuffers.set('raw-logs', logBuffer);
            }

            // 更新模块终端 - 仅用于历史数据加载
            updateModuleTerminal(moduleName, moduleInfo) {
                let terminal = this.terminals.get(moduleName);
                if (!terminal) {
                    // 创建新的动态模块
                    this.createDynamicModule(moduleName, moduleInfo);
                    terminal = this.terminals.get(moduleName);
                }

                if (terminal) {
                    // 清空终端和缓冲区
                    terminal.clear();
                    this.logBuffers.set(moduleName, []);

                    // 重新加载历史日志
                    const displayLogs = moduleInfo.logs.slice(-50); // 显示最近50条
                    const logBuffer = [];
                    displayLogs.forEach(log => {
                        const formattedLog = this.formatLogEntry(log);
                        logBuffer.push(formattedLog);
                        terminal.write(formattedLog + '\r\n');
                    });

                    this.logBuffers.set(moduleName, logBuffer);

                    // 更新模块统计信息
                    this.updateModuleStats(moduleName, moduleInfo);
                }
            }

            // 创建动态模块
            createDynamicModule(moduleName, moduleInfo) {
                const container = document.getElementById('dynamic-modules-container');
                const moduleDiv = document.createElement('div');
                moduleDiv.className = 'module';
                moduleDiv.id = `module-${moduleName}`;

                moduleDiv.innerHTML = `
                    <div class="module-header">
                        <div class="module-title">${moduleName}</div>
                        <div class="module-status status-running">运行中</div>
                    </div>
                    <div class="module-stats">
                        <div class="stat-line">
                            <span>总日志:</span>
                            <span id="stats-${moduleName}-total">${moduleInfo.totalLogs}</span>
                        </div>
                        <div class="stat-line">
                            <span>错误:</span>
                            <span id="stats-${moduleName}-error">${moduleInfo.errorCount}</span>
                        </div>
                        <div class="stat-line">
                            <span>警告:</span>
                            <span id="stats-${moduleName}-warn">${moduleInfo.warnCount}</span>
                        </div>
                        <div class="stat-line">
                            <span>信息:</span>
                            <span id="stats-${moduleName}-info">${moduleInfo.infoCount}</span>
                        </div>
                    </div>
                    <div class="module-terminal" id="terminal-${moduleName}"></div>
                `;

                container.appendChild(moduleDiv);
                this.createTerminal(`terminal-${moduleName}`, moduleName);

                // 更新统计信息
                this.updateModuleStats(moduleName, moduleInfo);
            }

            // 更新模块统计信息
            updateModuleStats(moduleName, moduleInfo) {
                const totalEl = document.getElementById(`stats-${moduleName}-total`);
                const errorEl = document.getElementById(`stats-${moduleName}-error`);
                const warnEl = document.getElementById(`stats-${moduleName}-warn`);
                const infoEl = document.getElementById(`stats-${moduleName}-info`);

                if (totalEl) totalEl.textContent = moduleInfo.totalLogs;
                if (errorEl) errorEl.textContent = moduleInfo.errorCount;
                if (warnEl) warnEl.textContent = moduleInfo.warnCount;
                if (infoEl) infoEl.textContent = moduleInfo.infoCount;
            }

            // 初始化静态终端
            initializeStaticTerminals() {
                this.createTerminal('realtime-logs-terminal', 'realtime-logs');
                this.createTerminal('raw-logs-terminal', 'raw-logs');
            }
        }

        // 全局终端管理器实例
        const terminalManager = new TerminalManager();

        // WebSocket连接管理
        class WebSocketManager {
            constructor() {
                this.ws = null;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;
                this.reconnectDelay = 1000;
                this.isConnected = false;
            }

            // 连接WebSocket
            connect() {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}/ws`;

                console.log('🔗 连接WebSocket:', wsUrl);
                this.updateConnectionStatus('连接中...');

                try {
                    this.ws = new WebSocket(wsUrl);
                    this.setupEventHandlers();
                } catch (error) {
                    console.error('WebSocket连接失败:', error);
                    this.handleConnectionError();
                }
            }

            // 设置事件处理器
            setupEventHandlers() {
                this.ws.onopen = () => {
                    console.log('✅ WebSocket连接成功');
                    this.isConnected = true;
                    this.reconnectAttempts = 0;
                    this.updateConnectionStatus('已连接');
                };

                this.ws.onmessage = (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        this.handleMessage(message);
                    } catch (error) {
                        console.error('解析WebSocket消息失败:', error, event.data);
                    }
                };

                this.ws.onclose = (event) => {
                    console.log('🔌 WebSocket连接关闭:', event.code, event.reason);
                    this.isConnected = false;
                    this.updateConnectionStatus('连接断开');

                    if (!event.wasClean) {
                        this.handleConnectionError();
                    }
                };

                this.ws.onerror = (error) => {
                    console.error('WebSocket错误:', error);
                    this.handleConnectionError();
                };
            }

            // 处理消息
            handleMessage(message) {
                switch (message.type) {
                    case 'LogEntry':
                        webLogState.processLogEntry(message.data);
                        break;
                    case 'HistoryComplete':
                        console.log('📚 历史数据加载完成');
                        webLogState.isHistoryLoaded = true;
                        this.updateConnectionStatus('历史数据已加载');
                        // 历史数据加载完成后，执行一次全量UI更新
                        webLogState.updateUI();
                        break;
                    default:
                        console.warn('未知消息类型:', message.type);
                }
            }

            // 处理连接错误
            handleConnectionError() {
                if (this.reconnectAttempts < this.maxReconnectAttempts) {
                    this.reconnectAttempts++;
                    const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);

                    console.log(`🔄 ${delay}ms后尝试重连 (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
                    this.updateConnectionStatus(`重连中... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);

                    setTimeout(() => this.connect(), delay);
                } else {
                    console.error('❌ 达到最大重连次数，停止重连');
                    this.updateConnectionStatus('连接失败');
                }
            }

            // 更新连接状态显示
            updateConnectionStatus(status) {
                const statusEl = document.getElementById('connection-status');
                if (statusEl) {
                    statusEl.textContent = status;
                    statusEl.className = 'connection-status ' +
                        (this.isConnected ? 'connected' : 'disconnected');
                }
            }
        }

        // 全局WebSocket管理器实例
        const wsManager = new WebSocketManager();

        // 工具函数
        function copyModuleName(moduleName) {
            navigator.clipboard.writeText(moduleName).then(() => {
                console.log('📋 已复制模块名称:', moduleName);
                // 临时高亮显示
                const tag = event.target;
                tag.classList.add('copied');
                setTimeout(() => tag.classList.remove('copied'), 1000);
            }).catch(err => {
                console.error('复制失败:', err);
            });
        }

        function copyAllModules() {
            const moduleNames = Array.from(webLogState.moduleData.keys()).sort();
            const text = moduleNames.join('\n');

            navigator.clipboard.writeText(text).then(() => {
                console.log('📋 已复制所有模块名称');
                const button = document.getElementById('header-copy-modules');
                button.classList.add('copied');
                button.textContent = '✅ 已复制';
                setTimeout(() => {
                    button.classList.remove('copied');
                    button.textContent = '🔥 复制全部模块';
                }, 2000);
            }).catch(err => {
                console.error('复制失败:', err);
            });
        }

        function toggleRealtimeLogs() {
            const module = document.getElementById('realtime-logs-module');
            const button = document.getElementById('toggle-realtime-logs');

            if (module.style.display === 'none') {
                module.style.display = 'flex';
                button.classList.add('active');
                button.textContent = '📊 隐藏实时原始日志';
            } else {
                module.style.display = 'none';
                button.classList.remove('active');
                button.textContent = '📊 显示实时原始日志';
            }
        }

        // 页面初始化
        document.addEventListener('DOMContentLoaded', function() {
            console.log('🎯 页面加载完成，初始化WebLog系统');

            // 初始化终端
            terminalManager.initializeStaticTerminals();

            // 绑定事件
            document.getElementById('header-copy-modules').addEventListener('click', copyAllModules);
            document.getElementById('toggle-realtime-logs').addEventListener('click', toggleRealtimeLogs);

            // 连接WebSocket
            wsManager.connect();

            console.log('✅ WebLog前端聚合系统初始化完成');

            // 添加窗口大小调整的监听器，以重新适配所有终端
            let resizeTimer;
            window.addEventListener('resize', () => {
                // 使用节流防止高频触发
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(() => {
                    console.log('🔄 窗口大小改变，适配所有终端');
                    terminalManager.fitAddons.forEach(fitAddon => {
                        try {
                            fitAddon.fit();
                        } catch (e) {
                            // 忽略可能的错误，例如当终端容器被隐藏时
                        }
                    });
                }, 250); // 250ms延迟
            });
        });
    </script>
</body>
</html>
