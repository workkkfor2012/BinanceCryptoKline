<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebLog - 前端聚合版本 v2.6</title>

    <!-- Xterm.js CSS -->
    <link rel="stylesheet" href="https://unpkg.com/@xterm/xterm@5.5.0/css/xterm.css" />

    <!-- Xterm.js JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/@xterm/xterm@5.5.0/lib/xterm.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/@xterm/addon-fit@0.10.0/lib/addon-fit.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/@xterm/addon-web-links@0.11.0/lib/addon-web-links.js" defer></script>
    <!-- [最终、完美方案] 使用用户验证可用的最新版 v0.15.0 -->
    <script src="https://cdn.jsdelivr.net/npm/@xterm/addon-search@0.15.0/lib/addon-search.js" defer></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            background-color: #1a1a1a;
            color: #00ff00;
            padding: 10px;
            font-size: 16px;
            line-height: 1.5;
        }

        .header {
            padding: 5px 10px;
            border-bottom: 2px solid #333;
            margin-bottom: 10px;
        }

        .header-top-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 15px;
            flex-wrap: wrap;
        }

        .header h1 {
            color: #00ffff;
            font-size: 18px;
            margin: 0;
            flex-shrink: 0;
        }

        .header-buttons {
            display: flex;
            gap: 10px;
            flex-shrink: 0;
            margin-right: 150px; /* 向左移动100px，避免与右上角连接状态重叠 */
        }

        .main-content {
            display: flex;
            gap: 15px;
            height: calc(100vh - 120px);
        }

        .static-modules-area {
            flex: 0 0 820px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            height: 100%;
            border: 2px solid #444;
            border-radius: 8px;
            padding: 10px;
            background-color: #0f0f0f;
        }

        .static-modules-title {
            color: #00ffff;
            font-size: 14px;
            font-weight: bold;
            text-align: center;
            padding: 5px 0;
            border-bottom: 1px solid #444;
            margin-bottom: 5px;
            flex-shrink: 0;
        }

        .static-modules-content {
            flex: 1;
            display: flex;
            gap: 15px;
            min-height: 0;
        }

        /* 确保静态模块区域中的两个模块平分空间 */
        .static-modules-content .static-module {
            flex: 1;
            min-height: 0;
        }

        .dynamic-modules-area {
            flex: 1;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 15px;
            overflow-y: auto;
            height: 100%;
        }

        .module {
            border: 1px solid #333;
            border-radius: 5px;
            background-color: #0a0a0a;
            display: flex;
            flex-direction: column;
        }

        .static-module {
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .static-modules-area .module-header {
            background-color: #1a1a2e;
            border-bottom: 2px solid #16213e;
            flex-shrink: 0;
        }

        .static-modules-area .module-title {
            color: #0ff;
            font-weight: bold;
        }

        .static-modules-area .module-stats {
            flex-shrink: 0;
        }

        .static-modules-area .module-terminal {
            flex: 1;
            min-height: 0; /* 确保终端可以被压缩 */
        }

        .module-header {
            padding: 8px 12px;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .module-title {
            font-weight: bold;
            font-size: 16px;
            color: #00ffff;
        }

        .module-status {
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }

        .status-running { background-color: #006600; color: #00ff00; }
        .status-waiting { background-color: #666600; color: #ffff00; }
        .status-error { background-color: #660000; color: #ff0000; }
        .status-disconnected { background-color: #663300; color: #ff9900; }

        .module-stats {
            padding: 10px 15px;
            border-bottom: 1px solid #333;
            font-size: 13px;
            color: #cccccc;
        }

        .stat-line {
            display: flex;
            justify-content: space-between;
            margin-bottom: 2px;
        }

        .module-terminal {
            flex: 1;
            padding: 5px;
            background-color: #000000;
            overflow: hidden;
            min-height: 100px;
        }

        .xterm {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace !important;
            font-size: 13px !important;
        }

        .xterm .xterm-viewport {
            background-color: #000000 !important;
        }

        .xterm .xterm-screen {
            background-color: #000000 !important;
        }

        /* 让xterm.js终端实例和它的视口100%填充其父容器(.module-terminal) */
        .module-terminal .xterm,
        .module-terminal .xterm-viewport,
        .module-terminal .xterm-screen {
            height: 100% !important;
        }

        .connection-status {
            position: fixed;
            top: 15px;
            right: 15px;
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 14px;
            font-weight: bold;
        }

        .connected { background-color: #006600; color: #00ff00; }
        .disconnected { background-color: #660000; color: #ff0000; }

        .header-copy-button {
            background-color: #ff6600;
            color: #ffffff;
            border: 2px solid #ff8833;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-family: 'Consolas', monospace;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 6px rgba(255, 102, 0, 0.4);
        }

        .header-copy-button:hover {
            background-color: #ff8833;
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(255, 102, 0, 0.6);
        }

        .header-copy-button.copied {
            background-color: #44ff44;
            color: #000000;
            border-color: #66ff66;
        }

        .header-toggle-button {
            background-color: #0066ff;
            color: #ffffff;
            border: 2px solid #3388ff;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-family: 'Consolas', monospace;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 6px rgba(0, 102, 255, 0.4);
        }

        .header-toggle-button:hover {
            background-color: #3388ff;
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0, 102, 255, 0.6);
        }

        .header-toggle-button.active {
            background-color: #44ff44;
            color: #000000;
            border-color: #66ff66;
            box-shadow: 0 2px 6px rgba(68, 255, 68, 0.4);
        }

        .module-names-section {
            flex: 1;
            min-width: 300px;
        }

        .module-names-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            align-items: center;
        }

        .module-name-tag {
            background-color: #1a4a1a;
            color: #00ff00;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
            font-family: 'Consolas', monospace;
            cursor: pointer;
            border: 1px solid #006600;
            transition: all 0.2s ease;
        }

        .module-name-tag:hover {
            background-color: #2a5a2a;
            border-color: #00ff00;
            transform: scale(1.05);
        }

        .module-name-tag.copied {
            background-color: #4a4a1a;
            color: #ffff00;
            border-color: #ffff00;
        }

        .no-modules {
            color: #666;
            font-style: italic;
            font-size: 12px;
        }

        html, body {
            height: 100%;
            overflow-x: hidden;
        }

        .dynamic-modules-area .module {
            min-height: 400px;
        }

        /* 搜索面板样式 */
        .search-panel {
            padding: 8px 12px;
            border-bottom: 1px solid #333;
            background-color: #1a1a1a;
            font-size: 12px;
            flex-shrink: 0; /* 确保搜索面板不会被压缩 */
        }

        .search-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 5px;
        }

        .search-input {
            flex: 1;
            min-width: 200px;
            padding: 4px 8px;
            background-color: #2a2a2a;
            border: 1px solid #444;
            border-radius: 3px;
            color: #00ff00;
            font-family: 'Consolas', monospace;
            font-size: 12px;
        }

        .search-input:focus {
            outline: none;
            border-color: #00ff00;
            box-shadow: 0 0 3px rgba(0, 255, 0, 0.3);
        }

        .search-btn, .search-nav-btn {
            padding: 4px 8px;
            background-color: #0066ff;
            color: white;
            border: 1px solid #3388ff;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }

        .search-btn:hover, .search-nav-btn:hover:not(:disabled) {
            background-color: #3388ff;
            transform: scale(1.05);
        }

        .search-btn:disabled, .search-nav-btn:disabled {
            background-color: #333;
            color: #666;
            cursor: not-allowed;
            border-color: #444;
        }

        .search-option {
            display: flex;
            align-items: center;
            gap: 3px;
            color: #cccccc;
            font-size: 11px;
            cursor: pointer;
        }

        .search-option input[type="checkbox"] {
            margin: 0;
        }

        .search-status {
            color: #888;
            font-size: 11px;
            font-style: italic;
            padding: 2px 4px;
            border-radius: 3px;
            transition: all 0.3s ease;
        }

        .search-status.has-results {
            color: #00ff00;
            background-color: rgba(0, 255, 0, 0.1);
            border: 1px solid rgba(0, 255, 0, 0.3);
        }

        .search-status.no-results {
            color: #ff6600;
            background-color: rgba(255, 102, 0, 0.1);
            border: 1px solid rgba(255, 102, 0, 0.3);
        }

        /* [新增] 搜索插件高亮样式 */
        .xterm .xterm-search-layer .xterm-search-layer__term {
            background-color: #fce100; /* 所有匹配项：亮黄色背景 */
            color: #000; /* 黑色文字，形成高对比度 */
            border-radius: 2px;
            box-sizing: border-box; /* 确保边框和内边距不影响布局 */
        }

        .xterm .xterm-search-layer .xterm-search-layer__term.xterm-search-layer__term-active {
            background-color: #ff6600; /* 当前激活的匹配项：亮橙色背景 */
            color: #fff; /* 白色文字，同样高对比度 */
        }

        @media (max-width: 1200px) {
            .static-modules-area {
                flex: 0 0 600px;
            }

            .static-modules-area .module-terminal {
                min-height: 200px;
            }
        }
    </style>
</head>
<body>
    <div class="connection-status" id="connection-status">连接中...</div>

    <div class="header">
        <div class="header-top-row">
            <h1>WebLog - 前端聚合版本</h1>

            <div class="module-names-section">
                <div class="module-names-list" id="module-names-list">
                    <span class="no-modules">暂无模块数据</span>
                </div>
            </div>

            <div class="header-buttons">
                <button class="header-copy-button" id="header-copy-modules" title="复制所有模块名称">🔥 复制全部模块</button>
                <button class="header-toggle-button" id="toggle-realtime-logs" title="显示/隐藏实时原始日志">📊 显示实时原始日志</button>
            </div>
        </div>
    </div>

    <div class="main-content">
        <!-- 左侧静态模块区域 -->
        <div class="static-modules-area">
            <div class="static-modules-title">📊 静态模块区域 - 日志监控</div>
            <div class="static-modules-content">
                <!-- 实时原始日志模块 (默认隐藏) -->
                <div class="module static-module" id="realtime-logs-module" style="display: none;">
                    <div class="module-header">
                        <div class="module-title">原始日志 | 日志数: <span id="realtime-log-count">0</span> | 最后更新: <span id="last-log-time">--:--:--</span></div>
                        <div class="module-status status-waiting" id="realtime-logs-status">等待日志</div>
                    </div>
                    <!-- 搜索控制面板 -->
                    <div class="search-panel" id="realtime-logs-search-panel">
                        <div class="search-controls">
                            <input type="text" id="realtime-logs-search-input" placeholder="搜索日志内容..." class="search-input">
                            <button id="realtime-logs-search-btn" class="search-btn" title="开始搜索">🔍</button>
                            <button id="realtime-logs-search-clear" class="search-btn" title="清除搜索">✖</button>
                            <button id="realtime-logs-search-prev" class="search-nav-btn" title="上一个匹配" disabled>↑</button>
                            <button id="realtime-logs-search-next" class="search-nav-btn" title="下一个匹配" disabled>↓</button>
                            <label class="search-option">
                                <input type="checkbox" id="realtime-logs-search-case"> 区分大小写
                            </label>
                            <label class="search-option">
                                <input type="checkbox" id="realtime-logs-search-regex"> 正则表达式
                            </label>
                        </div>
                        <div class="search-status" id="realtime-logs-search-status">输入关键词开始搜索</div>
                    </div>
                    <div class="module-terminal" id="realtime-logs-terminal"></div>
                </div>

                <!-- 原始日志高频折叠模块 -->
                <div class="module static-module" id="raw-logs-module">
                    <div class="module-header">
                        <div class="module-title">原始日志折叠 | 总数: <span id="total-log-count">--</span> | 折叠后: <span id="displayed-log-count">--</span> | 时间: <span id="collapse-timestamp">--:--:--</span></div>
                        <div class="module-status status-waiting" id="raw-logs-status">等待日志</div>
                    </div>
                    <!-- 搜索控制面板 -->
                    <div class="search-panel" id="raw-logs-search-panel">
                        <div class="search-controls">
                            <input type="text" id="raw-logs-search-input" placeholder="搜索日志内容..." class="search-input">
                            <button id="raw-logs-search-btn" class="search-btn" title="开始搜索">🔍</button>
                            <button id="raw-logs-search-clear" class="search-btn" title="清除搜索">✖</button>
                            <button id="raw-logs-search-prev" class="search-nav-btn" title="上一个匹配" disabled>↑</button>
                            <button id="raw-logs-search-next" class="search-nav-btn" title="下一个匹配" disabled>↓</button>
                            <label class="search-option">
                                <input type="checkbox" id="raw-logs-search-case"> 区分大小写
                            </label>
                            <label class="search-option">
                                <input type="checkbox" id="raw-logs-search-regex"> 正则表达式
                            </label>
                        </div>
                        <div class="search-status" id="raw-logs-search-status">输入关键词开始搜索</div>
                    </div>
                    <div class="module-terminal" id="raw-logs-terminal"></div>
                </div>

            </div>
        </div>

        <!-- 右侧动态模块区域 -->
        <div class="dynamic-modules-area" id="dynamic-modules-container">
            <!-- 动态模块将在这里创建 -->
        </div>
    </div>

    <script>
        // 前端聚合版本的WebLog系统
        console.log('🚀 WebLog前端聚合版本启动');

        // 全局状态管理
        class WebLogState {
            constructor() {
                this.allLogs = [];           // 所有原始日志
                this.moduleData = new Map(); // 按模块分类的数据
                this.highFreqAggregator = new HighFreqAggregator(); // 高频聚合器
                this.isHistoryLoaded = false; // 历史数据是否加载完成
                this.logCount = 0;           // 日志计数
                this.lastLogTime = null;     // 最后日志时间
                this.startTime = Date.now(); // 启动时间

                // 节流控制 - 解决页面闪烁问题
                this.isUiUpdateScheduled = false; // 是否已有更新计划
                this.uiUpdateInterval = 200; // 更新间隔，单位毫秒
                this.pendingUpdates = {
                    moduleNames: false,
                    realtimeLogs: false,
                    highFreqCollapsed: false,
                    dynamicModules: new Set() // 需要更新的模块名称
                };
            }

            // 处理新的日志条目
            processLogEntry(logEntry) {
                this.allLogs.push(logEntry);
                this.logCount++;
                this.lastLogTime = new Date();

                // 【新增】实时更新 "实时原始日志" 面板的统计数据和状态
                const countEl = document.getElementById('realtime-log-count');
                const timeEl = document.getElementById('last-log-time');
                const realtimeStatusEl = document.getElementById('realtime-logs-status');

                if (countEl) countEl.textContent = this.logCount;
                if (timeEl && this.lastLogTime) timeEl.textContent = this.lastLogTime.toLocaleTimeString();

                // 更新实时原始日志状态为"运行中"
                if (realtimeStatusEl && this.logCount > 0) {
                    realtimeStatusEl.textContent = '运行中';
                    realtimeStatusEl.className = 'module-status status-running';
                }

                // 【新增】更新原始日志折叠模块状态为"运行中"
                const rawLogsStatusEl = document.getElementById('raw-logs-status');
                if (rawLogsStatusEl && this.logCount > 0) {
                    rawLogsStatusEl.textContent = '运行中';
                    rawLogsStatusEl.className = 'module-status status-running';
                }

                // 按模块分类
                const moduleName = logEntry.target;
                if (!this.moduleData.has(moduleName)) {
                    this.moduleData.set(moduleName, {
                        name: moduleName,
                        logs: [],
                        errorCount: 0,
                        warnCount: 0,
                        infoCount: 0,
                        totalLogs: 0
                    });
                }

                const moduleInfo = this.moduleData.get(moduleName);
                moduleInfo.logs.push(logEntry);
                moduleInfo.totalLogs++;

                // 统计日志级别
                switch (logEntry.level.toUpperCase()) {
                    case 'ERROR':
                        moduleInfo.errorCount++;
                        break;
                    case 'WARN':
                        moduleInfo.warnCount++;
                        break;
                    case 'INFO':
                        moduleInfo.infoCount++;
                        break;
                }

                // 保持最近1000条日志
                if (moduleInfo.logs.length > 10000000) {
                    moduleInfo.logs.shift();
                }

                // 高频聚合处理
                this.highFreqAggregator.processLog(logEntry);

                // 【新增】立即更新实时日志（如果显示），使其与高频折叠行为一致
                // 无论是否是历史数据，都追加到实时原始日志终端
                if (terminalManager) {
                    terminalManager.appendToRealtimeLogs(logEntry);
                }

                // 立即增量更新 - 无需节流，直接追加到终端
                // 注意：这里只处理动态模块，实时原始日志已在上面处理
                if (this.isHistoryLoaded && terminalManager) {
                    // 立即追加到对应模块终端
                    terminalManager.appendLogToTerminal(moduleName, logEntry);

                    // 更新模块统计
                    this.updateModuleStatsIncremental(moduleName, moduleInfo);
                }

                // 注意：高频折叠终端的更新已经在 highFreqAggregator.processLog() 中自动处理

                // 只有模块名称需要延迟更新（避免频繁DOM操作）
                this.pendingUpdates.moduleNames = true;
                this.scheduleUIUpdate();
            }

            // 节流调度UI更新 - 防止高频闪烁
            scheduleUIUpdate() {
                if (!this.isUiUpdateScheduled) {
                    this.isUiUpdateScheduled = true;
                    setTimeout(() => {
                        this.performScheduledUpdates();
                        this.isUiUpdateScheduled = false;
                    }, this.uiUpdateInterval);
                }
            }

            // 执行计划中的更新 - 只更新模块名称列表（其他都是实时增量更新）
            performScheduledUpdates() {
                if (this.pendingUpdates.moduleNames) {
                    this.updateModuleNames();
                    this.pendingUpdates.moduleNames = false;
                }
            }

            // 增量更新模块统计信息
            updateModuleStatsIncremental(moduleName, moduleInfo) {
                if (!terminalManager.moduleExists(moduleName)) {
                    terminalManager.createDynamicModule(moduleName, moduleInfo);
                }
                terminalManager.updateModuleStats(moduleName, moduleInfo);
            }

            // 更新界面 - 保留用于历史数据加载时的全量更新
            updateUI() {
                this.updateModuleNames();
                // this.updateRealtimeLogs(); // 禁用：避免清空已实时填充的内容
                // this.updateHighFreqCollapsed(); // 禁用：避免清空已实时填充的内容
                this.updateDynamicModules();
            }

            // 更新模块名称列表
            updateModuleNames() {
                const container = document.getElementById('module-names-list');
                if (this.moduleData.size === 0) {
                    container.innerHTML = '<span class="no-modules">暂无模块数据</span>';
                    return;
                }

                const moduleNames = Array.from(this.moduleData.keys()).sort();
                container.innerHTML = moduleNames.map(name =>
                    `<span class="module-name-tag" onclick="copyModuleName('${name}')">${name}</span>`
                ).join('');
            }

            // 更新实时日志显示
            updateRealtimeLogs() {
                const countEl = document.getElementById('realtime-log-count');
                const timeEl = document.getElementById('last-log-time');

                if (countEl) countEl.textContent = this.logCount;
                if (timeEl && this.lastLogTime) {
                    timeEl.textContent = this.lastLogTime.toLocaleTimeString();
                }

                // 更新实时日志终端
                if (terminalManager && this.isHistoryLoaded) {
                    const recentLogs = this.allLogs.slice(-100); // 最近100条，与高频折叠保持一致
                    terminalManager.updateRealtimeLogs(recentLogs);
                }
            }

            // 更新高频折叠日志 - 仅用于历史数据加载
            updateHighFreqCollapsed() {
                // 获取高频聚合后的日志
                const aggregatedLogs = this.highFreqAggregator.getAggregatedLogs();

                // 更新高频折叠日志终端（仅用于历史数据加载）
                if (terminalManager && this.isHistoryLoaded) {
                    terminalManager.updateHighFreqCollapsed(aggregatedLogs);
                }
            }

            // 更新动态模块 - 全量更新（用于历史数据加载）
            updateDynamicModules() {
                if (terminalManager && this.isHistoryLoaded) {
                    for (const [moduleName, moduleInfo] of this.moduleData) {
                        terminalManager.updateModuleTerminal(moduleName, moduleInfo);
                    }
                }
            }

            // 更新单个动态模块 - 增量更新（用于实时日志）
            updateDynamicModule(moduleName, moduleInfo) {
                if (terminalManager && this.isHistoryLoaded) {
                    terminalManager.updateModuleTerminal(moduleName, moduleInfo);
                }
            }

            // 清空所有数据 - 用于新会话开始时重置前端状态
            clearAllData() {
                console.log('🧹 清空前端缓存数据');

                // 重置所有状态
                this.allLogs = [];
                this.moduleData.clear();
                this.isHistoryLoaded = false;
                this.logCount = 0;
                this.lastLogTime = null;
                this.startTime = Date.now();

                // 重置高频聚合器
                this.highFreqAggregator = new HighFreqAggregator();

                // 清空所有终端
                if (terminalManager) {
                    // 清空实时日志终端
                    const realtimeTerminal = terminalManager.terminals.get('realtime-logs');
                    if (realtimeTerminal) {
                        realtimeTerminal.clear();
                        terminalManager.logBuffers.set('realtime-logs', []);
                    }

                    // 清空高频折叠终端
                    const rawLogsTerminal = terminalManager.terminals.get('raw-logs');
                    if (rawLogsTerminal) {
                        rawLogsTerminal.clear();
                        terminalManager.logBuffers.set('raw-logs', []);
                    }

                    // 清空所有动态模块终端
                    for (const [moduleName, terminal] of terminalManager.terminals) {
                        if (moduleName !== 'realtime-logs' && moduleName !== 'raw-logs') {
                            terminal.clear();
                            terminalManager.logBuffers.set(moduleName, []);
                        }
                    }
                }

                // 清空UI显示
                this.updateModuleNames();

                // 重置统计显示
                const countEl = document.getElementById('realtime-log-count');
                const timeEl = document.getElementById('last-log-time');
                const totalCountEl = document.getElementById('total-log-count');
                const displayedCountEl = document.getElementById('displayed-log-count');
                const timestampEl = document.getElementById('collapse-timestamp');

                if (countEl) countEl.textContent = '0';
                if (timeEl) timeEl.textContent = '--';
                if (totalCountEl) totalCountEl.textContent = '0';
                if (displayedCountEl) displayedCountEl.textContent = '0';
                if (timestampEl) timestampEl.textContent = '--';

                // 重置状态显示
                const realtimeStatusEl = document.getElementById('realtime-logs-status');
                const rawLogsStatusEl = document.getElementById('raw-logs-status');

                if (realtimeStatusEl) {
                    realtimeStatusEl.textContent = '等待日志';
                    realtimeStatusEl.className = 'module-status status-waiting';
                }

                if (rawLogsStatusEl) {
                    rawLogsStatusEl.textContent = '等待日志';
                    rawLogsStatusEl.className = 'module-status status-waiting';
                }

                console.log('✅ 前端缓存清空完成');
            }
        }

        // 高频日志聚合器 - 采用 is_high_freq 和 event_type 精确控制
        class HighFreqAggregator {
            constructor() {
                this.aggregatedLogs = []; // 持久化的日志列表，是终端显示的最终数据源
                // 追踪活跃的、可被折叠的日志分组
                // Key: messageKey (由 target:event_type 构成), Value: { index, count, ... }
                this.activeGroups = new Map();
                this.timeWindow = 5000; // 5秒时间窗口
            }

            // 核心处理逻辑 - 已重构为精确分发
            processLog(logEntry) {
                const isHighFreq = logEntry.fields && logEntry.fields.is_high_freq === true;

                // **关键分发逻辑**
                if (isHighFreq && logEntry.fields.event_type) {
                    // **路径1：高频日志处理**
                    // 只有标记为高频且拥有event_type的日志才进入聚合流程
                    this.processHighFrequencyLog(logEntry);
                } else {
                    // **路径2：普通日志处理**
                    // 所有其他日志（非高频或缺少event_type）都直接追加，不参与聚合
                    this.appendAsNormalLog(logEntry);
                }

                // 更新统计数据
                this.updateStats();
            }

            // 处理高频日志（聚合逻辑）
            processHighFrequencyLog(logEntry) {
                const messageKey = this.getMessageKey(logEntry);
                const now = Date.now();

                if (this.activeGroups.has(messageKey)) {
                    const group = this.activeGroups.get(messageKey);

                    // 检查分组是否仍在时间窗口内
                    if (now - group.lastTime < this.timeWindow) {
                        // 聚合：更新现有分组
                        group.count++;
                        group.lastTime = now;
                        group.lastEntry = logEntry;

                        const aggregatedEntry = {
                            ...group.lastEntry,
                            message: `[${group.count}x] ${group.firstEntry.message}`,
                            isAggregated: true,
                            count: group.count,
                        };

                        this.aggregatedLogs[group.index] = aggregatedEntry;
                        terminalManager.updateHighFreqLogInPlace(group.index, aggregatedEntry, this.aggregatedLogs);
                    } else {
                        // 超时：结束旧分组，将此日志作为新分组的开始
                        this.activeGroups.delete(messageKey);
                        this.addNewHighFreqGroup(logEntry, messageKey, now);
                    }
                } else {
                    // 全新：为此 event_type 创建一个新的聚合分组
                    this.addNewHighFreqGroup(logEntry, messageKey, now);
                }
            }

            // 将日志作为普通、非聚合条目直接追加
            appendAsNormalLog(logEntry) {
                // 直接添加到数据源
                this.aggregatedLogs.push(logEntry);
                // 直接通知终端管理器追加显示
                terminalManager.appendHighFreqLog(logEntry, this.aggregatedLogs);
            }

            // 获取高频日志的分组键
            getMessageKey(logEntry) {
                // 此方法现在只被高频日志路径调用，因此可以确信 event_type 存在
                return `${logEntry.target}:${logEntry.fields.event_type}`;
            }

            // 辅助函数：为高频日志创建一个新的聚合分组
            addNewHighFreqGroup(logEntry, messageKey, now) {
                this.aggregatedLogs.push(logEntry);
                const newIndex = this.aggregatedLogs.length - 1;

                // 创建一个新的活跃分组，以便后续的日志可以匹配并折叠
                this.activeGroups.set(messageKey, {
                    index: newIndex,
                    count: 1,
                    lastTime: now,
                    firstEntry: logEntry,
                    lastEntry: logEntry
                });

                // 通知终端管理器追加显示这个新分组的初始日志
                terminalManager.appendHighFreqLog(logEntry, this.aggregatedLogs);
            }

            // 只更新统计部分的UI
            updateStats() {
                const timestampEl = document.getElementById('collapse-timestamp');
                const totalCountEl = document.getElementById('total-log-count');
                const displayedCountEl = document.getElementById('displayed-log-count');

                if (timestampEl) timestampEl.textContent = new Date().toLocaleTimeString();
                if (totalCountEl) totalCountEl.textContent = webLogState.allLogs.length;
                if (displayedCountEl) displayedCountEl.textContent = this.aggregatedLogs.length;
            }

            // 获取聚合后的日志（用于历史加载）
            getAggregatedLogs() {
                return this.aggregatedLogs;
            }

            // 完整重绘终端（仅用于初始化或特殊情况）
            updateHighFreqCollapsed(logs) {
                const terminal = terminalManager.terminals.get('raw-logs');
                if (!terminal) return;

                const displayLogs = logs ? logs.slice(-100) : this.aggregatedLogs.slice(-100);

                terminal.clear();
                const logBuffer = [];
                displayLogs.forEach(log => {
                    const formattedLog = terminalManager.formatLogEntry(log);
                    logBuffer.push(formattedLog);
                    terminal.write(formattedLog + '\r\n');
                });
                terminalManager.logBuffers.set('raw-logs', logBuffer);
                this.updateStats();
            }
        }

        // [修改] SearchManager 完全重构，使用 xterm-addon-search
        class SearchManager {
            constructor() {
                this.terminalName = '';
                this.searchAddon = null;
                this.isSearchActive = false;
                this.lastSearchTerm = '';
            }

            initializeSearch(terminalName) {
                this.terminalName = terminalName;
                this.searchAddon = terminalManager.searchAddons.get(terminalName);

                if (!this.searchAddon) {
                    console.error(`搜索插件初始化失败: ${terminalName}`);
                    return;
                }

                const searchInput = document.getElementById(`${terminalName}-search-input`);
                const searchBtn = document.getElementById(`${terminalName}-search-btn`);
                const clearBtn = document.getElementById(`${terminalName}-search-clear`);
                const prevBtn = document.getElementById(`${terminalName}-search-prev`);
                const nextBtn = document.getElementById(`${terminalName}-search-next`);
                const caseCheckbox = document.getElementById(`${terminalName}-search-case`);
                const regexCheckbox = document.getElementById(`${terminalName}-search-regex`);

                this.searchAddon.onDidChangeResults((results) => {
                    this.updateSearchStatus(results.resultCount, results.resultIndex);
                    this.updateNavigationButtons(results.resultCount > 0);
                });

                searchInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        if(searchInput.value !== this.lastSearchTerm) {
                            this.performSearch();
                        } else {
                            this.navigateMatch(1);
                        }
                    } else if (e.key === 'Escape') {
                        this.clearSearch();
                    }
                });

                searchBtn?.addEventListener('click', () => this.performSearch());
                clearBtn?.addEventListener('click', () => this.clearSearch());
                prevBtn?.addEventListener('click', () => this.navigateMatch(-1));
                nextBtn?.addEventListener('click', () => this.navigateMatch(1));

                const performSearchIfActive = () => {
                    if (this.isSearchActive) this.performSearch();
                };

                caseCheckbox?.addEventListener('change', performSearchIfActive);
                regexCheckbox?.addEventListener('change', performSearchIfActive);
            }

            getSearchOptions() {
                const caseCheckbox = document.getElementById(`${this.terminalName}-search-case`);
                const regexCheckbox = document.getElementById(`${this.terminalName}-search-regex`);
                return {
                    regex: regexCheckbox ? regexCheckbox.checked : false,
                    caseSensitive: caseCheckbox ? caseCheckbox.checked : false,
                    incremental: false, // 我们手动触发搜索，而非输入时即时搜索
                    decorations: {
                        // 不设置背景色，保持透明
                        matchBorder: '#FF0000',            // 红色边框 - 普通匹配项
                        matchOverviewRuler: '#FF0000',     // 红色概览标尺 - 普通匹配项
                        // 不设置背景色，保持透明
                        activeMatchBorder: '#FFFF00',      // 黄色边框 - 当前激活匹配项
                        activeMatchColorOverviewRuler: '#FFFF00' // 黄色概览标尺 - 当前激活匹配项
                    }
                };
            }

            performSearch() {
                const searchInput = document.getElementById(`${this.terminalName}-search-input`);
                const term = searchInput.value;

                if (!term) {
                    this.clearSearch();
                    return;
                }

                this.isSearchActive = true;
                this.lastSearchTerm = term;
                this.searchAddon.findNext(term, this.getSearchOptions());
            }

            navigateMatch(direction) {
                if (!this.isSearchActive) return;
                const term = this.lastSearchTerm;
                if (direction > 0) {
                    this.searchAddon.findNext(term, this.getSearchOptions());
                } else {
                    this.searchAddon.findPrevious(term, this.getSearchOptions());
                }
            }

            clearSearch() {
                this.searchAddon.clearDecorations();
                this.isSearchActive = false;
                this.lastSearchTerm = '';

                const searchInput = document.getElementById(`${this.terminalName}-search-input`);
                if (searchInput) searchInput.value = '';

                this.updateSearchStatus(0, -1);
                this.updateNavigationButtons(false);
                const statusEl = document.getElementById(`${this.terminalName}-search-status`);
                if(statusEl) {
                    statusEl.textContent = '输入关键词开始搜索';
                    statusEl.className = 'search-status';
                }
            }

            updateSearchStatus(count, index) {
                const statusEl = document.getElementById(`${this.terminalName}-search-status`);
                if (!statusEl) return;

                if (!this.isSearchActive || count === 0) {
                    if(this.isSearchActive) {
                        statusEl.textContent = `未找到匹配项: "${this.lastSearchTerm}"`;
                        statusEl.className = 'search-status no-results';
                    } else {
                         statusEl.textContent = '输入关键词开始搜索';
                         statusEl.className = 'search-status';
                    }
                } else {
                    statusEl.textContent = `🔍 找到 ${count} 个匹配项 | 当前: ${index + 1}/${count}`;
                    statusEl.className = 'search-status has-results';
                }
            }

            updateNavigationButtons(hasMatches) {
                const prevBtn = document.getElementById(`${this.terminalName}-search-prev`);
                const nextBtn = document.getElementById(`${this.terminalName}-search-next`);

                if (prevBtn) prevBtn.disabled = !hasMatches;
                if (nextBtn) nextBtn.disabled = !hasMatches;
            }
        }

        // 全局状态实例
        const webLogState = new WebLogState();

        // 终端管理器
        class TerminalManager {
            constructor() {
                this.terminals = new Map();
                this.fitAddons = new Map();
                this.searchAddons = new Map(); // [新增] 用于存储搜索插件实例
                this.logBuffers = new Map(); // 日志缓冲区，用于管理每个终端的日志
                this.searchManagers = new Map(); // 搜索管理器
                this.maxLines = 100000000; // 每个终端最大行数

                this.terminalTheme = {
                    background: '#000000',
                    foreground: '#00ff00',
                    cursor: '#00ff00',
                    cursorAccent: '#000000',
                    // [修改] selection的颜色现在只用于手动选择，不再影响搜索
                    selectionBackground: 'rgba(255, 255, 255, 0.3)',
                    selectionForeground: '#000000', // 可选，为选择文本添加前景色
                    black: '#000000',
                    red: '#ff0000',
                    green: '#00ff00',
                    yellow: '#ffff00',
                    blue: '#0066ff',
                    magenta: '#ff00ff',
                    cyan: '#00ffff',
                    white: '#ffffff',
                    brightBlack: '#666666',
                    brightRed: '#ff6666',
                    brightGreen: '#66ff66',
                    brightYellow: '#ffff66',
                    brightBlue: '#6666ff',
                    brightMagenta: '#ff66ff',
                    brightCyan: '#66ffff',
                    brightWhite: '#ffffff'
                };
            }

            // [修改] 创建终端时加载搜索插件
            createTerminal(containerId, moduleName) {
                const container = document.getElementById(containerId);
                if (!container) {
                    console.error(`找不到容器: ${containerId}`);
                    return null;
                }

                const terminal = new Terminal({
                    theme: this.terminalTheme,
                    fontFamily: 'Consolas, Monaco, "Courier New", monospace',
                    fontSize: 15,  // 增大字体从13到15
                    lineHeight: 1.2,
                    cursorBlink: false,
                    scrollback: this.maxLines,
                    convertEol: true,
                    disableStdin: true,
                    allowTransparency: true,
                    allowProposedApi: true  // 启用提议API以支持搜索装饰功能
                });

                // [修正] 通过 "命名空间.构造函数" 的方式实例化插件
                const fitAddon = new FitAddon.FitAddon();
                const webLinksAddon = new WebLinksAddon.WebLinksAddon();

                let searchAddon = null;
                try {
                    // [修正] 使用正确的全局变量 SearchAddon 和正确的实例化方式
                    if (window.SearchAddon && typeof window.SearchAddon.SearchAddon === 'function') {
                        // 创建搜索插件时配置边框装饰颜色（无背景）
                        const searchOptions = {
                            decorations: {
                                // 不设置背景色，保持透明
                                matchBorder: '#FF0000',            // 红色边框 - 普通匹配项
                                matchOverviewRuler: '#FF0000',     // 红色概览标尺 - 普通匹配项
                                // 不设置背景色，保持透明
                                activeMatchBorder: '#FFFF00',      // 黄色边框 - 当前激活匹配项
                                activeMatchColorOverviewRuler: '#FFFF00' // 黄色概览标尺 - 当前激活匹配项
                            }
                        };
                        searchAddon = new window.SearchAddon.SearchAddon(searchOptions);
                        console.log(`✅ 搜索插件创建成功 for ${moduleName} (高对比度配色)`);
                    } else {
                        // 更新错误信息以反映正确的变量名
                        throw new Error('SearchAddon 未在 window 对象上正确定义。请检查 xterm-addon-search 脚本是否正确加载。');
                    }
                } catch (error) {
                    console.error('❌ 创建搜索插件失败:', error);
                    // 创建一个模拟的搜索插件对象，避免后续代码崩溃
                    searchAddon = {
                        activate: () => {},
                        onDidChangeResults: () => {},
                        findNext: () => {},
                        findPrevious: () => {},
                        clearDecorations: () => {},
                        clearActiveDecoration: () => {}
                    };
                    console.log('⚠️ 已创建模拟搜索对象，搜索功能将不可用。');
                }

                terminal.loadAddon(fitAddon);
                terminal.loadAddon(webLinksAddon);
                terminal.loadAddon(searchAddon); // 加载真实的或模拟的插件

                terminal.open(container);
                setTimeout(() => fitAddon.fit(), 0);

                this.terminals.set(moduleName, terminal);
                this.fitAddons.set(moduleName, fitAddon);
                this.searchAddons.set(moduleName, searchAddon);
                this.logBuffers.set(moduleName, []); // 初始化日志缓冲区

                return terminal;
            }

            // 追加一行到高频折叠终端，无闪烁
            appendHighFreqLog(logEntry, allAggregatedLogs) {
                const terminal = this.terminals.get('raw-logs');
                if (!terminal) return;

                const buffer = this.logBuffers.get('raw-logs');
                if (!buffer) return;

                // 如果缓冲区超过最大行数，需要进行一次完整的重绘以同步视图
                // 这是为了处理滚动后顶部日志被丢弃的情况，避免索引错乱
                // 这种情况发生频率较低，可以接受偶尔的重绘
                if (buffer.length >= this.maxLines) {
                    this.updateHighFreqCollapsed(allAggregatedLogs);
                    return;
                }

                // 正常追加
                const formattedLog = this.formatLogEntry(logEntry);
                buffer.push(formattedLog);
                terminal.write(formattedLog + '\r\n');
            }

            // 原地更新高频折叠终端的某一行，无闪烁
            updateHighFreqLogInPlace(globalIndex, logEntry, allAggregatedLogs) {
                const terminal = this.terminals.get('raw-logs');
                if (!terminal) return;

                // 计算该日志在当前显示的100条中的位置
                const displaySize = Math.min(allAggregatedLogs.length, 100);
                const startIndex = allAggregatedLogs.length - displaySize;
                const lineOnScreen = globalIndex - startIndex;

                // 如果日志不在当前屏幕显示的范围内，则无需更新
                if (lineOnScreen < 0 || lineOnScreen >= displaySize) {
                    return;
                }

                const formattedLog = this.formatLogEntry(logEntry);

                // 使用ANSI转义序列实现原地更新
                // \x1b[s       : 保存当前光标位置
                // \x1b[${N};1H : 移动光标到第 N 行, 第 1 列 (行号是1-based)
                // \x1b[2K      : 清除整行
                // ... write ...: 写入新内容
                // \x1b[u       : 恢复之前保存的光标位置
                const command = `\x1b[s\x1b[${lineOnScreen + 1};1H\x1b[2K${formattedLog}\x1b[u`;

                terminal.write(command);
            }

            // 格式化日志条目 - 用于模块终端和高频折叠
            formatLogEntry(logEntry) {
                const timestamp = new Date(logEntry.timestamp).toLocaleTimeString();
                const level = logEntry.level.padEnd(5);
                const target = logEntry.target.padEnd(20);

                let color = '';
                switch (logEntry.level.toUpperCase()) {
                    case 'ERROR': color = '\x1b[31m'; break; // 红色
                    case 'WARN': color = '\x1b[33m'; break;  // 黄色
                    case 'INFO': color = '\x1b[32m'; break;  // 绿色
                    case 'DEBUG': color = '\x1b[36m'; break; // 青色
                    default: color = '\x1b[37m'; break;      // 白色
                }

                const reset = '\x1b[0m';
                const aggregatedPrefix = logEntry.isAggregated ? '\x1b[35m[聚合]\x1b[0m ' : '';

                return `${color}[${timestamp}] ${level} ${target}${reset} ${aggregatedPrefix}${logEntry.message}`;
            }

            // 格式化原始日志条目 - 用于实时原始日志，显示完整JSON格式
            formatRawLogEntry(logEntry) {
                // 创建一个干净的日志对象，移除内部处理字段
                const cleanLogEntry = {
                    timestamp: logEntry.timestamp,
                    level: logEntry.level,
                    target: logEntry.target,
                    message: logEntry.message
                };

                // 如果有fields字段，添加到输出中
                if (logEntry.fields && Object.keys(logEntry.fields).length > 0) {
                    cleanLogEntry.fields = logEntry.fields;
                }

                // 如果有span信息，添加到输出中
                if (logEntry.span) {
                    cleanLogEntry.span = logEntry.span;
                }

                // 根据日志级别设置颜色
                let color = '';
                switch (logEntry.level.toUpperCase()) {
                    case 'ERROR': color = '\x1b[31m'; break; // 红色
                    case 'WARN': color = '\x1b[33m'; break;  // 黄色
                    case 'INFO': color = '\x1b[32m'; break;  // 绿色
                    case 'DEBUG': color = '\x1b[36m'; break; // 青色
                    default: color = '\x1b[37m'; break;      // 白色
                }

                const reset = '\x1b[0m';

                // 格式化JSON，使其更易读
                const jsonString = JSON.stringify(cleanLogEntry, null, 2);

                // 为JSON添加颜色
                return `${color}${jsonString}${reset}`;
            }

            // 增量追加日志到指定模块终端 - 关键方法，无闪烁
            appendLogToTerminal(moduleName, logEntry) {
                let terminal = this.terminals.get(moduleName);
                if (!terminal) {
                    // 如果模块不存在，创建它
                    const moduleInfo = webLogState.moduleData.get(moduleName);
                    if (moduleInfo) {
                        this.createDynamicModule(moduleName, moduleInfo);
                        terminal = this.terminals.get(moduleName);
                    }
                }

                if (terminal) {
                    const formattedLog = this.formatLogEntry(logEntry);

                    // 获取日志缓冲区
                    let logBuffer = this.logBuffers.get(moduleName);
                    if (!logBuffer) {
                        logBuffer = [];
                        this.logBuffers.set(moduleName, logBuffer);
                    }

                    // 添加到缓冲区
                    logBuffer.push(formattedLog);

                    // 限制缓冲区大小
                    if (logBuffer.length > this.maxLines) {
                        logBuffer.shift(); // 移除最老的日志
                    }

                    // 关键：直接追加到终端，不清空！
                    terminal.write(formattedLog + '\r\n');
                }
            }

            // 追加到实时日志终端 - 显示原始JSON格式
            appendToRealtimeLogs(logEntry) {
                const terminal = this.terminals.get('realtime-logs');
                if (terminal) {
                    const formattedLog = this.formatRawLogEntry(logEntry);

                    // 获取实时日志缓冲区
                    let logBuffer = this.logBuffers.get('realtime-logs');
                    if (!logBuffer) {
                        logBuffer = [];
                        this.logBuffers.set('realtime-logs', logBuffer);
                    }

                    // 添加到缓冲区
                    logBuffer.push(formattedLog);

                    // 实时日志保留大量历史数据，让历史加载过程能够填满终端
                    if (logBuffer.length > 50000000) {
                        logBuffer.shift();
                    }

                    // 直接追加到终端
                    terminal.write(formattedLog + '\r\n');
                }
            }

            // 检查模块是否存在
            moduleExists(moduleName) {
                return this.terminals.has(moduleName);
            }

            // 更新实时日志 - 仅用于历史数据加载，显示原始JSON格式
            updateRealtimeLogs(logs) {
                const terminal = this.terminals.get('realtime-logs');
                if (!terminal) return;

                // 清空终端和缓冲区
                terminal.clear();
                this.logBuffers.set('realtime-logs', []);

                // 重新加载所有历史日志，使用原始JSON格式
                const logBuffer = [];
                logs.forEach(log => {
                    const formattedLog = this.formatRawLogEntry(log);
                    logBuffer.push(formattedLog);
                    terminal.write(formattedLog + '\r\n');
                });

                this.logBuffers.set('realtime-logs', logBuffer);
            }

            // 更新高频折叠日志 - 仅用于历史数据加载，实时更新通过高频聚合器处理
            updateHighFreqCollapsed(aggregatedLogs) {
                const terminal = this.terminals.get('raw-logs');
                if (!terminal) return;

                // 清空终端和缓冲区
                terminal.clear();
                this.logBuffers.set('raw-logs', []);

                // 重新加载所有聚合日志
                const displayLogs = aggregatedLogs.slice(-100); // 显示最近100条
                const logBuffer = [];
                displayLogs.forEach(log => {
                    const formattedLog = this.formatLogEntry(log);
                    logBuffer.push(formattedLog);
                    terminal.write(formattedLog + '\r\n');
                });

                this.logBuffers.set('raw-logs', logBuffer);
            }

            // 更新模块终端 - 仅用于历史数据加载
            updateModuleTerminal(moduleName, moduleInfo) {
                let terminal = this.terminals.get(moduleName);
                if (!terminal) {
                    // 创建新的动态模块
                    this.createDynamicModule(moduleName, moduleInfo);
                    terminal = this.terminals.get(moduleName);
                }

                if (terminal) {
                    // 清空终端和缓冲区
                    terminal.clear();
                    this.logBuffers.set(moduleName, []);

                    // 重新加载历史日志
                    const displayLogs = moduleInfo.logs.slice(-50); // 显示最近50条
                    const logBuffer = [];
                    displayLogs.forEach(log => {
                        const formattedLog = this.formatLogEntry(log);
                        logBuffer.push(formattedLog);
                        terminal.write(formattedLog + '\r\n');
                    });

                    this.logBuffers.set(moduleName, logBuffer);

                    // 更新模块统计信息
                    this.updateModuleStats(moduleName, moduleInfo);
                }
            }

            // 创建动态模块
            createDynamicModule(moduleName, moduleInfo) {
                const container = document.getElementById('dynamic-modules-container');
                const moduleDiv = document.createElement('div');
                moduleDiv.className = 'module';
                moduleDiv.id = `module-${moduleName}`;

                moduleDiv.innerHTML = `
                    <div class="module-header">
                        <div class="module-title">${moduleName} | 总日志: <span id="stats-${moduleName}-total">${moduleInfo.totalLogs}</span></div>
                        <div class="module-status status-running">运行中</div>
                    </div>
                    <!-- 搜索控制面板 -->
                    <div class="search-panel" id="${moduleName}-search-panel">
                        <div class="search-controls">
                            <input type="text" id="${moduleName}-search-input" placeholder="搜索日志内容..." class="search-input">
                            <button id="${moduleName}-search-btn" class="search-btn" title="开始搜索">🔍</button>
                            <button id="${moduleName}-search-clear" class="search-btn" title="清除搜索">✖</button>
                            <button id="${moduleName}-search-prev" class="search-nav-btn" title="上一个匹配" disabled>↑</button>
                            <button id="${moduleName}-search-next" class="search-nav-btn" title="下一个匹配" disabled>↓</button>
                            <label class="search-option">
                                <input type="checkbox" id="${moduleName}-search-case"> 区分大小写
                            </label>
                            <label class="search-option">
                                <input type="checkbox" id="${moduleName}-search-regex"> 正则表达式
                            </label>
                        </div>
                        <div class="search-status" id="${moduleName}-search-status">输入关键词开始搜索</div>
                    </div>
                    <div class="module-terminal" id="terminal-${moduleName}"></div>
                `;

                container.appendChild(moduleDiv);
                this.createTerminal(`terminal-${moduleName}`, moduleName);

                // 为动态模块初始化搜索功能
                const searchManager = new SearchManager();
                searchManager.initializeSearch(moduleName);
                this.searchManagers.set(moduleName, searchManager);

                // 更新统计信息
                this.updateModuleStats(moduleName, moduleInfo);
            }

            // 更新模块统计信息
            updateModuleStats(moduleName, moduleInfo) {
                const totalEl = document.getElementById(`stats-${moduleName}-total`);
                if (totalEl) totalEl.textContent = moduleInfo.totalLogs;
            }

            // 初始化静态终端
            initializeStaticTerminals() {
                this.createTerminal('realtime-logs-terminal', 'realtime-logs');
                this.createTerminal('raw-logs-terminal', 'raw-logs');

                // 为实时日志终端初始化搜索功能
                const realtimeSearchManager = new SearchManager();
                realtimeSearchManager.initializeSearch('realtime-logs');
                this.searchManagers.set('realtime-logs', realtimeSearchManager);

                // 为原始日志折叠终端初始化搜索功能
                const rawLogsSearchManager = new SearchManager();
                rawLogsSearchManager.initializeSearch('raw-logs');
                this.searchManagers.set('raw-logs', rawLogsSearchManager);
            }
        }

        // 全局终端管理器实例
        const terminalManager = new TerminalManager();

        // WebSocket连接管理
        class WebSocketManager {
            constructor() {
                this.ws = null;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;
                this.reconnectDelay = 1000;
                this.isConnected = false;
            }

            // 连接WebSocket
            connect() {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}/ws`;

                console.log('🔗 连接WebSocket:', wsUrl);
                this.updateConnectionStatus('连接中...');

                try {
                    this.ws = new WebSocket(wsUrl);
                    this.setupEventHandlers();
                } catch (error) {
                    console.error('WebSocket连接失败:', error);
                    this.handleConnectionError();
                }
            }

            // 设置事件处理器
            setupEventHandlers() {
                this.ws.onopen = () => {
                    console.log('✅ WebSocket连接成功');
                    this.isConnected = true;
                    this.reconnectAttempts = 0;
                    this.updateConnectionStatus('已连接');
                };

                this.ws.onmessage = (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        this.handleMessage(message);
                    } catch (error) {
                        console.error('解析WebSocket消息失败:', error, event.data);
                    }
                };

                this.ws.onclose = (event) => {
                    console.log('🔌 WebSocket连接关闭:', event.code, event.reason);
                    this.isConnected = false;
                    this.updateConnectionStatus('连接断开');

                    if (!event.wasClean) {
                        this.handleConnectionError();
                    }
                };

                this.ws.onerror = (error) => {
                    console.error('WebSocket错误:', error);
                    this.handleConnectionError();
                };
            }

            // 处理消息
            handleMessage(message) {
                switch (message.type) {
                    case 'SessionStart':
                        console.log('🆕 新会话开始:', message.session_id);
                        this.updateConnectionStatus('新会话开始');
                        // 清空前端缓存并重新初始化
                        webLogState.clearAllData();
                        break;
                    case 'LogEntry':
                        webLogState.processLogEntry(message.data);
                        break;
                    case 'HistoryComplete':
                        console.log('📚 历史数据加载完成');
                        webLogState.isHistoryLoaded = true;
                        this.updateConnectionStatus('历史数据已加载');
                        // 历史数据加载完成后，执行一次全量UI更新
                        webLogState.updateUI();
                        break;
                    default:
                        console.warn('未知消息类型:', message.type);
                }
            }

            // 处理连接错误
            handleConnectionError() {
                if (this.reconnectAttempts < this.maxReconnectAttempts) {
                    this.reconnectAttempts++;
                    const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);

                    console.log(`🔄 ${delay}ms后尝试重连 (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
                    this.updateConnectionStatus(`重连中... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);

                    setTimeout(() => this.connect(), delay);
                } else {
                    console.error('❌ 达到最大重连次数，停止重连');
                    this.updateConnectionStatus('连接失败');
                }
            }

            // 更新连接状态显示
            updateConnectionStatus(status) {
                const statusEl = document.getElementById('connection-status');
                if (statusEl) {
                    statusEl.textContent = status;
                    statusEl.className = 'connection-status ' +
                        (this.isConnected ? 'connected' : 'disconnected');
                }
            }
        }

        // 全局WebSocket管理器实例
        const wsManager = new WebSocketManager();

        // 工具函数
        function copyModuleName(moduleName) {
            navigator.clipboard.writeText(moduleName).then(() => {
                console.log('📋 已复制模块名称:', moduleName);
                // 临时高亮显示
                const tag = event.target;
                tag.classList.add('copied');
                setTimeout(() => tag.classList.remove('copied'), 1000);
            }).catch(err => {
                console.error('复制失败:', err);
            });
        }

        function copyAllModules() {
            const moduleNames = Array.from(webLogState.moduleData.keys()).sort();
            const text = moduleNames.join('\n');

            navigator.clipboard.writeText(text).then(() => {
                console.log('📋 已复制所有模块名称');
                const button = document.getElementById('header-copy-modules');
                button.classList.add('copied');
                button.textContent = '✅ 已复制';
                setTimeout(() => {
                    button.classList.remove('copied');
                    button.textContent = '🔥 复制全部模块';
                }, 2000);
            }).catch(err => {
                console.error('复制失败:', err);
            });
        }

        function toggleRealtimeLogs() {
            const realtimeModule = document.getElementById('realtime-logs-module');
            const rawLogsModule = document.getElementById('raw-logs-module');
            const button = document.getElementById('toggle-realtime-logs');

            // 检查实时日志模块当前是否是隐藏的
            if (realtimeModule.style.display === 'none') {
                // 如果是隐藏的，就显示它，并【隐藏】另一个
                realtimeModule.style.display = 'flex';
                rawLogsModule.style.display = 'none'; // <-- 关键：隐藏高频折叠模块

                button.classList.add('active');
                button.textContent = '📊 显示高频折叠日志'; // <-- 修改按钮文本，更符合当前状态
            } else {
                // 如果是显示的，就隐藏它，并【显示】另一个
                realtimeModule.style.display = 'none';
                rawLogsModule.style.display = 'flex'; // <-- 关键：显示高频折叠模块

                button.classList.remove('active');
                button.textContent = '📊 显示实时原始日志'; // <-- 恢复按钮默认文本
            }

            // 【重要】切换显示后，需要让两个模块的终端重新计算尺寸
            // 因为模块的尺寸发生了变化，xterm.js需要重新适配
            // 我们延迟执行以确保DOM更新完成
            setTimeout(() => {
                try {
                    if (rawLogsModule.style.display !== 'none') {
                        terminalManager.fitAddons.get('raw-logs')?.fit();
                    }
                    if (realtimeModule.style.display !== 'none') {
                        terminalManager.fitAddons.get('realtime-logs')?.fit();
                    }
                } catch(e) {
                    console.error("Error fitting terminal:", e);
                }
            }, 10);
        }

        // 页面初始化
        window.addEventListener('load', function() {
            // ================== 插件加载状态诊断 ==================
            console.log('--- 插件加载状态诊断 ---');
            console.log('1. Terminal 核心库:', typeof Terminal);
            console.log('2. FitAddon 插件对象:', window.FitAddon);
            console.log('3. WebLinksAddon 插件对象:', window.WebLinksAddon);
            // 修正了诊断代码，检查正确的全局变量 SearchAddon
            console.log('4. SearchAddon 插件对象 (关键):', window.SearchAddon);

            // 更详细的 SearchAddon 诊断
            if (window.SearchAddon) {
                console.log('   SearchAddon 详细信息:');
                console.log('   - 类型:', typeof window.SearchAddon);
                console.log('   - 属性:', Object.keys(window.SearchAddon));
                console.log('   - SearchAddon 构造函数类型:', typeof window.SearchAddon.SearchAddon);
            } else {
                console.log('   ❌ SearchAddon 完全未定义');

                // 检查是否有其他可能的全局变量名
                console.log('5. 检查其他可能的搜索插件全局变量:');
                console.log('   - window.XtermAddonSearch:', window.XtermAddonSearch);
                console.log('   - window.AddonSearch:', window.AddonSearch);
                console.log('   - window.xtermAddonSearch:', window.xtermAddonSearch);

                // 检查所有以 'Search' 开头的全局变量
                const searchGlobals = Object.keys(window).filter(key => key.toLowerCase().includes('search'));
                console.log('   - 所有包含"search"的全局变量:', searchGlobals);

                // 检查脚本是否成功加载
                const scripts = Array.from(document.querySelectorAll('script[src*="addon-search"]'));
                console.log('   - 搜索插件脚本标签:', scripts.map(s => ({src: s.src, loaded: s.readyState || 'unknown'})));
            }

            console.log('--- 诊断结束 ---');
            // =======================================================

            console.log('🎯 页面及所有资源加载完成，初始化WebLog系统');

            // 初始化终端
            terminalManager.initializeStaticTerminals();

            // 绑定事件
            document.getElementById('header-copy-modules').addEventListener('click', copyAllModules);
            document.getElementById('toggle-realtime-logs').addEventListener('click', toggleRealtimeLogs);

            // 连接WebSocket
            wsManager.connect();

            console.log('✅ WebLog前端聚合系统初始化完成');

            // 添加窗口大小调整的监听器，以重新适配所有终端
            let resizeTimer;
            window.addEventListener('resize', () => {
                // 使用节流防止高频触发
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(() => {
                    console.log('🔄 窗口大小改变，适配所有终端');
                    terminalManager.fitAddons.forEach(fitAddon => {
                        try {
                            fitAddon.fit();
                        } catch (e) {
                            // 忽略可能的错误，例如当终端容器被隐藏时
                        }
                    });
                }, 250); // 250ms延迟
            });
        });
    </script>
</body>
</html>
