<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K线聚合系统 - 模块监控 v6.0 (Xterm.js 5.5.0 + 无自动滚动)</title>

    <!-- Xterm.js CSS - 升级到最新版本 5.5.0 -->
    <link rel="stylesheet" href="https://unpkg.com/@xterm/xterm@5.5.0/css/xterm.css" />

    <!-- Xterm.js JavaScript - 升级到最新版本，使用新的 @xterm 作用域 -->
    <script src="https://cdn.jsdelivr.net/npm/@xterm/xterm@5.5.0/lib/xterm.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@xterm/addon-fit@0.10.0/lib/addon-fit.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@xterm/addon-web-links@0.11.0/lib/addon-web-links.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            background-color: #1a1a1a;
            color: #00ff00;
            padding: 10px;
            font-size: 16px;
            line-height: 1.5;
        }

        .header {
            padding: 5px 10px;
            border-bottom: 2px solid #333;
            margin-bottom: 10px;
        }

        .header-top-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 15px;
            flex-wrap: wrap;
        }

        .header h1 {
            color: #00ffff;
            font-size: 18px;
            margin: 0;
            flex-shrink: 0;
        }

        .header-buttons {
            display: flex;
            gap: 10px;
            flex-shrink: 0;
        }

        .main-content {
            display: flex;
            gap: 15px;
            height: calc(100vh - 120px); /* 减少头部预留空间到120px */
        }

        .static-modules-area {
            flex: 0 0 820px; /* 固定宽度820px，考虑边框和内边距 */
            display: flex;
            flex-direction: column;
            gap: 10px;
            height: 100%; /* 确保占满父容器高度 */
            border: 2px solid #444; /* 添加边框 */
            border-radius: 8px; /* 圆角 */
            padding: 10px; /* 内边距 */
            background-color: #0f0f0f; /* 稍微不同的背景色以区分 */
        }

        .static-modules-title {
            color: #00ffff;
            font-size: 14px;
            font-weight: bold;
            text-align: center;
            padding: 5px 0;
            border-bottom: 1px solid #444;
            margin-bottom: 5px;
            flex-shrink: 0;
        }

        .static-modules-content {
            flex: 1;
            display: flex;
            gap: 15px;
            min-height: 0; /* 允许flex子项收缩 */
        }

        .dynamic-modules-area {
            flex: 1;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 15px;
            overflow-y: auto;
            height: 100%; /* 确保占满父容器高度 */
        }

        .module {
            border: 1px solid #333;
            border-radius: 5px;
            background-color: #0a0a0a;
            display: flex;
            flex-direction: column;
        }

        .static-module {
            flex: 1; /* 在静态区域中平分空间 */
            display: flex;
            flex-direction: column;
            min-height: 0; /* 允许flex子项收缩 */
        }

        /* 静态模块区域的特殊样式 */
        .static-modules-area .module-header {
            background-color: #1a1a2e;
            border-bottom: 2px solid #16213e;
            flex-shrink: 0; /* 防止头部被压缩 */
        }

        .static-modules-area .module-title {
            color: #0ff;
            font-weight: bold;
        }

        .static-modules-area .module-stats {
            flex-shrink: 0; /* 防止统计区域被压缩 */
        }

        .static-modules-area .module-terminal {
            flex: 1; /* 终端区域占用剩余空间 */
            /* 移除固定最小高度，完全依赖flex布局自动计算 */
        }

        .module-header {
            padding: 8px 12px;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .module-title {
            font-weight: bold;
            font-size: 16px;
            color: #00ffff;
        }

        .module-status {
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }

        .status-running { background-color: #006600; color: #00ff00; }
        .status-waiting { background-color: #666600; color: #ffff00; }
        .status-error { background-color: #660000; color: #ff0000; }
        .status-disconnected { background-color: #663300; color: #ff9900; }

        .module-stats {
            padding: 10px 15px;
            border-bottom: 1px solid #333;
            font-size: 13px;
            color: #cccccc;
        }

        .stat-line {
            display: flex;
            justify-content: space-between;
            margin-bottom: 2px;
        }

        /* Xterm.js 终端容器样式 */
        .module-terminal {
            flex: 1;
            padding: 5px;
            background-color: #000000;
            overflow: hidden;
            min-height: 100px; /* 减少最小高度，主要依赖flex布局 */
        }

        /* 自定义 Xterm.js 主题 */
        .xterm {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace !important;
            font-size: 13px !important;
        }

        .xterm .xterm-viewport {
            background-color: #000000 !important;
        }

        .xterm .xterm-screen {
            background-color: #000000 !important;
        }

        .connection-status {
            position: fixed;
            top: 15px;
            right: 15px;
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 14px;
            font-weight: bold;
        }

        .connected { background-color: #006600; color: #00ff00; }
        .disconnected { background-color: #660000; color: #ff0000; }

        /* 顶部按钮样式 */
        .header-copy-button {
            background-color: #ff6600;
            color: #ffffff;
            border: 2px solid #ff8833;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-family: 'Consolas', monospace;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 6px rgba(255, 102, 0, 0.4);
        }

        .header-copy-button:hover {
            background-color: #ff8833;
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(255, 102, 0, 0.6);
        }

        .header-copy-button.copied {
            background-color: #44ff44;
            color: #000000;
            border-color: #66ff66;
        }

        .header-toggle-button {
            background-color: #0066ff;
            color: #ffffff;
            border: 2px solid #3388ff;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-family: 'Consolas', monospace;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 6px rgba(0, 102, 255, 0.4);
        }

        .header-toggle-button:hover {
            background-color: #3388ff;
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0, 102, 255, 0.6);
        }

        .header-toggle-button.active {
            background-color: #44ff44;
            color: #000000;
            border-color: #66ff66;
            box-shadow: 0 2px 6px rgba(68, 255, 68, 0.4);
        }

        /* 模块名称显示区域样式 - 紧凑版 */
        .module-names-section {
            flex: 1;
            min-width: 300px;
        }

        .module-names-header {
            color: #00ffff;
            font-size: 14px;
            font-weight: bold;
            margin: 0 0 5px 0;
        }

        .module-names-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            align-items: center;
        }

        .module-name-tag {
            background-color: #1a4a1a;
            color: #00ff00;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
            font-family: 'Consolas', monospace;
            cursor: pointer;
            border: 1px solid #006600;
            transition: all 0.2s ease;
        }

        .module-name-tag:hover {
            background-color: #2a5a2a;
            border-color: #00ff00;
            transform: scale(1.05);
        }

        .module-name-tag.copied {
            background-color: #4a4a1a;
            color: #ffff00;
            border-color: #ffff00;
        }

        .no-modules {
            color: #666;
            font-style: italic;
            font-size: 12px;
        }

        /* 确保页面布局稳定性 */
        html, body {
            height: 100%;
            overflow-x: hidden;
        }

        /* 动态模块的样式优化 */
        .dynamic-modules-area .module {
            min-height: 400px; /* 动态模块最小高度 */
        }

        /* 响应式调整 */
        @media (max-width: 1200px) {
            .static-modules-area {
                flex: 0 0 600px; /* 小屏幕时减少静态区域宽度 */
            }

            .static-modules-area .module-terminal {
                min-height: 200px; /* 小屏幕时减少最小高度 */
            }
        }
    </style>
</head>
<body>
    <div class="connection-status" id="connection-status">连接中...</div>

    <div class="header">
        <div class="header-top-row">
            <h1>K线聚合系统 - 模块监控 v6</h1>

            <!-- 模块名称显示区域 -->
            <div class="module-names-section">
                
                <div class="module-names-list" id="module-names-list">
                    <span class="no-modules">暂无模块数据</span>
                </div>
            </div>

            <div class="header-buttons">
                <button class="header-copy-button" id="header-copy-modules" title="复制所有模块名称">🔥 复制全部模块</button>
                <button class="header-toggle-button" id="toggle-realtime-logs" title="显示/隐藏实时原始日志">📊 显示实时原始日志</button>
            </div>
        </div>
    </div>

    <div class="main-content">
        <!-- 左侧静态模块区域 -->
        <div class="static-modules-area">
            <div class="static-modules-title">📊 静态模块区域 - 日志监控</div>
            <div class="static-modules-content">
                <!-- 实时原始日志模块 (默认隐藏) -->
                <div class="module static-module" id="realtime-logs-module" style="display: none;">
                    <div class="module-header">
                        <div class="module-title">实时原始日志 (RealtimeLogs)</div>
                        <div class="module-status status-waiting" id="realtime-logs-status">等待日志</div>
                    </div>
                    <div class="module-stats">
                        <div class="stat-line">
                            <span>实时日志数:</span>
                            <span id="realtime-log-count">0</span>
                        </div>
                        <div class="stat-line">
                            <span>最后更新:</span>
                            <span id="last-log-time">--:--:--</span>
                        </div>
                        <div class="stat-line">
                            <span>日志频率:</span>
                            <span id="log-frequency">-- 条/秒</span>
                        </div>
                    </div>
                    <div class="module-terminal" id="realtime-logs-terminal"></div>
                </div>

                <!-- 原始日志快照模块 -->
                <div class="module static-module" id="raw-logs-module">
                    <div class="module-header">
                        <div class="module-title">原始日志高频折叠 (RawLogSnapshot)</div>
                        <div class="module-status status-waiting" id="raw-logs-status">等待折叠</div>
                    </div>
                    <div class="module-stats">
                        <div class="stat-line">
                            <span>折叠时间:</span>
                            <span id="snapshot-timestamp">--:--:--</span>
                        </div>
                        <div class="stat-line">
                            <span>原始日志数:</span>
                            <span id="total-log-count">--</span>
                        </div>
                        <div class="stat-line">
                            <span>折叠后条数:</span>
                            <span id="displayed-log-count">--</span>
                        </div>
                    </div>
                    <div class="module-terminal" id="raw-logs-terminal"></div>
                </div>

            </div>
        </div>

        <!-- 右侧动态模块区域 -->
        <div class="dynamic-modules-area" id="dynamic-modules-container">
            <!-- 动态模块将在这里创建 -->
        </div>
    </div>

    <script>
        // Xterm.js 终端管理 (最终版：新日志显示在顶部)
        class TerminalManager {
            constructor() {
                this.terminals = new Map();
                this.fitAddons = new Map();
                this.logBuffers = new Map(); // 存储每个模块的日志缓冲区
                this.maxLines = 10000000;

                this.terminalTheme = {
                    background: '#000000',
                    foreground: '#00ff00',
                    cursor: '#00ff00',
                    cursorAccent: '#000000',
                    selection: 'rgba(255, 255, 255, 0.3)',
                    black: '#000000',
                    red: '#ff0000',
                    green: '#00ff00',
                    yellow: '#ffff00',
                    blue: '#0066ff',
                    magenta: '#ff00ff',
                    cyan: '#00ffff',
                    white: '#ffffff',
                    brightBlack: '#666666',
                    brightRed: '#ff6666',
                    brightGreen: '#66ff66',
                    brightYellow: '#ffff66',
                    brightBlue: '#6666ff',
                    brightMagenta: '#ff66ff',
                    brightCyan: '#66ffff',
                    brightWhite: '#ffffff'
                };
            }

            // 创建新的终端实例
            createTerminal(containerId, moduleName) {
                const container = document.getElementById(containerId);
                if (!container) {
                    console.error(`找不到容器: ${containerId}`);
                    return null;
                }

                const terminal = new Terminal({
                    theme: this.terminalTheme,
                    fontFamily: 'Consolas, Monaco, "Courier New", monospace',
                    fontSize: 13,
                    lineHeight: 1.2,
                    cursorBlink: false,
                    scrollback: this.maxLines,
                    convertEol: true,
                    disableStdin: true, // 禁用输入，只用于显示
                    allowTransparency: true,
                    // 1GB 写入缓冲区，支持大量日志
                    writeBufferSize: 1024 * 1024 * 1024
                });

                // 正确实例化 v5 插件
                const fitAddon = new FitAddon.FitAddon();
                const webLinksAddon = new WebLinksAddon.WebLinksAddon();

                // 加载插件
                terminal.loadAddon(fitAddon);
                terminal.loadAddon(webLinksAddon);

                // 无需任何滚动状态管理和检测
                // 用户完全控制滚动条位置

                // 打开终端
                terminal.open(container);

                // 立即调整大小以填满容器
                setTimeout(() => fitAddon.fit(), 0);

                // 存储实例
                this.terminals.set(moduleName, terminal);
                this.fitAddons.set(moduleName, fitAddon);
                this.logBuffers.set(moduleName, []); // 初始化日志缓冲区

                console.log(`✅ 为模块 [${moduleName}] 创建了新日志显示在顶部的终端`);
                return terminal;
            }

            // 获取终端实例
            getTerminal(moduleName) {
                return this.terminals.get(moduleName);
            }

            // 向终端写入日志 (命令行惯例：新日志在底部)
            writeLog(moduleName, logText, level = 'INFO') {
                const terminal = this.getTerminal(moduleName);
                if (!terminal) {
                    console.warn(`终端不存在: ${moduleName}`);
                    return;
                }

                // 根据日志级别设置颜色
                let colorCode = '';
                switch (level.toUpperCase()) {
                    case 'ERROR': colorCode = '\x1b[31m'; break; // 红色
                    case 'WARN':  colorCode = '\x1b[33m'; break; // 黄色
                    case 'INFO':  colorCode = '\x1b[32m'; break; // 绿色
                    case 'DEBUG': colorCode = '\x1b[36m'; break; // 青色
                    default:      colorCode = '\x1b[37m'; break; // 白色
                }

                const resetCode = '\x1b[0m'; // 重置颜色
                const formattedLog = `${colorCode}${logText}${resetCode}`;

                // 获取日志缓冲区
                let logBuffer = this.logBuffers.get(moduleName);
                if (!logBuffer) {
                    logBuffer = [];
                    this.logBuffers.set(moduleName, logBuffer);
                }

                // 将新日志追加到缓冲区底部（命令行惯例）
                logBuffer.push(formattedLog);

                // 限制缓冲区大小，防止内存溢出（移除最老的日志）
                if (logBuffer.length > this.maxLines) {
                    logBuffer.shift(); // 移除最老的日志（数组开头）
                }

                // 直接追加到终端底部，无需刷新整个终端
                terminal.write(formattedLog + '\r\n');
            }

            // 刷新终端显示（带流控制）
            refreshTerminal(moduleName) {
                const terminal = this.getTerminal(moduleName);
                const logBuffer = this.logBuffers.get(moduleName);

                if (!terminal || !logBuffer) {
                    return;
                }

                // 清空终端
                terminal.clear();

                // 分批写入日志以避免缓冲区溢出
                this.writeLogsInBatches(terminal, logBuffer);
            }

            // 直接写入所有日志到终端
            writeLogsInBatches(terminal, logBuffer) {
                if (!logBuffer || logBuffer.length === 0) {
                    return;
                }

                try {
                    // 直接写入所有日志，不分批
                    logBuffer.forEach(formattedLog => {
                        terminal.write(formattedLog + '\r\n');
                    });
                    // 只在历史日志加载时显示日志，新日志追加时不显示
                    // console.log(`🔄 [${moduleName}] 刷新终端，写入 ${logBuffer.length} 条日志`);
                } catch (error) {
                    console.error(`❌ 写入日志失败: ${error.message}`);
                }
            }

            // 清空终端
            clearTerminal(moduleName) {
                const terminal = this.getTerminal(moduleName);
                if (terminal) {
                    terminal.clear();
                    // 同时清空日志缓冲区
                    this.logBuffers.set(moduleName, []);
                }
            }

            // 调整终端大小
            resizeTerminal(moduleName) {
                const fitAddon = this.fitAddons.get(moduleName);
                if (fitAddon && fitAddon.fit) {
                    fitAddon.fit();
                } else {
                    console.log(`模块 ${moduleName} 的FitAddon不可用`);
                }
            }

            // 销毁终端
            destroyTerminal(moduleName) {
                const terminal = this.getTerminal(moduleName);
                if (terminal) {
                    terminal.dispose();
                    this.terminals.delete(moduleName);
                    this.fitAddons.delete(moduleName);
                    this.logBuffers.delete(moduleName); // 清理日志缓冲区
                }
            }
        }

        // 全局终端管理器实例
        const terminalManager = new TerminalManager();

        // WebSocket连接管理
        let ws = null;
        let reconnectInterval = null;
        let createdModules = new Set();
        let currentModuleNames = [];
        let isInitialDataLoaded = false; // 标记是否已加载初始历史数据

        // 初始化固定终端
        function initializeFixedTerminals() {
            // 创建原始日志快照终端
            terminalManager.createTerminal('raw-logs-terminal', 'RawLogSnapshot');

            console.log('🚀 固定终端初始化完成');
        }

        // WebSocket连接函数
        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws`;

            ws = new WebSocket(wsUrl);

            ws.onopen = function() {
                console.log('🔗 WebSocket已连接');
                updateConnectionStatus(true);
                // 重置初始数据加载标志，准备接收新的历史数据
                isInitialDataLoaded = false;
                if (reconnectInterval) {
                    clearInterval(reconnectInterval);
                    reconnectInterval = null;
                }
            };

            ws.onmessage = function(event) {
                try {
                    const message = JSON.parse(event.data);

                    // 处理不同类型的消息
                    if (message.type === 'SystemStatus') {
                        // 处理系统状态更新（低频）
                        updateSystemStatus(message.data);
                    } else if (message.type === 'LogEntry') {
                        // 处理单个日志条目 - 立即增量显示
                        const logEntry = message.data;
                        addLogEntryIncremental(logEntry);
                    } else if (message.type === 'DashboardUpdate') {
                        // 处理聚合数据更新 - 更新统计信息和原始日志快照
                        updateDashboardData(message.data);
                    } else {
                        console.log('未知消息类型:', message.type);
                    }
                } catch (e) {
                    console.error('解析WebSocket消息失败:', e);
                }
            };

            ws.onclose = function() {
                console.log('WebSocket连接已关闭');
                updateConnectionStatus(false);
                if (!reconnectInterval) {
                    reconnectInterval = setInterval(connectWebSocket, 5000);
                }
            };

            ws.onerror = function(error) {
                console.error('WebSocket错误:', error);
                updateConnectionStatus(false);
            };
        }

        // 更新连接状态
        function updateConnectionStatus(connected) {
            const statusEl = document.getElementById('connection-status');

            if (connected) {
                statusEl.textContent = '已连接';
                statusEl.className = 'connection-status connected';
            } else {
                statusEl.textContent = '连接断开';
                statusEl.className = 'connection-status disconnected';
            }
        }

        // 处理系统状态更新（简化版 - 仅记录日志）
        function updateSystemStatus(data) {
            console.log('📊 收到系统状态更新:', data);
            // 系统状态信息已从界面移除，仅保留日志记录
        }

        // 处理聚合数据更新
        function updateDashboardData(data) {
           // console.log('📈 收到聚合数据更新:', data);

            // 更新聚合日志视图 (持续更新的全量数据)
            if (data.raw_log_snapshot) {
                const aggregatedData = data.raw_log_snapshot;

                // 更新统计信息
                if (aggregatedData.timestamp) {
                    document.getElementById('snapshot-timestamp').textContent = aggregatedData.timestamp;
                }
                if (aggregatedData.total_count !== undefined) {
                    document.getElementById('total-log-count').textContent = aggregatedData.total_count;
                }
                if (aggregatedData.logs && aggregatedData.logs.length !== undefined) {
                    document.getElementById('displayed-log-count').textContent = aggregatedData.logs.length;
                }

                // 更新状态为运行中
                const statusEl = document.getElementById('raw-logs-status');
                if (statusEl) {
                    statusEl.textContent = '运行中';
                    statusEl.className = 'module-status status-running';
                }

                // 关键修复：每次收到数据都刷新终端内容
                // 因为此模块的数据是全量下发的，所以每次都需要完全替换
                if (aggregatedData.logs) { // 只要有logs字段就刷新，即使是空数组也要清空终端
                    loadHistoryRawLogsToTerminal('RawLogSnapshot', aggregatedData.logs);
                }
            }

            // 处理模块数据（统一的显示日志）
            if (data.module_logs) {
                for (const [moduleName, moduleData] of Object.entries(data.module_logs)) {
                    // 确保模块容器存在
                    ensureModuleContainer(moduleName);

                    // 更新模块统计信息
                    updateModuleStatsFromData(moduleName, moduleData);

                    // 只在初始连接时加载历史数据
                    if (!isInitialDataLoaded) {
                        // 加载统一的显示日志（包含普通日志和聚合日志）
                        if (moduleData.display_logs && moduleData.display_logs.length > 0) {
                            loadHistoryDisplayLogsToTerminal(moduleName, moduleData.display_logs);
                        }
                    }

                    // 更新模块名称列表
                    updateModuleNamesList([moduleName]);
                }
            }

            // 标记初始数据已加载
            if (!isInitialDataLoaded) {
                isInitialDataLoaded = true;
                console.log('✅ 初始历史数据加载完成');
            }
        }
        // 加载历史日志到终端（用于字符串格式的日志）
        function loadHistoryLogsToTerminal(moduleName, historyLogs) {
            const terminal = terminalManager.getTerminal(moduleName);
            if (!terminal || !historyLogs || historyLogs.length === 0) {
                return;
            }

            console.log(`📚 为模块 [${moduleName}] 加载 ${historyLogs.length} 条历史日志`);

            // 清空终端和缓冲区
            terminalManager.clearTerminal(moduleName);

            // 按照命令行惯例：最老的日志在上方，最新的在下方
            // 如果后端发送的是最新在前的顺序，需要反转
            // 先检查并调试历史日志的顺序
            console.log(`🔍 [${moduleName}] 历史日志顺序检查:`, {
                总数: historyLogs.length,
                第一条: historyLogs[0]?.substring(0, 50) + '...',
                最后一条: historyLogs[historyLogs.length - 1]?.substring(0, 50) + '...'
            });

            // 反转历史日志顺序，确保最老的在上方
            const orderedLogs = [...historyLogs].reverse();

            const logBuffer = terminalManager.logBuffers.get(moduleName) || [];
            orderedLogs.forEach(logText => {
                const level = extractLogLevelFromText(logText);
                const colorCode = getColorCodeForLevel(level);
                const resetCode = '\x1b[0m';
                const formattedLog = `${colorCode}${logText}${resetCode}`;
                logBuffer.push(formattedLog); // 追加到底部
            });
            terminalManager.logBuffers.set(moduleName, logBuffer);

            // 刷新终端显示
            terminalManager.refreshTerminal(moduleName);
            console.log(`📍 模块 [${moduleName}] 历史日志加载完成，新日志将显示在底部`);
        }

        // 获取日志级别对应的颜色代码
        function getColorCodeForLevel(level) {
            switch (level.toUpperCase()) {
                case 'ERROR': return '\x1b[31m'; // 红色
                case 'WARN':  return '\x1b[33m'; // 黄色
                case 'INFO':  return '\x1b[32m'; // 绿色
                case 'DEBUG': return '\x1b[36m'; // 青色
                case 'AGGREGATE': return '\x1b[93m'; // 亮黄色（高频聚合）
                default:      return '\x1b[37m'; // 白色
            }
        }

        // 加载历史显示日志到终端（用于DisplayLogEntry格式的日志）
        function loadHistoryDisplayLogsToTerminal(moduleName, displayLogs) {
            const terminal = terminalManager.getTerminal(moduleName);
            if (!terminal || !displayLogs || displayLogs.length === 0) {
                return;
            }

            console.log(`📚 为模块 [${moduleName}] 加载 ${displayLogs.length} 条历史显示日志`);

            // 清空终端和缓冲区
            terminalManager.clearTerminal(moduleName);

            // 按照命令行惯例：最老的日志在上方，最新的在下方
            // 检查显示日志的时间戳顺序
            if (displayLogs.length > 1) {
                const firstTime = new Date(displayLogs[0].timestamp);
                const lastTime = new Date(displayLogs[displayLogs.length - 1].timestamp);
                console.log(`🔍 [${moduleName}] 显示日志时间顺序:`, {
                    总数: displayLogs.length,
                    第一条时间: firstTime.toLocaleTimeString(),
                    最后一条时间: lastTime.toLocaleTimeString(),
                    是否需要反转: firstTime > lastTime ? '是' : '否'
                });
            }

            // 根据时间戳排序，确保最老的在前面
            const orderedDisplayLogs = [...displayLogs].sort((a, b) =>
                new Date(a.timestamp) - new Date(b.timestamp)
            );

            const logBuffer = terminalManager.logBuffers.get(moduleName) || [];
            orderedDisplayLogs.forEach(displayEntry => {
                const timestamp = new Date(displayEntry.timestamp).toLocaleTimeString();
                // 聚合日志的消息已经包含了聚合信息，不需要额外添加
                const logText = `[${timestamp}] ${displayEntry.level} ${displayEntry.message}`;

                // 聚合日志使用特殊颜色
                const level = displayEntry.is_aggregated ? 'AGGREGATE' : displayEntry.level;
                const colorCode = getColorCodeForLevel(level);
                const resetCode = '\x1b[0m';
                const formattedLog = `${colorCode}${logText}${resetCode}`;
                logBuffer.push(formattedLog); // 追加到底部
            });
            terminalManager.logBuffers.set(moduleName, logBuffer);

            // 刷新终端显示
            terminalManager.refreshTerminal(moduleName);
            console.log(`📍 模块 [${moduleName}] 历史显示日志加载完成，新日志将显示在底部`);
        }

        // 加载原始日志快照到终端
        function loadHistoryRawLogsToTerminal(moduleName, rawLogs) {
            const terminal = terminalManager.getTerminal(moduleName);
            if (!terminal || !rawLogs || rawLogs.length === 0) {
                return;
            }

            console.log(`📚 为模块 [${moduleName}] 加载 ${rawLogs.length} 条原始日志快照`);

            // 清空终端和缓冲区
            terminalManager.clearTerminal(moduleName);

            const logBuffer = terminalManager.logBuffers.get(moduleName) || [];
            rawLogs.forEach(logText => {
                // 从日志文本中提取级别并应用相应颜色
                const level = extractLogLevelFromText(logText);

                // 检查是否是聚合日志
                const isAggregated = logText.includes('🔄') && logText.includes('聚合');
                const finalLevel = isAggregated ? 'AGGREGATE' : level;

                const colorCode = getColorCodeForLevel(finalLevel);
                const resetCode = '\x1b[0m';
                const formattedLog = `${colorCode}${logText}${resetCode}`;
                logBuffer.push(formattedLog);
            });
            terminalManager.logBuffers.set(moduleName, logBuffer);

            // 刷新终端显示
            terminalManager.refreshTerminal(moduleName);
            console.log(`📍 模块 [${moduleName}] 原始日志快照加载完成`);
        }





        // 从文本中提取日志级别
        function extractLogLevelFromText(logText) {
            if (typeof logText === 'string') {
                if (logText.includes('ERROR')) return 'ERROR';
                if (logText.includes('WARN')) return 'WARN';
                if (logText.includes('INFO')) return 'INFO';
                if (logText.includes('DEBUG')) return 'DEBUG';
            }
            return 'INFO';
        }

        // 从数据更新模块统计信息
        function updateModuleStatsFromData(moduleName, moduleData) {
            const containerId = getModuleContainerId(moduleName);

            // 更新总日志数
            const totalEl = document.getElementById(`${containerId}-total`);
            if (totalEl && moduleData.total_logs !== undefined) {
                totalEl.textContent = moduleData.total_logs;
            }

            // 更新错误数
            const errorsEl = document.getElementById(`${containerId}-errors`);
            if (errorsEl && moduleData.error_count !== undefined) {
                errorsEl.textContent = moduleData.error_count;
            }

            // 更新最后更新时间
            const lastUpdateEl = document.getElementById(`${containerId}-last-update`);
            if (lastUpdateEl) {
                lastUpdateEl.textContent = new Date().toLocaleTimeString();
            }

            // 更新状态为运行中
            const statusEl = document.getElementById(`${containerId}-status`);
            if (statusEl) {
                statusEl.textContent = '运行中';
                statusEl.className = 'module-status status-running';
            }
        }









        // 确保模块容器存在
        function ensureModuleContainer(moduleName) {
            if (createdModules.has(moduleName)) {
                return; // 模块已存在
            }

            console.log('🆕 创建模块:', moduleName);
            const containerId = getModuleContainerId(moduleName);
            const terminalId = containerId + '-terminal';

            // 创建模块容器
            const moduleDiv = document.createElement('div');
            moduleDiv.className = 'module';
            moduleDiv.innerHTML = `
                <div class="module-header">
                    <div class="module-title">${moduleName}</div>
                    <div class="module-status status-running" id="${containerId}-status">运行中</div>
                </div>
                <div class="module-stats">
                    <div class="stat-line">
                        <span>总日志数:</span>
                        <span id="${containerId}-total">0</span>
                    </div>
                    <div class="stat-line">
                        <span>错误数:</span>
                        <span id="${containerId}-errors">0</span>
                    </div>
                    <div class="stat-line">
                        <span>最后更新:</span>
                        <span id="${containerId}-last-update">--:--:--</span>
                    </div>
                </div>
                <div class="module-terminal" id="${terminalId}"></div>
            `;

            // 添加到动态模块容器中
            const dynamicModulesContainer = document.querySelector('.dynamic-modules-area');
            dynamicModulesContainer.appendChild(moduleDiv);

            // 创建终端
            terminalManager.createTerminal(terminalId, moduleName);

            createdModules.add(moduleName);
        }

        // 更新固定模块状态
        function updateFixedModuleStatus() {
            // 更新原始快照模块状态
            const rawLogsStatusEl = document.getElementById('raw-logs-status');
            if (rawLogsStatusEl) {
                rawLogsStatusEl.textContent = '运行中';
                rawLogsStatusEl.className = 'module-status status-running';
            }
        }



        // 增量添加日志条目 - 简化版（主要通过 DashboardUpdate 处理）
        function addLogEntryIncremental(logEntry) {
            // 只处理未被聚合的日志，直接添加到对应模块终端
            const moduleName = logEntry.target || 'unknown';
            ensureModuleContainer(moduleName);

            const logText = formatLogEntry(logEntry);
            const level = extractLogLevel(logEntry);
            terminalManager.writeLog(moduleName, logText, level);

            // 更新固定模块状态
            updateFixedModuleStatus();

            // 更新模块名称列表
            updateModuleNamesList([moduleName]);

            // 更新统计信息
            updateModuleStats(moduleName, logEntry);
        }

        // 格式化日志条目
        function formatLogEntry(logEntry) {
            if (typeof logEntry === 'string') {
                return logEntry;
            }

            if (logEntry.message) {
                const timestamp = logEntry.timestamp ? new Date(logEntry.timestamp).toLocaleTimeString() : '';
                const level = logEntry.level || 'INFO';
                const module = logEntry.module || '';

                if (timestamp && module) {
                    return `[${timestamp}] ${level} ${module}: ${logEntry.message}`;
                } else if (timestamp) {
                    return `[${timestamp}] ${level}: ${logEntry.message}`;
                } else {
                    return `${level}: ${logEntry.message}`;
                }
            }

            return JSON.stringify(logEntry);
        }

        // 提取日志级别
        function extractLogLevel(logEntry) {
            if (typeof logEntry === 'object' && logEntry.level) {
                return logEntry.level.toUpperCase();
            }

            if (typeof logEntry === 'string') {
                if (logEntry.includes('ERROR')) return 'ERROR';
                if (logEntry.includes('WARN')) return 'WARN';
                if (logEntry.includes('INFO')) return 'INFO';
                if (logEntry.includes('DEBUG')) return 'DEBUG';
            }

            return 'INFO';
        }

        // 获取模块容器ID
        function getModuleContainerId(moduleName) {
            return 'module-' + moduleName.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase();
        }

        // 更新模块名称列表（增量版本）
        function updateModuleNamesList(newModuleNames) {
            const container = document.getElementById('module-names-list');

            // 合并新模块名到现有列表
            newModuleNames.forEach(moduleName => {
                if (!currentModuleNames.includes(moduleName)) {
                    currentModuleNames.push(moduleName);

                    // 创建新的模块标签
                    const tag = document.createElement('span');
                    tag.className = 'module-name-tag';
                    tag.textContent = moduleName;
                    tag.title = '点击复制模块名称';
                    tag.id = `module-tag-${moduleName}`;

                    // 添加点击复制功能
                    tag.addEventListener('click', function() {
                        copyToClipboard(moduleName, tag);
                    });

                    // 如果容器是空的，先清空"暂无模块"提示
                    if (container.querySelector('.no-modules')) {
                        container.innerHTML = '';
                    }

                    container.appendChild(tag);
                }
            });
        }

        // 更新模块统计信息（增量版本）
        function updateModuleStats(moduleName, logEntry) {
            const containerId = getModuleContainerId(moduleName);

            // 更新总日志数
            const totalEl = document.getElementById(`${containerId}-total`);
            if (totalEl) {
                const current = parseInt(totalEl.textContent) || 0;
                totalEl.textContent = current + 1;
            }

            // 更新错误数
            if (logEntry.level === 'ERROR') {
                const errorsEl = document.getElementById(`${containerId}-errors`);
                if (errorsEl) {
                    const current = parseInt(errorsEl.textContent) || 0;
                    errorsEl.textContent = current + 1;
                }
            }

            // 更新最后更新时间
            const lastUpdateEl = document.getElementById(`${containerId}-last-update`);
            if (lastUpdateEl) {
                lastUpdateEl.textContent = new Date().toLocaleTimeString();
            }

            // 更新状态为运行中
            const statusEl = document.getElementById(`${containerId}-status`);
            if (statusEl) {
                statusEl.textContent = '运行中';
                statusEl.className = 'module-status status-running';
            }
        }

        // 复制到剪贴板功能
        function copyToClipboard(text, element) {
            navigator.clipboard.writeText(text).then(function() {
                // 显示复制成功的视觉反馈
                element.classList.add('copied');
                const originalText = element.textContent;
                element.textContent = '已复制!';

                setTimeout(function() {
                    element.classList.remove('copied');
                    element.textContent = originalText;
                }, 1000);
            }).catch(function(err) {
                console.error('复制失败:', err);
            });
        }

        // 复制所有模块名称
        function copyAllModuleNames() {
            if (currentModuleNames.length === 0) {
                alert('暂无模块数据可复制');
                return;
            }

            const allModuleNames = currentModuleNames.join('\n');
            const button = document.getElementById('header-copy-modules');

            navigator.clipboard.writeText(allModuleNames).then(function() {
                button.classList.add('copied');
                const originalText = button.textContent;
                button.textContent = '✅ 已复制!';

                setTimeout(function() {
                    button.classList.remove('copied');
                    button.textContent = originalText;
                }, 2000);
            }).catch(function(err) {
                console.error('复制失败:', err);
            });
        }

        // 切换实时日志显示
        function toggleRealtimeLogs() {
            const realtimeModule = document.getElementById('realtime-logs-module');
            const button = document.getElementById('toggle-realtime-logs');
            const staticArea = document.querySelector('.static-modules-area');

            if (!realtimeModule || !staticArea) return;

            const isCurrentlyHidden = realtimeModule.style.display === 'none';

            if (isCurrentlyHidden) {
                // 显示实时日志模块
                realtimeModule.style.display = '';
                button.classList.add('active');
                button.textContent = '📊 隐藏实时原始日志';

                // 调整静态模块区域宽度为800px（两个模块）
                staticArea.style.flex = '0 0 820px'; // 考虑边框和内边距

                // 调整终端大小
                setTimeout(() => {
                    terminalManager.resizeTerminal('RealtimeLogs');
                    terminalManager.resizeTerminal('RawLogSnapshot');
                }, 150);
            } else {
                // 隐藏实时日志模块
                realtimeModule.style.display = 'none';
                button.classList.remove('active');
                button.textContent = '📊 显示实时原始日志';

                // 调整静态模块区域宽度为420px（一个模块）
                staticArea.style.flex = '0 0 420px'; // 考虑边框和内边距

                // 调整剩余模块的终端大小
                setTimeout(() => {
                    terminalManager.resizeTerminal('RawLogSnapshot');
                }, 150);
            }
        }

        // 检查Xterm.js是否加载完成 (适配新版本 @xterm/* 包)
        function checkXtermLoaded() {
            const terminalLoaded = typeof Terminal !== 'undefined';
            const fitAddonLoaded = typeof FitAddon !== 'undefined';
            const webLinksLoaded = typeof WebLinksAddon !== 'undefined';

            console.log('Xterm.js 5.5.0 库加载状态:', {
                Terminal: terminalLoaded,
                FitAddon: fitAddonLoaded,
                WebLinksAddon: webLinksLoaded,
                // 检查全局对象中的所有可用变量
                globalKeys: Object.keys(window).filter(key => key.toLowerCase().includes('addon') || key.toLowerCase().includes('fit') || key.toLowerCase().includes('weblinks')),
                // 检查具体的构造函数
                FitAddonType: typeof window.FitAddon,
                WebLinksAddonType: typeof window.WebLinksAddon,
                // 检查是否可以实例化
                canCreateFitAddon: typeof window.FitAddon === 'function',
                canCreateWebLinksAddon: typeof window.WebLinksAddon === 'function'
            });

            // 至少Terminal必须加载，插件是可选的
            return terminalLoaded;
        }

        // 等待Xterm.js加载完成后初始化
        function waitForXtermAndInitialize() {
            if (checkXtermLoaded()) {
                console.log('✅ Xterm.js 库加载完成');

                // 初始化固定终端
                initializeFixedTerminals();

                // 连接WebSocket
                connectWebSocket();

                // 绑定按钮事件
                document.getElementById('header-copy-modules').addEventListener('click', copyAllModuleNames);
                document.getElementById('toggle-realtime-logs').addEventListener('click', toggleRealtimeLogs);

                console.log('✅ 初始化完成');
            } else {
                console.log('⏳ 等待 Xterm.js 库加载...');
                setTimeout(waitForXtermAndInitialize, 300);
            }
        }

        // 页面加载完成后初始化
        document.addEventListener('DOMContentLoaded', function() {
            console.log('🚀 页面加载完成，开始初始化...');

            // 等待Xterm.js库加载完成
            waitForXtermAndInitialize();
        });

        // 窗口大小变化时调整所有终端
        window.addEventListener('resize', function() {
            setTimeout(() => {
                terminalManager.terminals.forEach((terminal, moduleName) => {
                    terminalManager.resizeTerminal(moduleName);
                });
            }, 100);
        });
    </script>
</body>
</html>
